
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model BlogPost
 * 
 */
export type BlogPost = $Result.DefaultSelection<Prisma.$BlogPostPayload>
/**
 * Model Author
 * 
 */
export type Author = $Result.DefaultSelection<Prisma.$AuthorPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model PostTag
 * 
 */
export type PostTag = $Result.DefaultSelection<Prisma.$PostTagPayload>
/**
 * Model PostRelation
 * 
 */
export type PostRelation = $Result.DefaultSelection<Prisma.$PostRelationPayload>
/**
 * Model PostVersion
 * 
 */
export type PostVersion = $Result.DefaultSelection<Prisma.$PostVersionPayload>
/**
 * Model PostSeries
 * 
 */
export type PostSeries = $Result.DefaultSelection<Prisma.$PostSeriesPayload>
/**
 * Model SeriesPost
 * 
 */
export type SeriesPost = $Result.DefaultSelection<Prisma.$SeriesPostPayload>
/**
 * Model PostView
 * 
 */
export type PostView = $Result.DefaultSelection<Prisma.$PostViewPayload>
/**
 * Model PostInteraction
 * 
 */
export type PostInteraction = $Result.DefaultSelection<Prisma.$PostInteractionPayload>
/**
 * Model SEOEvent
 * 
 */
export type SEOEvent = $Result.DefaultSelection<Prisma.$SEOEventPayload>
/**
 * Model SEOKeyword
 * 
 */
export type SEOKeyword = $Result.DefaultSelection<Prisma.$SEOKeywordPayload>
/**
 * Model SitemapEntry
 * 
 */
export type SitemapEntry = $Result.DefaultSelection<Prisma.$SitemapEntryPayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model ContactSubmission
 * 
 */
export type ContactSubmission = $Result.DefaultSelection<Prisma.$ContactSubmissionPayload>
/**
 * Model SecurityEvent
 * 
 */
export type SecurityEvent = $Result.DefaultSelection<Prisma.$SecurityEventPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const PostStatus: {
  DRAFT: 'DRAFT',
  REVIEW: 'REVIEW',
  SCHEDULED: 'SCHEDULED',
  PUBLISHED: 'PUBLISHED',
  ARCHIVED: 'ARCHIVED',
  DELETED: 'DELETED'
};

export type PostStatus = (typeof PostStatus)[keyof typeof PostStatus]


export const ContentType: {
  MARKDOWN: 'MARKDOWN',
  HTML: 'HTML',
  RICH_TEXT: 'RICH_TEXT'
};

export type ContentType = (typeof ContentType)[keyof typeof ContentType]


export const RelationType: {
  RELATED: 'RELATED',
  SEQUEL: 'SEQUEL',
  PREQUEL: 'PREQUEL',
  UPDATE: 'UPDATE',
  REFERENCE: 'REFERENCE'
};

export type RelationType = (typeof RelationType)[keyof typeof RelationType]


export const ChangeType: {
  MAJOR: 'MAJOR',
  MINOR: 'MINOR',
  PATCH: 'PATCH',
  CONTENT: 'CONTENT',
  SEO: 'SEO',
  STRUCTURE: 'STRUCTURE'
};

export type ChangeType = (typeof ChangeType)[keyof typeof ChangeType]


export const InteractionType: {
  LIKE: 'LIKE',
  SHARE: 'SHARE',
  COMMENT: 'COMMENT',
  BOOKMARK: 'BOOKMARK',
  SUBSCRIBE: 'SUBSCRIBE',
  DOWNLOAD: 'DOWNLOAD'
};

export type InteractionType = (typeof InteractionType)[keyof typeof InteractionType]


export const SEOEventType: {
  TITLE_CHANGE: 'TITLE_CHANGE',
  META_DESCRIPTION_CHANGE: 'META_DESCRIPTION_CHANGE',
  KEYWORD_UPDATE: 'KEYWORD_UPDATE',
  CONTENT_ANALYSIS: 'CONTENT_ANALYSIS',
  PERFORMANCE_ALERT: 'PERFORMANCE_ALERT',
  RANKING_CHANGE: 'RANKING_CHANGE',
  TECHNICAL_ISSUE: 'TECHNICAL_ISSUE',
  OPPORTUNITY: 'OPPORTUNITY'
};

export type SEOEventType = (typeof SEOEventType)[keyof typeof SEOEventType]


export const SEOSeverity: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  CRITICAL: 'CRITICAL',
  INFO: 'INFO'
};

export type SEOSeverity = (typeof SEOSeverity)[keyof typeof SEOSeverity]


export const ChangeFrequency: {
  ALWAYS: 'ALWAYS',
  HOURLY: 'HOURLY',
  DAILY: 'DAILY',
  WEEKLY: 'WEEKLY',
  MONTHLY: 'MONTHLY',
  YEARLY: 'YEARLY',
  NEVER: 'NEVER'
};

export type ChangeFrequency = (typeof ChangeFrequency)[keyof typeof ChangeFrequency]


export const SubmissionStatus: {
  NEW: 'NEW',
  READ: 'READ',
  IN_PROGRESS: 'IN_PROGRESS',
  RESPONDED: 'RESPONDED',
  ARCHIVED: 'ARCHIVED',
  SPAM: 'SPAM'
};

export type SubmissionStatus = (typeof SubmissionStatus)[keyof typeof SubmissionStatus]


export const SecurityEventType: {
  RATE_LIMIT_EXCEEDED: 'RATE_LIMIT_EXCEEDED',
  CSRF_VALIDATION_FAILED: 'CSRF_VALIDATION_FAILED',
  INVALID_INPUT: 'INVALID_INPUT',
  SUSPICIOUS_ACTIVITY: 'SUSPICIOUS_ACTIVITY',
  BOT_DETECTED: 'BOT_DETECTED',
  BRUTE_FORCE_ATTEMPT: 'BRUTE_FORCE_ATTEMPT',
  BLOCKED_REQUEST: 'BLOCKED_REQUEST',
  AUTH_FAILURE: 'AUTH_FAILURE',
  SQL_INJECTION_ATTEMPT: 'SQL_INJECTION_ATTEMPT',
  XSS_ATTEMPT: 'XSS_ATTEMPT',
  UNAUTHORIZED_ACCESS: 'UNAUTHORIZED_ACCESS'
};

export type SecurityEventType = (typeof SecurityEventType)[keyof typeof SecurityEventType]


export const SecuritySeverity: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  CRITICAL: 'CRITICAL'
};

export type SecuritySeverity = (typeof SecuritySeverity)[keyof typeof SecuritySeverity]

}

export type PostStatus = $Enums.PostStatus

export const PostStatus: typeof $Enums.PostStatus

export type ContentType = $Enums.ContentType

export const ContentType: typeof $Enums.ContentType

export type RelationType = $Enums.RelationType

export const RelationType: typeof $Enums.RelationType

export type ChangeType = $Enums.ChangeType

export const ChangeType: typeof $Enums.ChangeType

export type InteractionType = $Enums.InteractionType

export const InteractionType: typeof $Enums.InteractionType

export type SEOEventType = $Enums.SEOEventType

export const SEOEventType: typeof $Enums.SEOEventType

export type SEOSeverity = $Enums.SEOSeverity

export const SEOSeverity: typeof $Enums.SEOSeverity

export type ChangeFrequency = $Enums.ChangeFrequency

export const ChangeFrequency: typeof $Enums.ChangeFrequency

export type SubmissionStatus = $Enums.SubmissionStatus

export const SubmissionStatus: typeof $Enums.SubmissionStatus

export type SecurityEventType = $Enums.SecurityEventType

export const SecurityEventType: typeof $Enums.SecurityEventType

export type SecuritySeverity = $Enums.SecuritySeverity

export const SecuritySeverity: typeof $Enums.SecuritySeverity

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more BlogPosts
 * const blogPosts = await prisma.blogPost.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more BlogPosts
   * const blogPosts = await prisma.blogPost.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.blogPost`: Exposes CRUD operations for the **BlogPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlogPosts
    * const blogPosts = await prisma.blogPost.findMany()
    * ```
    */
  get blogPost(): Prisma.BlogPostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.author`: Exposes CRUD operations for the **Author** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Authors
    * const authors = await prisma.author.findMany()
    * ```
    */
  get author(): Prisma.AuthorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.postTag`: Exposes CRUD operations for the **PostTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostTags
    * const postTags = await prisma.postTag.findMany()
    * ```
    */
  get postTag(): Prisma.PostTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.postRelation`: Exposes CRUD operations for the **PostRelation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostRelations
    * const postRelations = await prisma.postRelation.findMany()
    * ```
    */
  get postRelation(): Prisma.PostRelationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.postVersion`: Exposes CRUD operations for the **PostVersion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostVersions
    * const postVersions = await prisma.postVersion.findMany()
    * ```
    */
  get postVersion(): Prisma.PostVersionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.postSeries`: Exposes CRUD operations for the **PostSeries** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostSeries
    * const postSeries = await prisma.postSeries.findMany()
    * ```
    */
  get postSeries(): Prisma.PostSeriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.seriesPost`: Exposes CRUD operations for the **SeriesPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SeriesPosts
    * const seriesPosts = await prisma.seriesPost.findMany()
    * ```
    */
  get seriesPost(): Prisma.SeriesPostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.postView`: Exposes CRUD operations for the **PostView** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostViews
    * const postViews = await prisma.postView.findMany()
    * ```
    */
  get postView(): Prisma.PostViewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.postInteraction`: Exposes CRUD operations for the **PostInteraction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostInteractions
    * const postInteractions = await prisma.postInteraction.findMany()
    * ```
    */
  get postInteraction(): Prisma.PostInteractionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sEOEvent`: Exposes CRUD operations for the **SEOEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SEOEvents
    * const sEOEvents = await prisma.sEOEvent.findMany()
    * ```
    */
  get sEOEvent(): Prisma.SEOEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sEOKeyword`: Exposes CRUD operations for the **SEOKeyword** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SEOKeywords
    * const sEOKeywords = await prisma.sEOKeyword.findMany()
    * ```
    */
  get sEOKeyword(): Prisma.SEOKeywordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sitemapEntry`: Exposes CRUD operations for the **SitemapEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SitemapEntries
    * const sitemapEntries = await prisma.sitemapEntry.findMany()
    * ```
    */
  get sitemapEntry(): Prisma.SitemapEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contactSubmission`: Exposes CRUD operations for the **ContactSubmission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContactSubmissions
    * const contactSubmissions = await prisma.contactSubmission.findMany()
    * ```
    */
  get contactSubmission(): Prisma.ContactSubmissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.securityEvent`: Exposes CRUD operations for the **SecurityEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SecurityEvents
    * const securityEvents = await prisma.securityEvent.findMany()
    * ```
    */
  get securityEvent(): Prisma.SecurityEventDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.2.0
   * Query Engine version: 0c8ef2ce45c83248ab3df073180d5eda9e8be7a3
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    BlogPost: 'BlogPost',
    Author: 'Author',
    Category: 'Category',
    Tag: 'Tag',
    PostTag: 'PostTag',
    PostRelation: 'PostRelation',
    PostVersion: 'PostVersion',
    PostSeries: 'PostSeries',
    SeriesPost: 'SeriesPost',
    PostView: 'PostView',
    PostInteraction: 'PostInteraction',
    SEOEvent: 'SEOEvent',
    SEOKeyword: 'SEOKeyword',
    SitemapEntry: 'SitemapEntry',
    Project: 'Project',
    ContactSubmission: 'ContactSubmission',
    SecurityEvent: 'SecurityEvent'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "blogPost" | "author" | "category" | "tag" | "postTag" | "postRelation" | "postVersion" | "postSeries" | "seriesPost" | "postView" | "postInteraction" | "sEOEvent" | "sEOKeyword" | "sitemapEntry" | "project" | "contactSubmission" | "securityEvent"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      BlogPost: {
        payload: Prisma.$BlogPostPayload<ExtArgs>
        fields: Prisma.BlogPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlogPostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlogPostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          findFirst: {
            args: Prisma.BlogPostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlogPostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          findMany: {
            args: Prisma.BlogPostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>[]
          }
          create: {
            args: Prisma.BlogPostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          createMany: {
            args: Prisma.BlogPostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlogPostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>[]
          }
          delete: {
            args: Prisma.BlogPostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          update: {
            args: Prisma.BlogPostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          deleteMany: {
            args: Prisma.BlogPostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlogPostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BlogPostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>[]
          }
          upsert: {
            args: Prisma.BlogPostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          aggregate: {
            args: Prisma.BlogPostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlogPost>
          }
          groupBy: {
            args: Prisma.BlogPostGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlogPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlogPostCountArgs<ExtArgs>
            result: $Utils.Optional<BlogPostCountAggregateOutputType> | number
          }
        }
      }
      Author: {
        payload: Prisma.$AuthorPayload<ExtArgs>
        fields: Prisma.AuthorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuthorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuthorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload>
          }
          findFirst: {
            args: Prisma.AuthorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuthorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload>
          }
          findMany: {
            args: Prisma.AuthorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload>[]
          }
          create: {
            args: Prisma.AuthorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload>
          }
          createMany: {
            args: Prisma.AuthorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuthorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload>[]
          }
          delete: {
            args: Prisma.AuthorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload>
          }
          update: {
            args: Prisma.AuthorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload>
          }
          deleteMany: {
            args: Prisma.AuthorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuthorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuthorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload>[]
          }
          upsert: {
            args: Prisma.AuthorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload>
          }
          aggregate: {
            args: Prisma.AuthorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuthor>
          }
          groupBy: {
            args: Prisma.AuthorGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuthorGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuthorCountArgs<ExtArgs>
            result: $Utils.Optional<AuthorCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      PostTag: {
        payload: Prisma.$PostTagPayload<ExtArgs>
        fields: Prisma.PostTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload>
          }
          findFirst: {
            args: Prisma.PostTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload>
          }
          findMany: {
            args: Prisma.PostTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload>[]
          }
          create: {
            args: Prisma.PostTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload>
          }
          createMany: {
            args: Prisma.PostTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload>[]
          }
          delete: {
            args: Prisma.PostTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload>
          }
          update: {
            args: Prisma.PostTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload>
          }
          deleteMany: {
            args: Prisma.PostTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PostTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload>[]
          }
          upsert: {
            args: Prisma.PostTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload>
          }
          aggregate: {
            args: Prisma.PostTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePostTag>
          }
          groupBy: {
            args: Prisma.PostTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostTagCountArgs<ExtArgs>
            result: $Utils.Optional<PostTagCountAggregateOutputType> | number
          }
        }
      }
      PostRelation: {
        payload: Prisma.$PostRelationPayload<ExtArgs>
        fields: Prisma.PostRelationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostRelationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostRelationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostRelationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostRelationPayload>
          }
          findFirst: {
            args: Prisma.PostRelationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostRelationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostRelationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostRelationPayload>
          }
          findMany: {
            args: Prisma.PostRelationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostRelationPayload>[]
          }
          create: {
            args: Prisma.PostRelationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostRelationPayload>
          }
          createMany: {
            args: Prisma.PostRelationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostRelationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostRelationPayload>[]
          }
          delete: {
            args: Prisma.PostRelationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostRelationPayload>
          }
          update: {
            args: Prisma.PostRelationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostRelationPayload>
          }
          deleteMany: {
            args: Prisma.PostRelationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostRelationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PostRelationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostRelationPayload>[]
          }
          upsert: {
            args: Prisma.PostRelationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostRelationPayload>
          }
          aggregate: {
            args: Prisma.PostRelationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePostRelation>
          }
          groupBy: {
            args: Prisma.PostRelationGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostRelationGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostRelationCountArgs<ExtArgs>
            result: $Utils.Optional<PostRelationCountAggregateOutputType> | number
          }
        }
      }
      PostVersion: {
        payload: Prisma.$PostVersionPayload<ExtArgs>
        fields: Prisma.PostVersionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostVersionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostVersionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostVersionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostVersionPayload>
          }
          findFirst: {
            args: Prisma.PostVersionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostVersionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostVersionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostVersionPayload>
          }
          findMany: {
            args: Prisma.PostVersionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostVersionPayload>[]
          }
          create: {
            args: Prisma.PostVersionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostVersionPayload>
          }
          createMany: {
            args: Prisma.PostVersionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostVersionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostVersionPayload>[]
          }
          delete: {
            args: Prisma.PostVersionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostVersionPayload>
          }
          update: {
            args: Prisma.PostVersionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostVersionPayload>
          }
          deleteMany: {
            args: Prisma.PostVersionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostVersionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PostVersionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostVersionPayload>[]
          }
          upsert: {
            args: Prisma.PostVersionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostVersionPayload>
          }
          aggregate: {
            args: Prisma.PostVersionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePostVersion>
          }
          groupBy: {
            args: Prisma.PostVersionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostVersionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostVersionCountArgs<ExtArgs>
            result: $Utils.Optional<PostVersionCountAggregateOutputType> | number
          }
        }
      }
      PostSeries: {
        payload: Prisma.$PostSeriesPayload<ExtArgs>
        fields: Prisma.PostSeriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostSeriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostSeriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostSeriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostSeriesPayload>
          }
          findFirst: {
            args: Prisma.PostSeriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostSeriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostSeriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostSeriesPayload>
          }
          findMany: {
            args: Prisma.PostSeriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostSeriesPayload>[]
          }
          create: {
            args: Prisma.PostSeriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostSeriesPayload>
          }
          createMany: {
            args: Prisma.PostSeriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostSeriesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostSeriesPayload>[]
          }
          delete: {
            args: Prisma.PostSeriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostSeriesPayload>
          }
          update: {
            args: Prisma.PostSeriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostSeriesPayload>
          }
          deleteMany: {
            args: Prisma.PostSeriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostSeriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PostSeriesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostSeriesPayload>[]
          }
          upsert: {
            args: Prisma.PostSeriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostSeriesPayload>
          }
          aggregate: {
            args: Prisma.PostSeriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePostSeries>
          }
          groupBy: {
            args: Prisma.PostSeriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostSeriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostSeriesCountArgs<ExtArgs>
            result: $Utils.Optional<PostSeriesCountAggregateOutputType> | number
          }
        }
      }
      SeriesPost: {
        payload: Prisma.$SeriesPostPayload<ExtArgs>
        fields: Prisma.SeriesPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SeriesPostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SeriesPostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPostPayload>
          }
          findFirst: {
            args: Prisma.SeriesPostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SeriesPostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPostPayload>
          }
          findMany: {
            args: Prisma.SeriesPostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPostPayload>[]
          }
          create: {
            args: Prisma.SeriesPostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPostPayload>
          }
          createMany: {
            args: Prisma.SeriesPostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SeriesPostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPostPayload>[]
          }
          delete: {
            args: Prisma.SeriesPostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPostPayload>
          }
          update: {
            args: Prisma.SeriesPostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPostPayload>
          }
          deleteMany: {
            args: Prisma.SeriesPostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SeriesPostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SeriesPostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPostPayload>[]
          }
          upsert: {
            args: Prisma.SeriesPostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPostPayload>
          }
          aggregate: {
            args: Prisma.SeriesPostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeriesPost>
          }
          groupBy: {
            args: Prisma.SeriesPostGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeriesPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.SeriesPostCountArgs<ExtArgs>
            result: $Utils.Optional<SeriesPostCountAggregateOutputType> | number
          }
        }
      }
      PostView: {
        payload: Prisma.$PostViewPayload<ExtArgs>
        fields: Prisma.PostViewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostViewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostViewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostViewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostViewPayload>
          }
          findFirst: {
            args: Prisma.PostViewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostViewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostViewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostViewPayload>
          }
          findMany: {
            args: Prisma.PostViewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostViewPayload>[]
          }
          create: {
            args: Prisma.PostViewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostViewPayload>
          }
          createMany: {
            args: Prisma.PostViewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostViewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostViewPayload>[]
          }
          delete: {
            args: Prisma.PostViewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostViewPayload>
          }
          update: {
            args: Prisma.PostViewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostViewPayload>
          }
          deleteMany: {
            args: Prisma.PostViewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostViewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PostViewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostViewPayload>[]
          }
          upsert: {
            args: Prisma.PostViewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostViewPayload>
          }
          aggregate: {
            args: Prisma.PostViewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePostView>
          }
          groupBy: {
            args: Prisma.PostViewGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostViewGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostViewCountArgs<ExtArgs>
            result: $Utils.Optional<PostViewCountAggregateOutputType> | number
          }
        }
      }
      PostInteraction: {
        payload: Prisma.$PostInteractionPayload<ExtArgs>
        fields: Prisma.PostInteractionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostInteractionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostInteractionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostInteractionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostInteractionPayload>
          }
          findFirst: {
            args: Prisma.PostInteractionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostInteractionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostInteractionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostInteractionPayload>
          }
          findMany: {
            args: Prisma.PostInteractionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostInteractionPayload>[]
          }
          create: {
            args: Prisma.PostInteractionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostInteractionPayload>
          }
          createMany: {
            args: Prisma.PostInteractionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostInteractionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostInteractionPayload>[]
          }
          delete: {
            args: Prisma.PostInteractionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostInteractionPayload>
          }
          update: {
            args: Prisma.PostInteractionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostInteractionPayload>
          }
          deleteMany: {
            args: Prisma.PostInteractionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostInteractionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PostInteractionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostInteractionPayload>[]
          }
          upsert: {
            args: Prisma.PostInteractionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostInteractionPayload>
          }
          aggregate: {
            args: Prisma.PostInteractionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePostInteraction>
          }
          groupBy: {
            args: Prisma.PostInteractionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostInteractionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostInteractionCountArgs<ExtArgs>
            result: $Utils.Optional<PostInteractionCountAggregateOutputType> | number
          }
        }
      }
      SEOEvent: {
        payload: Prisma.$SEOEventPayload<ExtArgs>
        fields: Prisma.SEOEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SEOEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SEOEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SEOEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SEOEventPayload>
          }
          findFirst: {
            args: Prisma.SEOEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SEOEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SEOEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SEOEventPayload>
          }
          findMany: {
            args: Prisma.SEOEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SEOEventPayload>[]
          }
          create: {
            args: Prisma.SEOEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SEOEventPayload>
          }
          createMany: {
            args: Prisma.SEOEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SEOEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SEOEventPayload>[]
          }
          delete: {
            args: Prisma.SEOEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SEOEventPayload>
          }
          update: {
            args: Prisma.SEOEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SEOEventPayload>
          }
          deleteMany: {
            args: Prisma.SEOEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SEOEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SEOEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SEOEventPayload>[]
          }
          upsert: {
            args: Prisma.SEOEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SEOEventPayload>
          }
          aggregate: {
            args: Prisma.SEOEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSEOEvent>
          }
          groupBy: {
            args: Prisma.SEOEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<SEOEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.SEOEventCountArgs<ExtArgs>
            result: $Utils.Optional<SEOEventCountAggregateOutputType> | number
          }
        }
      }
      SEOKeyword: {
        payload: Prisma.$SEOKeywordPayload<ExtArgs>
        fields: Prisma.SEOKeywordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SEOKeywordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SEOKeywordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SEOKeywordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SEOKeywordPayload>
          }
          findFirst: {
            args: Prisma.SEOKeywordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SEOKeywordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SEOKeywordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SEOKeywordPayload>
          }
          findMany: {
            args: Prisma.SEOKeywordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SEOKeywordPayload>[]
          }
          create: {
            args: Prisma.SEOKeywordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SEOKeywordPayload>
          }
          createMany: {
            args: Prisma.SEOKeywordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SEOKeywordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SEOKeywordPayload>[]
          }
          delete: {
            args: Prisma.SEOKeywordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SEOKeywordPayload>
          }
          update: {
            args: Prisma.SEOKeywordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SEOKeywordPayload>
          }
          deleteMany: {
            args: Prisma.SEOKeywordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SEOKeywordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SEOKeywordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SEOKeywordPayload>[]
          }
          upsert: {
            args: Prisma.SEOKeywordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SEOKeywordPayload>
          }
          aggregate: {
            args: Prisma.SEOKeywordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSEOKeyword>
          }
          groupBy: {
            args: Prisma.SEOKeywordGroupByArgs<ExtArgs>
            result: $Utils.Optional<SEOKeywordGroupByOutputType>[]
          }
          count: {
            args: Prisma.SEOKeywordCountArgs<ExtArgs>
            result: $Utils.Optional<SEOKeywordCountAggregateOutputType> | number
          }
        }
      }
      SitemapEntry: {
        payload: Prisma.$SitemapEntryPayload<ExtArgs>
        fields: Prisma.SitemapEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SitemapEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitemapEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SitemapEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitemapEntryPayload>
          }
          findFirst: {
            args: Prisma.SitemapEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitemapEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SitemapEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitemapEntryPayload>
          }
          findMany: {
            args: Prisma.SitemapEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitemapEntryPayload>[]
          }
          create: {
            args: Prisma.SitemapEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitemapEntryPayload>
          }
          createMany: {
            args: Prisma.SitemapEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SitemapEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitemapEntryPayload>[]
          }
          delete: {
            args: Prisma.SitemapEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitemapEntryPayload>
          }
          update: {
            args: Prisma.SitemapEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitemapEntryPayload>
          }
          deleteMany: {
            args: Prisma.SitemapEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SitemapEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SitemapEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitemapEntryPayload>[]
          }
          upsert: {
            args: Prisma.SitemapEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitemapEntryPayload>
          }
          aggregate: {
            args: Prisma.SitemapEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSitemapEntry>
          }
          groupBy: {
            args: Prisma.SitemapEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SitemapEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.SitemapEntryCountArgs<ExtArgs>
            result: $Utils.Optional<SitemapEntryCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      ContactSubmission: {
        payload: Prisma.$ContactSubmissionPayload<ExtArgs>
        fields: Prisma.ContactSubmissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactSubmissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactSubmissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload>
          }
          findFirst: {
            args: Prisma.ContactSubmissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactSubmissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload>
          }
          findMany: {
            args: Prisma.ContactSubmissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload>[]
          }
          create: {
            args: Prisma.ContactSubmissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload>
          }
          createMany: {
            args: Prisma.ContactSubmissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactSubmissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload>[]
          }
          delete: {
            args: Prisma.ContactSubmissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload>
          }
          update: {
            args: Prisma.ContactSubmissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload>
          }
          deleteMany: {
            args: Prisma.ContactSubmissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactSubmissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactSubmissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload>[]
          }
          upsert: {
            args: Prisma.ContactSubmissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload>
          }
          aggregate: {
            args: Prisma.ContactSubmissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactSubmission>
          }
          groupBy: {
            args: Prisma.ContactSubmissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactSubmissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactSubmissionCountArgs<ExtArgs>
            result: $Utils.Optional<ContactSubmissionCountAggregateOutputType> | number
          }
        }
      }
      SecurityEvent: {
        payload: Prisma.$SecurityEventPayload<ExtArgs>
        fields: Prisma.SecurityEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SecurityEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SecurityEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload>
          }
          findFirst: {
            args: Prisma.SecurityEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SecurityEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload>
          }
          findMany: {
            args: Prisma.SecurityEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload>[]
          }
          create: {
            args: Prisma.SecurityEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload>
          }
          createMany: {
            args: Prisma.SecurityEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SecurityEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload>[]
          }
          delete: {
            args: Prisma.SecurityEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload>
          }
          update: {
            args: Prisma.SecurityEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload>
          }
          deleteMany: {
            args: Prisma.SecurityEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SecurityEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SecurityEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload>[]
          }
          upsert: {
            args: Prisma.SecurityEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload>
          }
          aggregate: {
            args: Prisma.SecurityEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSecurityEvent>
          }
          groupBy: {
            args: Prisma.SecurityEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<SecurityEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.SecurityEventCountArgs<ExtArgs>
            result: $Utils.Optional<SecurityEventCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    blogPost?: BlogPostOmit
    author?: AuthorOmit
    category?: CategoryOmit
    tag?: TagOmit
    postTag?: PostTagOmit
    postRelation?: PostRelationOmit
    postVersion?: PostVersionOmit
    postSeries?: PostSeriesOmit
    seriesPost?: SeriesPostOmit
    postView?: PostViewOmit
    postInteraction?: PostInteractionOmit
    sEOEvent?: SEOEventOmit
    sEOKeyword?: SEOKeywordOmit
    sitemapEntry?: SitemapEntryOmit
    project?: ProjectOmit
    contactSubmission?: ContactSubmissionOmit
    securityEvent?: SecurityEventOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BlogPostCountOutputType
   */

  export type BlogPostCountOutputType = {
    tags: number
    seriesPosts: number
    relatedPosts: number
    relatedToPosts: number
    versions: number
    views: number
    interactions: number
    seoEvents: number
    seoKeywords: number
    sitemapEntries: number
  }

  export type BlogPostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tags?: boolean | BlogPostCountOutputTypeCountTagsArgs
    seriesPosts?: boolean | BlogPostCountOutputTypeCountSeriesPostsArgs
    relatedPosts?: boolean | BlogPostCountOutputTypeCountRelatedPostsArgs
    relatedToPosts?: boolean | BlogPostCountOutputTypeCountRelatedToPostsArgs
    versions?: boolean | BlogPostCountOutputTypeCountVersionsArgs
    views?: boolean | BlogPostCountOutputTypeCountViewsArgs
    interactions?: boolean | BlogPostCountOutputTypeCountInteractionsArgs
    seoEvents?: boolean | BlogPostCountOutputTypeCountSeoEventsArgs
    seoKeywords?: boolean | BlogPostCountOutputTypeCountSeoKeywordsArgs
    sitemapEntries?: boolean | BlogPostCountOutputTypeCountSitemapEntriesArgs
  }

  // Custom InputTypes
  /**
   * BlogPostCountOutputType without action
   */
  export type BlogPostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostCountOutputType
     */
    select?: BlogPostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BlogPostCountOutputType without action
   */
  export type BlogPostCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostTagWhereInput
  }

  /**
   * BlogPostCountOutputType without action
   */
  export type BlogPostCountOutputTypeCountSeriesPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeriesPostWhereInput
  }

  /**
   * BlogPostCountOutputType without action
   */
  export type BlogPostCountOutputTypeCountRelatedPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostRelationWhereInput
  }

  /**
   * BlogPostCountOutputType without action
   */
  export type BlogPostCountOutputTypeCountRelatedToPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostRelationWhereInput
  }

  /**
   * BlogPostCountOutputType without action
   */
  export type BlogPostCountOutputTypeCountVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostVersionWhereInput
  }

  /**
   * BlogPostCountOutputType without action
   */
  export type BlogPostCountOutputTypeCountViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostViewWhereInput
  }

  /**
   * BlogPostCountOutputType without action
   */
  export type BlogPostCountOutputTypeCountInteractionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostInteractionWhereInput
  }

  /**
   * BlogPostCountOutputType without action
   */
  export type BlogPostCountOutputTypeCountSeoEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SEOEventWhereInput
  }

  /**
   * BlogPostCountOutputType without action
   */
  export type BlogPostCountOutputTypeCountSeoKeywordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SEOKeywordWhereInput
  }

  /**
   * BlogPostCountOutputType without action
   */
  export type BlogPostCountOutputTypeCountSitemapEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SitemapEntryWhereInput
  }


  /**
   * Count Type AuthorCountOutputType
   */

  export type AuthorCountOutputType = {
    posts: number
    postVersions: number
  }

  export type AuthorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | AuthorCountOutputTypeCountPostsArgs
    postVersions?: boolean | AuthorCountOutputTypeCountPostVersionsArgs
  }

  // Custom InputTypes
  /**
   * AuthorCountOutputType without action
   */
  export type AuthorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthorCountOutputType
     */
    select?: AuthorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AuthorCountOutputType without action
   */
  export type AuthorCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogPostWhereInput
  }

  /**
   * AuthorCountOutputType without action
   */
  export type AuthorCountOutputTypeCountPostVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostVersionWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    children: number
    posts: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | CategoryCountOutputTypeCountChildrenArgs
    posts?: boolean | CategoryCountOutputTypeCountPostsArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogPostWhereInput
  }


  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    posts: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | TagCountOutputTypeCountPostsArgs
  }

  // Custom InputTypes
  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostTagWhereInput
  }


  /**
   * Count Type PostSeriesCountOutputType
   */

  export type PostSeriesCountOutputType = {
    posts: number
  }

  export type PostSeriesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | PostSeriesCountOutputTypeCountPostsArgs
  }

  // Custom InputTypes
  /**
   * PostSeriesCountOutputType without action
   */
  export type PostSeriesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostSeriesCountOutputType
     */
    select?: PostSeriesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PostSeriesCountOutputType without action
   */
  export type PostSeriesCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeriesPostWhereInput
  }


  /**
   * Models
   */

  /**
   * Model BlogPost
   */

  export type AggregateBlogPost = {
    _count: BlogPostCountAggregateOutputType | null
    _avg: BlogPostAvgAggregateOutputType | null
    _sum: BlogPostSumAggregateOutputType | null
    _min: BlogPostMinAggregateOutputType | null
    _max: BlogPostMaxAggregateOutputType | null
  }

  export type BlogPostAvgAggregateOutputType = {
    readingTime: number | null
    wordCount: number | null
    currentVersion: number | null
    viewCount: number | null
    likeCount: number | null
    shareCount: number | null
    commentCount: number | null
    seoScore: number | null
  }

  export type BlogPostSumAggregateOutputType = {
    readingTime: number | null
    wordCount: number | null
    currentVersion: number | null
    viewCount: number | null
    likeCount: number | null
    shareCount: number | null
    commentCount: number | null
    seoScore: number | null
  }

  export type BlogPostMinAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    excerpt: string | null
    content: string | null
    contentType: $Enums.ContentType | null
    status: $Enums.PostStatus | null
    metaTitle: string | null
    metaDescription: string | null
    canonicalUrl: string | null
    ogTitle: string | null
    ogDescription: string | null
    ogImage: string | null
    twitterTitle: string | null
    twitterDescription: string | null
    twitterImage: string | null
    featuredImage: string | null
    featuredImageAlt: string | null
    readingTime: number | null
    wordCount: number | null
    publishedAt: Date | null
    scheduledAt: Date | null
    archivedAt: Date | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    authorId: string | null
    categoryId: string | null
    currentVersion: number | null
    viewCount: number | null
    likeCount: number | null
    shareCount: number | null
    commentCount: number | null
    seoScore: number | null
    lastSeoCheck: Date | null
  }

  export type BlogPostMaxAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    excerpt: string | null
    content: string | null
    contentType: $Enums.ContentType | null
    status: $Enums.PostStatus | null
    metaTitle: string | null
    metaDescription: string | null
    canonicalUrl: string | null
    ogTitle: string | null
    ogDescription: string | null
    ogImage: string | null
    twitterTitle: string | null
    twitterDescription: string | null
    twitterImage: string | null
    featuredImage: string | null
    featuredImageAlt: string | null
    readingTime: number | null
    wordCount: number | null
    publishedAt: Date | null
    scheduledAt: Date | null
    archivedAt: Date | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    authorId: string | null
    categoryId: string | null
    currentVersion: number | null
    viewCount: number | null
    likeCount: number | null
    shareCount: number | null
    commentCount: number | null
    seoScore: number | null
    lastSeoCheck: Date | null
  }

  export type BlogPostCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    excerpt: number
    content: number
    contentType: number
    status: number
    metaTitle: number
    metaDescription: number
    keywords: number
    canonicalUrl: number
    ogTitle: number
    ogDescription: number
    ogImage: number
    twitterTitle: number
    twitterDescription: number
    twitterImage: number
    featuredImage: number
    featuredImageAlt: number
    readingTime: number
    wordCount: number
    publishedAt: number
    scheduledAt: number
    archivedAt: number
    deletedAt: number
    createdAt: number
    updatedAt: number
    authorId: number
    categoryId: number
    currentVersion: number
    viewCount: number
    likeCount: number
    shareCount: number
    commentCount: number
    seoScore: number
    seoAnalysis: number
    lastSeoCheck: number
    _all: number
  }


  export type BlogPostAvgAggregateInputType = {
    readingTime?: true
    wordCount?: true
    currentVersion?: true
    viewCount?: true
    likeCount?: true
    shareCount?: true
    commentCount?: true
    seoScore?: true
  }

  export type BlogPostSumAggregateInputType = {
    readingTime?: true
    wordCount?: true
    currentVersion?: true
    viewCount?: true
    likeCount?: true
    shareCount?: true
    commentCount?: true
    seoScore?: true
  }

  export type BlogPostMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    excerpt?: true
    content?: true
    contentType?: true
    status?: true
    metaTitle?: true
    metaDescription?: true
    canonicalUrl?: true
    ogTitle?: true
    ogDescription?: true
    ogImage?: true
    twitterTitle?: true
    twitterDescription?: true
    twitterImage?: true
    featuredImage?: true
    featuredImageAlt?: true
    readingTime?: true
    wordCount?: true
    publishedAt?: true
    scheduledAt?: true
    archivedAt?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    authorId?: true
    categoryId?: true
    currentVersion?: true
    viewCount?: true
    likeCount?: true
    shareCount?: true
    commentCount?: true
    seoScore?: true
    lastSeoCheck?: true
  }

  export type BlogPostMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    excerpt?: true
    content?: true
    contentType?: true
    status?: true
    metaTitle?: true
    metaDescription?: true
    canonicalUrl?: true
    ogTitle?: true
    ogDescription?: true
    ogImage?: true
    twitterTitle?: true
    twitterDescription?: true
    twitterImage?: true
    featuredImage?: true
    featuredImageAlt?: true
    readingTime?: true
    wordCount?: true
    publishedAt?: true
    scheduledAt?: true
    archivedAt?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    authorId?: true
    categoryId?: true
    currentVersion?: true
    viewCount?: true
    likeCount?: true
    shareCount?: true
    commentCount?: true
    seoScore?: true
    lastSeoCheck?: true
  }

  export type BlogPostCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    excerpt?: true
    content?: true
    contentType?: true
    status?: true
    metaTitle?: true
    metaDescription?: true
    keywords?: true
    canonicalUrl?: true
    ogTitle?: true
    ogDescription?: true
    ogImage?: true
    twitterTitle?: true
    twitterDescription?: true
    twitterImage?: true
    featuredImage?: true
    featuredImageAlt?: true
    readingTime?: true
    wordCount?: true
    publishedAt?: true
    scheduledAt?: true
    archivedAt?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    authorId?: true
    categoryId?: true
    currentVersion?: true
    viewCount?: true
    likeCount?: true
    shareCount?: true
    commentCount?: true
    seoScore?: true
    seoAnalysis?: true
    lastSeoCheck?: true
    _all?: true
  }

  export type BlogPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogPost to aggregate.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlogPosts
    **/
    _count?: true | BlogPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlogPostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlogPostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogPostMaxAggregateInputType
  }

  export type GetBlogPostAggregateType<T extends BlogPostAggregateArgs> = {
        [P in keyof T & keyof AggregateBlogPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlogPost[P]>
      : GetScalarType<T[P], AggregateBlogPost[P]>
  }




  export type BlogPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogPostWhereInput
    orderBy?: BlogPostOrderByWithAggregationInput | BlogPostOrderByWithAggregationInput[]
    by: BlogPostScalarFieldEnum[] | BlogPostScalarFieldEnum
    having?: BlogPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogPostCountAggregateInputType | true
    _avg?: BlogPostAvgAggregateInputType
    _sum?: BlogPostSumAggregateInputType
    _min?: BlogPostMinAggregateInputType
    _max?: BlogPostMaxAggregateInputType
  }

  export type BlogPostGroupByOutputType = {
    id: string
    title: string
    slug: string
    excerpt: string | null
    content: string
    contentType: $Enums.ContentType
    status: $Enums.PostStatus
    metaTitle: string | null
    metaDescription: string | null
    keywords: string[]
    canonicalUrl: string | null
    ogTitle: string | null
    ogDescription: string | null
    ogImage: string | null
    twitterTitle: string | null
    twitterDescription: string | null
    twitterImage: string | null
    featuredImage: string | null
    featuredImageAlt: string | null
    readingTime: number | null
    wordCount: number | null
    publishedAt: Date | null
    scheduledAt: Date | null
    archivedAt: Date | null
    deletedAt: Date | null
    createdAt: Date
    updatedAt: Date
    authorId: string
    categoryId: string | null
    currentVersion: number
    viewCount: number
    likeCount: number
    shareCount: number
    commentCount: number
    seoScore: number | null
    seoAnalysis: JsonValue | null
    lastSeoCheck: Date | null
    _count: BlogPostCountAggregateOutputType | null
    _avg: BlogPostAvgAggregateOutputType | null
    _sum: BlogPostSumAggregateOutputType | null
    _min: BlogPostMinAggregateOutputType | null
    _max: BlogPostMaxAggregateOutputType | null
  }

  type GetBlogPostGroupByPayload<T extends BlogPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlogPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogPostGroupByOutputType[P]>
            : GetScalarType<T[P], BlogPostGroupByOutputType[P]>
        }
      >
    >


  export type BlogPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    excerpt?: boolean
    content?: boolean
    contentType?: boolean
    status?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    keywords?: boolean
    canonicalUrl?: boolean
    ogTitle?: boolean
    ogDescription?: boolean
    ogImage?: boolean
    twitterTitle?: boolean
    twitterDescription?: boolean
    twitterImage?: boolean
    featuredImage?: boolean
    featuredImageAlt?: boolean
    readingTime?: boolean
    wordCount?: boolean
    publishedAt?: boolean
    scheduledAt?: boolean
    archivedAt?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authorId?: boolean
    categoryId?: boolean
    currentVersion?: boolean
    viewCount?: boolean
    likeCount?: boolean
    shareCount?: boolean
    commentCount?: boolean
    seoScore?: boolean
    seoAnalysis?: boolean
    lastSeoCheck?: boolean
    author?: boolean | AuthorDefaultArgs<ExtArgs>
    category?: boolean | BlogPost$categoryArgs<ExtArgs>
    tags?: boolean | BlogPost$tagsArgs<ExtArgs>
    seriesPosts?: boolean | BlogPost$seriesPostsArgs<ExtArgs>
    relatedPosts?: boolean | BlogPost$relatedPostsArgs<ExtArgs>
    relatedToPosts?: boolean | BlogPost$relatedToPostsArgs<ExtArgs>
    versions?: boolean | BlogPost$versionsArgs<ExtArgs>
    views?: boolean | BlogPost$viewsArgs<ExtArgs>
    interactions?: boolean | BlogPost$interactionsArgs<ExtArgs>
    seoEvents?: boolean | BlogPost$seoEventsArgs<ExtArgs>
    seoKeywords?: boolean | BlogPost$seoKeywordsArgs<ExtArgs>
    sitemapEntries?: boolean | BlogPost$sitemapEntriesArgs<ExtArgs>
    _count?: boolean | BlogPostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogPost"]>

  export type BlogPostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    excerpt?: boolean
    content?: boolean
    contentType?: boolean
    status?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    keywords?: boolean
    canonicalUrl?: boolean
    ogTitle?: boolean
    ogDescription?: boolean
    ogImage?: boolean
    twitterTitle?: boolean
    twitterDescription?: boolean
    twitterImage?: boolean
    featuredImage?: boolean
    featuredImageAlt?: boolean
    readingTime?: boolean
    wordCount?: boolean
    publishedAt?: boolean
    scheduledAt?: boolean
    archivedAt?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authorId?: boolean
    categoryId?: boolean
    currentVersion?: boolean
    viewCount?: boolean
    likeCount?: boolean
    shareCount?: boolean
    commentCount?: boolean
    seoScore?: boolean
    seoAnalysis?: boolean
    lastSeoCheck?: boolean
    author?: boolean | AuthorDefaultArgs<ExtArgs>
    category?: boolean | BlogPost$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["blogPost"]>

  export type BlogPostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    excerpt?: boolean
    content?: boolean
    contentType?: boolean
    status?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    keywords?: boolean
    canonicalUrl?: boolean
    ogTitle?: boolean
    ogDescription?: boolean
    ogImage?: boolean
    twitterTitle?: boolean
    twitterDescription?: boolean
    twitterImage?: boolean
    featuredImage?: boolean
    featuredImageAlt?: boolean
    readingTime?: boolean
    wordCount?: boolean
    publishedAt?: boolean
    scheduledAt?: boolean
    archivedAt?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authorId?: boolean
    categoryId?: boolean
    currentVersion?: boolean
    viewCount?: boolean
    likeCount?: boolean
    shareCount?: boolean
    commentCount?: boolean
    seoScore?: boolean
    seoAnalysis?: boolean
    lastSeoCheck?: boolean
    author?: boolean | AuthorDefaultArgs<ExtArgs>
    category?: boolean | BlogPost$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["blogPost"]>

  export type BlogPostSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    excerpt?: boolean
    content?: boolean
    contentType?: boolean
    status?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    keywords?: boolean
    canonicalUrl?: boolean
    ogTitle?: boolean
    ogDescription?: boolean
    ogImage?: boolean
    twitterTitle?: boolean
    twitterDescription?: boolean
    twitterImage?: boolean
    featuredImage?: boolean
    featuredImageAlt?: boolean
    readingTime?: boolean
    wordCount?: boolean
    publishedAt?: boolean
    scheduledAt?: boolean
    archivedAt?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authorId?: boolean
    categoryId?: boolean
    currentVersion?: boolean
    viewCount?: boolean
    likeCount?: boolean
    shareCount?: boolean
    commentCount?: boolean
    seoScore?: boolean
    seoAnalysis?: boolean
    lastSeoCheck?: boolean
  }

  export type BlogPostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "slug" | "excerpt" | "content" | "contentType" | "status" | "metaTitle" | "metaDescription" | "keywords" | "canonicalUrl" | "ogTitle" | "ogDescription" | "ogImage" | "twitterTitle" | "twitterDescription" | "twitterImage" | "featuredImage" | "featuredImageAlt" | "readingTime" | "wordCount" | "publishedAt" | "scheduledAt" | "archivedAt" | "deletedAt" | "createdAt" | "updatedAt" | "authorId" | "categoryId" | "currentVersion" | "viewCount" | "likeCount" | "shareCount" | "commentCount" | "seoScore" | "seoAnalysis" | "lastSeoCheck", ExtArgs["result"]["blogPost"]>
  export type BlogPostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | AuthorDefaultArgs<ExtArgs>
    category?: boolean | BlogPost$categoryArgs<ExtArgs>
    tags?: boolean | BlogPost$tagsArgs<ExtArgs>
    seriesPosts?: boolean | BlogPost$seriesPostsArgs<ExtArgs>
    relatedPosts?: boolean | BlogPost$relatedPostsArgs<ExtArgs>
    relatedToPosts?: boolean | BlogPost$relatedToPostsArgs<ExtArgs>
    versions?: boolean | BlogPost$versionsArgs<ExtArgs>
    views?: boolean | BlogPost$viewsArgs<ExtArgs>
    interactions?: boolean | BlogPost$interactionsArgs<ExtArgs>
    seoEvents?: boolean | BlogPost$seoEventsArgs<ExtArgs>
    seoKeywords?: boolean | BlogPost$seoKeywordsArgs<ExtArgs>
    sitemapEntries?: boolean | BlogPost$sitemapEntriesArgs<ExtArgs>
    _count?: boolean | BlogPostCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BlogPostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | AuthorDefaultArgs<ExtArgs>
    category?: boolean | BlogPost$categoryArgs<ExtArgs>
  }
  export type BlogPostIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | AuthorDefaultArgs<ExtArgs>
    category?: boolean | BlogPost$categoryArgs<ExtArgs>
  }

  export type $BlogPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlogPost"
    objects: {
      author: Prisma.$AuthorPayload<ExtArgs>
      category: Prisma.$CategoryPayload<ExtArgs> | null
      tags: Prisma.$PostTagPayload<ExtArgs>[]
      seriesPosts: Prisma.$SeriesPostPayload<ExtArgs>[]
      relatedPosts: Prisma.$PostRelationPayload<ExtArgs>[]
      relatedToPosts: Prisma.$PostRelationPayload<ExtArgs>[]
      versions: Prisma.$PostVersionPayload<ExtArgs>[]
      views: Prisma.$PostViewPayload<ExtArgs>[]
      interactions: Prisma.$PostInteractionPayload<ExtArgs>[]
      seoEvents: Prisma.$SEOEventPayload<ExtArgs>[]
      seoKeywords: Prisma.$SEOKeywordPayload<ExtArgs>[]
      sitemapEntries: Prisma.$SitemapEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      slug: string
      excerpt: string | null
      content: string
      contentType: $Enums.ContentType
      status: $Enums.PostStatus
      metaTitle: string | null
      metaDescription: string | null
      keywords: string[]
      canonicalUrl: string | null
      ogTitle: string | null
      ogDescription: string | null
      ogImage: string | null
      twitterTitle: string | null
      twitterDescription: string | null
      twitterImage: string | null
      featuredImage: string | null
      featuredImageAlt: string | null
      readingTime: number | null
      wordCount: number | null
      publishedAt: Date | null
      scheduledAt: Date | null
      archivedAt: Date | null
      deletedAt: Date | null
      createdAt: Date
      updatedAt: Date
      authorId: string
      categoryId: string | null
      currentVersion: number
      viewCount: number
      likeCount: number
      shareCount: number
      commentCount: number
      seoScore: number | null
      seoAnalysis: Prisma.JsonValue | null
      lastSeoCheck: Date | null
    }, ExtArgs["result"]["blogPost"]>
    composites: {}
  }

  type BlogPostGetPayload<S extends boolean | null | undefined | BlogPostDefaultArgs> = $Result.GetResult<Prisma.$BlogPostPayload, S>

  type BlogPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlogPostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlogPostCountAggregateInputType | true
    }

  export interface BlogPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlogPost'], meta: { name: 'BlogPost' } }
    /**
     * Find zero or one BlogPost that matches the filter.
     * @param {BlogPostFindUniqueArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlogPostFindUniqueArgs>(args: SelectSubset<T, BlogPostFindUniqueArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BlogPost that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlogPostFindUniqueOrThrowArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlogPostFindUniqueOrThrowArgs>(args: SelectSubset<T, BlogPostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlogPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostFindFirstArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlogPostFindFirstArgs>(args?: SelectSubset<T, BlogPostFindFirstArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlogPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostFindFirstOrThrowArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlogPostFindFirstOrThrowArgs>(args?: SelectSubset<T, BlogPostFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BlogPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlogPosts
     * const blogPosts = await prisma.blogPost.findMany()
     * 
     * // Get first 10 BlogPosts
     * const blogPosts = await prisma.blogPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blogPostWithIdOnly = await prisma.blogPost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlogPostFindManyArgs>(args?: SelectSubset<T, BlogPostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BlogPost.
     * @param {BlogPostCreateArgs} args - Arguments to create a BlogPost.
     * @example
     * // Create one BlogPost
     * const BlogPost = await prisma.blogPost.create({
     *   data: {
     *     // ... data to create a BlogPost
     *   }
     * })
     * 
     */
    create<T extends BlogPostCreateArgs>(args: SelectSubset<T, BlogPostCreateArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BlogPosts.
     * @param {BlogPostCreateManyArgs} args - Arguments to create many BlogPosts.
     * @example
     * // Create many BlogPosts
     * const blogPost = await prisma.blogPost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlogPostCreateManyArgs>(args?: SelectSubset<T, BlogPostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlogPosts and returns the data saved in the database.
     * @param {BlogPostCreateManyAndReturnArgs} args - Arguments to create many BlogPosts.
     * @example
     * // Create many BlogPosts
     * const blogPost = await prisma.blogPost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlogPosts and only return the `id`
     * const blogPostWithIdOnly = await prisma.blogPost.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlogPostCreateManyAndReturnArgs>(args?: SelectSubset<T, BlogPostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BlogPost.
     * @param {BlogPostDeleteArgs} args - Arguments to delete one BlogPost.
     * @example
     * // Delete one BlogPost
     * const BlogPost = await prisma.blogPost.delete({
     *   where: {
     *     // ... filter to delete one BlogPost
     *   }
     * })
     * 
     */
    delete<T extends BlogPostDeleteArgs>(args: SelectSubset<T, BlogPostDeleteArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BlogPost.
     * @param {BlogPostUpdateArgs} args - Arguments to update one BlogPost.
     * @example
     * // Update one BlogPost
     * const blogPost = await prisma.blogPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlogPostUpdateArgs>(args: SelectSubset<T, BlogPostUpdateArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BlogPosts.
     * @param {BlogPostDeleteManyArgs} args - Arguments to filter BlogPosts to delete.
     * @example
     * // Delete a few BlogPosts
     * const { count } = await prisma.blogPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlogPostDeleteManyArgs>(args?: SelectSubset<T, BlogPostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlogPosts
     * const blogPost = await prisma.blogPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlogPostUpdateManyArgs>(args: SelectSubset<T, BlogPostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogPosts and returns the data updated in the database.
     * @param {BlogPostUpdateManyAndReturnArgs} args - Arguments to update many BlogPosts.
     * @example
     * // Update many BlogPosts
     * const blogPost = await prisma.blogPost.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BlogPosts and only return the `id`
     * const blogPostWithIdOnly = await prisma.blogPost.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BlogPostUpdateManyAndReturnArgs>(args: SelectSubset<T, BlogPostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BlogPost.
     * @param {BlogPostUpsertArgs} args - Arguments to update or create a BlogPost.
     * @example
     * // Update or create a BlogPost
     * const blogPost = await prisma.blogPost.upsert({
     *   create: {
     *     // ... data to create a BlogPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlogPost we want to update
     *   }
     * })
     */
    upsert<T extends BlogPostUpsertArgs>(args: SelectSubset<T, BlogPostUpsertArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BlogPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostCountArgs} args - Arguments to filter BlogPosts to count.
     * @example
     * // Count the number of BlogPosts
     * const count = await prisma.blogPost.count({
     *   where: {
     *     // ... the filter for the BlogPosts we want to count
     *   }
     * })
    **/
    count<T extends BlogPostCountArgs>(
      args?: Subset<T, BlogPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlogPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogPostAggregateArgs>(args: Subset<T, BlogPostAggregateArgs>): Prisma.PrismaPromise<GetBlogPostAggregateType<T>>

    /**
     * Group by BlogPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlogPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlogPostGroupByArgs['orderBy'] }
        : { orderBy?: BlogPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlogPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlogPost model
   */
  readonly fields: BlogPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlogPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlogPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends AuthorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AuthorDefaultArgs<ExtArgs>>): Prisma__AuthorClient<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    category<T extends BlogPost$categoryArgs<ExtArgs> = {}>(args?: Subset<T, BlogPost$categoryArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tags<T extends BlogPost$tagsArgs<ExtArgs> = {}>(args?: Subset<T, BlogPost$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    seriesPosts<T extends BlogPost$seriesPostsArgs<ExtArgs> = {}>(args?: Subset<T, BlogPost$seriesPostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeriesPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    relatedPosts<T extends BlogPost$relatedPostsArgs<ExtArgs> = {}>(args?: Subset<T, BlogPost$relatedPostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostRelationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    relatedToPosts<T extends BlogPost$relatedToPostsArgs<ExtArgs> = {}>(args?: Subset<T, BlogPost$relatedToPostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostRelationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    versions<T extends BlogPost$versionsArgs<ExtArgs> = {}>(args?: Subset<T, BlogPost$versionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostVersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    views<T extends BlogPost$viewsArgs<ExtArgs> = {}>(args?: Subset<T, BlogPost$viewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostViewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    interactions<T extends BlogPost$interactionsArgs<ExtArgs> = {}>(args?: Subset<T, BlogPost$interactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostInteractionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    seoEvents<T extends BlogPost$seoEventsArgs<ExtArgs> = {}>(args?: Subset<T, BlogPost$seoEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SEOEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    seoKeywords<T extends BlogPost$seoKeywordsArgs<ExtArgs> = {}>(args?: Subset<T, BlogPost$seoKeywordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SEOKeywordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sitemapEntries<T extends BlogPost$sitemapEntriesArgs<ExtArgs> = {}>(args?: Subset<T, BlogPost$sitemapEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SitemapEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlogPost model
   */
  interface BlogPostFieldRefs {
    readonly id: FieldRef<"BlogPost", 'String'>
    readonly title: FieldRef<"BlogPost", 'String'>
    readonly slug: FieldRef<"BlogPost", 'String'>
    readonly excerpt: FieldRef<"BlogPost", 'String'>
    readonly content: FieldRef<"BlogPost", 'String'>
    readonly contentType: FieldRef<"BlogPost", 'ContentType'>
    readonly status: FieldRef<"BlogPost", 'PostStatus'>
    readonly metaTitle: FieldRef<"BlogPost", 'String'>
    readonly metaDescription: FieldRef<"BlogPost", 'String'>
    readonly keywords: FieldRef<"BlogPost", 'String[]'>
    readonly canonicalUrl: FieldRef<"BlogPost", 'String'>
    readonly ogTitle: FieldRef<"BlogPost", 'String'>
    readonly ogDescription: FieldRef<"BlogPost", 'String'>
    readonly ogImage: FieldRef<"BlogPost", 'String'>
    readonly twitterTitle: FieldRef<"BlogPost", 'String'>
    readonly twitterDescription: FieldRef<"BlogPost", 'String'>
    readonly twitterImage: FieldRef<"BlogPost", 'String'>
    readonly featuredImage: FieldRef<"BlogPost", 'String'>
    readonly featuredImageAlt: FieldRef<"BlogPost", 'String'>
    readonly readingTime: FieldRef<"BlogPost", 'Int'>
    readonly wordCount: FieldRef<"BlogPost", 'Int'>
    readonly publishedAt: FieldRef<"BlogPost", 'DateTime'>
    readonly scheduledAt: FieldRef<"BlogPost", 'DateTime'>
    readonly archivedAt: FieldRef<"BlogPost", 'DateTime'>
    readonly deletedAt: FieldRef<"BlogPost", 'DateTime'>
    readonly createdAt: FieldRef<"BlogPost", 'DateTime'>
    readonly updatedAt: FieldRef<"BlogPost", 'DateTime'>
    readonly authorId: FieldRef<"BlogPost", 'String'>
    readonly categoryId: FieldRef<"BlogPost", 'String'>
    readonly currentVersion: FieldRef<"BlogPost", 'Int'>
    readonly viewCount: FieldRef<"BlogPost", 'Int'>
    readonly likeCount: FieldRef<"BlogPost", 'Int'>
    readonly shareCount: FieldRef<"BlogPost", 'Int'>
    readonly commentCount: FieldRef<"BlogPost", 'Int'>
    readonly seoScore: FieldRef<"BlogPost", 'Float'>
    readonly seoAnalysis: FieldRef<"BlogPost", 'Json'>
    readonly lastSeoCheck: FieldRef<"BlogPost", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BlogPost findUnique
   */
  export type BlogPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost findUniqueOrThrow
   */
  export type BlogPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost findFirst
   */
  export type BlogPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogPosts.
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogPosts.
     */
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogPost findFirstOrThrow
   */
  export type BlogPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogPosts.
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogPosts.
     */
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogPost findMany
   */
  export type BlogPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPosts to fetch.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlogPosts.
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogPost create
   */
  export type BlogPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * The data needed to create a BlogPost.
     */
    data: XOR<BlogPostCreateInput, BlogPostUncheckedCreateInput>
  }

  /**
   * BlogPost createMany
   */
  export type BlogPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlogPosts.
     */
    data: BlogPostCreateManyInput | BlogPostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlogPost createManyAndReturn
   */
  export type BlogPostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * The data used to create many BlogPosts.
     */
    data: BlogPostCreateManyInput | BlogPostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlogPost update
   */
  export type BlogPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * The data needed to update a BlogPost.
     */
    data: XOR<BlogPostUpdateInput, BlogPostUncheckedUpdateInput>
    /**
     * Choose, which BlogPost to update.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost updateMany
   */
  export type BlogPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlogPosts.
     */
    data: XOR<BlogPostUpdateManyMutationInput, BlogPostUncheckedUpdateManyInput>
    /**
     * Filter which BlogPosts to update
     */
    where?: BlogPostWhereInput
    /**
     * Limit how many BlogPosts to update.
     */
    limit?: number
  }

  /**
   * BlogPost updateManyAndReturn
   */
  export type BlogPostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * The data used to update BlogPosts.
     */
    data: XOR<BlogPostUpdateManyMutationInput, BlogPostUncheckedUpdateManyInput>
    /**
     * Filter which BlogPosts to update
     */
    where?: BlogPostWhereInput
    /**
     * Limit how many BlogPosts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlogPost upsert
   */
  export type BlogPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * The filter to search for the BlogPost to update in case it exists.
     */
    where: BlogPostWhereUniqueInput
    /**
     * In case the BlogPost found by the `where` argument doesn't exist, create a new BlogPost with this data.
     */
    create: XOR<BlogPostCreateInput, BlogPostUncheckedCreateInput>
    /**
     * In case the BlogPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlogPostUpdateInput, BlogPostUncheckedUpdateInput>
  }

  /**
   * BlogPost delete
   */
  export type BlogPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter which BlogPost to delete.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost deleteMany
   */
  export type BlogPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogPosts to delete
     */
    where?: BlogPostWhereInput
    /**
     * Limit how many BlogPosts to delete.
     */
    limit?: number
  }

  /**
   * BlogPost.category
   */
  export type BlogPost$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * BlogPost.tags
   */
  export type BlogPost$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    where?: PostTagWhereInput
    orderBy?: PostTagOrderByWithRelationInput | PostTagOrderByWithRelationInput[]
    cursor?: PostTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostTagScalarFieldEnum | PostTagScalarFieldEnum[]
  }

  /**
   * BlogPost.seriesPosts
   */
  export type BlogPost$seriesPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeriesPost
     */
    select?: SeriesPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeriesPost
     */
    omit?: SeriesPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesPostInclude<ExtArgs> | null
    where?: SeriesPostWhereInput
    orderBy?: SeriesPostOrderByWithRelationInput | SeriesPostOrderByWithRelationInput[]
    cursor?: SeriesPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SeriesPostScalarFieldEnum | SeriesPostScalarFieldEnum[]
  }

  /**
   * BlogPost.relatedPosts
   */
  export type BlogPost$relatedPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostRelation
     */
    select?: PostRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostRelation
     */
    omit?: PostRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostRelationInclude<ExtArgs> | null
    where?: PostRelationWhereInput
    orderBy?: PostRelationOrderByWithRelationInput | PostRelationOrderByWithRelationInput[]
    cursor?: PostRelationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostRelationScalarFieldEnum | PostRelationScalarFieldEnum[]
  }

  /**
   * BlogPost.relatedToPosts
   */
  export type BlogPost$relatedToPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostRelation
     */
    select?: PostRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostRelation
     */
    omit?: PostRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostRelationInclude<ExtArgs> | null
    where?: PostRelationWhereInput
    orderBy?: PostRelationOrderByWithRelationInput | PostRelationOrderByWithRelationInput[]
    cursor?: PostRelationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostRelationScalarFieldEnum | PostRelationScalarFieldEnum[]
  }

  /**
   * BlogPost.versions
   */
  export type BlogPost$versionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostVersion
     */
    select?: PostVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostVersion
     */
    omit?: PostVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostVersionInclude<ExtArgs> | null
    where?: PostVersionWhereInput
    orderBy?: PostVersionOrderByWithRelationInput | PostVersionOrderByWithRelationInput[]
    cursor?: PostVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostVersionScalarFieldEnum | PostVersionScalarFieldEnum[]
  }

  /**
   * BlogPost.views
   */
  export type BlogPost$viewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostView
     */
    select?: PostViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostView
     */
    omit?: PostViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostViewInclude<ExtArgs> | null
    where?: PostViewWhereInput
    orderBy?: PostViewOrderByWithRelationInput | PostViewOrderByWithRelationInput[]
    cursor?: PostViewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostViewScalarFieldEnum | PostViewScalarFieldEnum[]
  }

  /**
   * BlogPost.interactions
   */
  export type BlogPost$interactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostInteraction
     */
    select?: PostInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostInteraction
     */
    omit?: PostInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInteractionInclude<ExtArgs> | null
    where?: PostInteractionWhereInput
    orderBy?: PostInteractionOrderByWithRelationInput | PostInteractionOrderByWithRelationInput[]
    cursor?: PostInteractionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostInteractionScalarFieldEnum | PostInteractionScalarFieldEnum[]
  }

  /**
   * BlogPost.seoEvents
   */
  export type BlogPost$seoEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SEOEvent
     */
    select?: SEOEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SEOEvent
     */
    omit?: SEOEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SEOEventInclude<ExtArgs> | null
    where?: SEOEventWhereInput
    orderBy?: SEOEventOrderByWithRelationInput | SEOEventOrderByWithRelationInput[]
    cursor?: SEOEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SEOEventScalarFieldEnum | SEOEventScalarFieldEnum[]
  }

  /**
   * BlogPost.seoKeywords
   */
  export type BlogPost$seoKeywordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SEOKeyword
     */
    select?: SEOKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SEOKeyword
     */
    omit?: SEOKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SEOKeywordInclude<ExtArgs> | null
    where?: SEOKeywordWhereInput
    orderBy?: SEOKeywordOrderByWithRelationInput | SEOKeywordOrderByWithRelationInput[]
    cursor?: SEOKeywordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SEOKeywordScalarFieldEnum | SEOKeywordScalarFieldEnum[]
  }

  /**
   * BlogPost.sitemapEntries
   */
  export type BlogPost$sitemapEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SitemapEntry
     */
    select?: SitemapEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SitemapEntry
     */
    omit?: SitemapEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SitemapEntryInclude<ExtArgs> | null
    where?: SitemapEntryWhereInput
    orderBy?: SitemapEntryOrderByWithRelationInput | SitemapEntryOrderByWithRelationInput[]
    cursor?: SitemapEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SitemapEntryScalarFieldEnum | SitemapEntryScalarFieldEnum[]
  }

  /**
   * BlogPost without action
   */
  export type BlogPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
  }


  /**
   * Model Author
   */

  export type AggregateAuthor = {
    _count: AuthorCountAggregateOutputType | null
    _avg: AuthorAvgAggregateOutputType | null
    _sum: AuthorSumAggregateOutputType | null
    _min: AuthorMinAggregateOutputType | null
    _max: AuthorMaxAggregateOutputType | null
  }

  export type AuthorAvgAggregateOutputType = {
    totalViews: number | null
    totalPosts: number | null
  }

  export type AuthorSumAggregateOutputType = {
    totalViews: number | null
    totalPosts: number | null
  }

  export type AuthorMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    slug: string | null
    bio: string | null
    avatar: string | null
    website: string | null
    twitter: string | null
    linkedin: string | null
    github: string | null
    metaDescription: string | null
    totalViews: number | null
    totalPosts: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuthorMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    slug: string | null
    bio: string | null
    avatar: string | null
    website: string | null
    twitter: string | null
    linkedin: string | null
    github: string | null
    metaDescription: string | null
    totalViews: number | null
    totalPosts: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuthorCountAggregateOutputType = {
    id: number
    name: number
    email: number
    slug: number
    bio: number
    avatar: number
    website: number
    twitter: number
    linkedin: number
    github: number
    metaDescription: number
    totalViews: number
    totalPosts: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AuthorAvgAggregateInputType = {
    totalViews?: true
    totalPosts?: true
  }

  export type AuthorSumAggregateInputType = {
    totalViews?: true
    totalPosts?: true
  }

  export type AuthorMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    slug?: true
    bio?: true
    avatar?: true
    website?: true
    twitter?: true
    linkedin?: true
    github?: true
    metaDescription?: true
    totalViews?: true
    totalPosts?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuthorMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    slug?: true
    bio?: true
    avatar?: true
    website?: true
    twitter?: true
    linkedin?: true
    github?: true
    metaDescription?: true
    totalViews?: true
    totalPosts?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuthorCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    slug?: true
    bio?: true
    avatar?: true
    website?: true
    twitter?: true
    linkedin?: true
    github?: true
    metaDescription?: true
    totalViews?: true
    totalPosts?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AuthorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Author to aggregate.
     */
    where?: AuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authors to fetch.
     */
    orderBy?: AuthorOrderByWithRelationInput | AuthorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Authors
    **/
    _count?: true | AuthorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuthorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuthorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuthorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuthorMaxAggregateInputType
  }

  export type GetAuthorAggregateType<T extends AuthorAggregateArgs> = {
        [P in keyof T & keyof AggregateAuthor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuthor[P]>
      : GetScalarType<T[P], AggregateAuthor[P]>
  }




  export type AuthorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuthorWhereInput
    orderBy?: AuthorOrderByWithAggregationInput | AuthorOrderByWithAggregationInput[]
    by: AuthorScalarFieldEnum[] | AuthorScalarFieldEnum
    having?: AuthorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuthorCountAggregateInputType | true
    _avg?: AuthorAvgAggregateInputType
    _sum?: AuthorSumAggregateInputType
    _min?: AuthorMinAggregateInputType
    _max?: AuthorMaxAggregateInputType
  }

  export type AuthorGroupByOutputType = {
    id: string
    name: string
    email: string
    slug: string
    bio: string | null
    avatar: string | null
    website: string | null
    twitter: string | null
    linkedin: string | null
    github: string | null
    metaDescription: string | null
    totalViews: number
    totalPosts: number
    createdAt: Date
    updatedAt: Date
    _count: AuthorCountAggregateOutputType | null
    _avg: AuthorAvgAggregateOutputType | null
    _sum: AuthorSumAggregateOutputType | null
    _min: AuthorMinAggregateOutputType | null
    _max: AuthorMaxAggregateOutputType | null
  }

  type GetAuthorGroupByPayload<T extends AuthorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuthorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuthorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuthorGroupByOutputType[P]>
            : GetScalarType<T[P], AuthorGroupByOutputType[P]>
        }
      >
    >


  export type AuthorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    slug?: boolean
    bio?: boolean
    avatar?: boolean
    website?: boolean
    twitter?: boolean
    linkedin?: boolean
    github?: boolean
    metaDescription?: boolean
    totalViews?: boolean
    totalPosts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    posts?: boolean | Author$postsArgs<ExtArgs>
    postVersions?: boolean | Author$postVersionsArgs<ExtArgs>
    _count?: boolean | AuthorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["author"]>

  export type AuthorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    slug?: boolean
    bio?: boolean
    avatar?: boolean
    website?: boolean
    twitter?: boolean
    linkedin?: boolean
    github?: boolean
    metaDescription?: boolean
    totalViews?: boolean
    totalPosts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["author"]>

  export type AuthorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    slug?: boolean
    bio?: boolean
    avatar?: boolean
    website?: boolean
    twitter?: boolean
    linkedin?: boolean
    github?: boolean
    metaDescription?: boolean
    totalViews?: boolean
    totalPosts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["author"]>

  export type AuthorSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    slug?: boolean
    bio?: boolean
    avatar?: boolean
    website?: boolean
    twitter?: boolean
    linkedin?: boolean
    github?: boolean
    metaDescription?: boolean
    totalViews?: boolean
    totalPosts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AuthorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "slug" | "bio" | "avatar" | "website" | "twitter" | "linkedin" | "github" | "metaDescription" | "totalViews" | "totalPosts" | "createdAt" | "updatedAt", ExtArgs["result"]["author"]>
  export type AuthorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | Author$postsArgs<ExtArgs>
    postVersions?: boolean | Author$postVersionsArgs<ExtArgs>
    _count?: boolean | AuthorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AuthorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AuthorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AuthorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Author"
    objects: {
      posts: Prisma.$BlogPostPayload<ExtArgs>[]
      postVersions: Prisma.$PostVersionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      slug: string
      bio: string | null
      avatar: string | null
      website: string | null
      twitter: string | null
      linkedin: string | null
      github: string | null
      metaDescription: string | null
      totalViews: number
      totalPosts: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["author"]>
    composites: {}
  }

  type AuthorGetPayload<S extends boolean | null | undefined | AuthorDefaultArgs> = $Result.GetResult<Prisma.$AuthorPayload, S>

  type AuthorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuthorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuthorCountAggregateInputType | true
    }

  export interface AuthorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Author'], meta: { name: 'Author' } }
    /**
     * Find zero or one Author that matches the filter.
     * @param {AuthorFindUniqueArgs} args - Arguments to find a Author
     * @example
     * // Get one Author
     * const author = await prisma.author.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuthorFindUniqueArgs>(args: SelectSubset<T, AuthorFindUniqueArgs<ExtArgs>>): Prisma__AuthorClient<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Author that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuthorFindUniqueOrThrowArgs} args - Arguments to find a Author
     * @example
     * // Get one Author
     * const author = await prisma.author.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuthorFindUniqueOrThrowArgs>(args: SelectSubset<T, AuthorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuthorClient<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Author that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorFindFirstArgs} args - Arguments to find a Author
     * @example
     * // Get one Author
     * const author = await prisma.author.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuthorFindFirstArgs>(args?: SelectSubset<T, AuthorFindFirstArgs<ExtArgs>>): Prisma__AuthorClient<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Author that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorFindFirstOrThrowArgs} args - Arguments to find a Author
     * @example
     * // Get one Author
     * const author = await prisma.author.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuthorFindFirstOrThrowArgs>(args?: SelectSubset<T, AuthorFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuthorClient<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Authors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Authors
     * const authors = await prisma.author.findMany()
     * 
     * // Get first 10 Authors
     * const authors = await prisma.author.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const authorWithIdOnly = await prisma.author.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuthorFindManyArgs>(args?: SelectSubset<T, AuthorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Author.
     * @param {AuthorCreateArgs} args - Arguments to create a Author.
     * @example
     * // Create one Author
     * const Author = await prisma.author.create({
     *   data: {
     *     // ... data to create a Author
     *   }
     * })
     * 
     */
    create<T extends AuthorCreateArgs>(args: SelectSubset<T, AuthorCreateArgs<ExtArgs>>): Prisma__AuthorClient<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Authors.
     * @param {AuthorCreateManyArgs} args - Arguments to create many Authors.
     * @example
     * // Create many Authors
     * const author = await prisma.author.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuthorCreateManyArgs>(args?: SelectSubset<T, AuthorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Authors and returns the data saved in the database.
     * @param {AuthorCreateManyAndReturnArgs} args - Arguments to create many Authors.
     * @example
     * // Create many Authors
     * const author = await prisma.author.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Authors and only return the `id`
     * const authorWithIdOnly = await prisma.author.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuthorCreateManyAndReturnArgs>(args?: SelectSubset<T, AuthorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Author.
     * @param {AuthorDeleteArgs} args - Arguments to delete one Author.
     * @example
     * // Delete one Author
     * const Author = await prisma.author.delete({
     *   where: {
     *     // ... filter to delete one Author
     *   }
     * })
     * 
     */
    delete<T extends AuthorDeleteArgs>(args: SelectSubset<T, AuthorDeleteArgs<ExtArgs>>): Prisma__AuthorClient<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Author.
     * @param {AuthorUpdateArgs} args - Arguments to update one Author.
     * @example
     * // Update one Author
     * const author = await prisma.author.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuthorUpdateArgs>(args: SelectSubset<T, AuthorUpdateArgs<ExtArgs>>): Prisma__AuthorClient<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Authors.
     * @param {AuthorDeleteManyArgs} args - Arguments to filter Authors to delete.
     * @example
     * // Delete a few Authors
     * const { count } = await prisma.author.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuthorDeleteManyArgs>(args?: SelectSubset<T, AuthorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Authors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Authors
     * const author = await prisma.author.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuthorUpdateManyArgs>(args: SelectSubset<T, AuthorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Authors and returns the data updated in the database.
     * @param {AuthorUpdateManyAndReturnArgs} args - Arguments to update many Authors.
     * @example
     * // Update many Authors
     * const author = await prisma.author.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Authors and only return the `id`
     * const authorWithIdOnly = await prisma.author.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuthorUpdateManyAndReturnArgs>(args: SelectSubset<T, AuthorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Author.
     * @param {AuthorUpsertArgs} args - Arguments to update or create a Author.
     * @example
     * // Update or create a Author
     * const author = await prisma.author.upsert({
     *   create: {
     *     // ... data to create a Author
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Author we want to update
     *   }
     * })
     */
    upsert<T extends AuthorUpsertArgs>(args: SelectSubset<T, AuthorUpsertArgs<ExtArgs>>): Prisma__AuthorClient<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Authors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorCountArgs} args - Arguments to filter Authors to count.
     * @example
     * // Count the number of Authors
     * const count = await prisma.author.count({
     *   where: {
     *     // ... the filter for the Authors we want to count
     *   }
     * })
    **/
    count<T extends AuthorCountArgs>(
      args?: Subset<T, AuthorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuthorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Author.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuthorAggregateArgs>(args: Subset<T, AuthorAggregateArgs>): Prisma.PrismaPromise<GetAuthorAggregateType<T>>

    /**
     * Group by Author.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuthorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuthorGroupByArgs['orderBy'] }
        : { orderBy?: AuthorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuthorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuthorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Author model
   */
  readonly fields: AuthorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Author.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuthorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    posts<T extends Author$postsArgs<ExtArgs> = {}>(args?: Subset<T, Author$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    postVersions<T extends Author$postVersionsArgs<ExtArgs> = {}>(args?: Subset<T, Author$postVersionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostVersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Author model
   */
  interface AuthorFieldRefs {
    readonly id: FieldRef<"Author", 'String'>
    readonly name: FieldRef<"Author", 'String'>
    readonly email: FieldRef<"Author", 'String'>
    readonly slug: FieldRef<"Author", 'String'>
    readonly bio: FieldRef<"Author", 'String'>
    readonly avatar: FieldRef<"Author", 'String'>
    readonly website: FieldRef<"Author", 'String'>
    readonly twitter: FieldRef<"Author", 'String'>
    readonly linkedin: FieldRef<"Author", 'String'>
    readonly github: FieldRef<"Author", 'String'>
    readonly metaDescription: FieldRef<"Author", 'String'>
    readonly totalViews: FieldRef<"Author", 'Int'>
    readonly totalPosts: FieldRef<"Author", 'Int'>
    readonly createdAt: FieldRef<"Author", 'DateTime'>
    readonly updatedAt: FieldRef<"Author", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Author findUnique
   */
  export type AuthorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
    /**
     * Filter, which Author to fetch.
     */
    where: AuthorWhereUniqueInput
  }

  /**
   * Author findUniqueOrThrow
   */
  export type AuthorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
    /**
     * Filter, which Author to fetch.
     */
    where: AuthorWhereUniqueInput
  }

  /**
   * Author findFirst
   */
  export type AuthorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
    /**
     * Filter, which Author to fetch.
     */
    where?: AuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authors to fetch.
     */
    orderBy?: AuthorOrderByWithRelationInput | AuthorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Authors.
     */
    cursor?: AuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Authors.
     */
    distinct?: AuthorScalarFieldEnum | AuthorScalarFieldEnum[]
  }

  /**
   * Author findFirstOrThrow
   */
  export type AuthorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
    /**
     * Filter, which Author to fetch.
     */
    where?: AuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authors to fetch.
     */
    orderBy?: AuthorOrderByWithRelationInput | AuthorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Authors.
     */
    cursor?: AuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Authors.
     */
    distinct?: AuthorScalarFieldEnum | AuthorScalarFieldEnum[]
  }

  /**
   * Author findMany
   */
  export type AuthorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
    /**
     * Filter, which Authors to fetch.
     */
    where?: AuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authors to fetch.
     */
    orderBy?: AuthorOrderByWithRelationInput | AuthorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Authors.
     */
    cursor?: AuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authors.
     */
    skip?: number
    distinct?: AuthorScalarFieldEnum | AuthorScalarFieldEnum[]
  }

  /**
   * Author create
   */
  export type AuthorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
    /**
     * The data needed to create a Author.
     */
    data: XOR<AuthorCreateInput, AuthorUncheckedCreateInput>
  }

  /**
   * Author createMany
   */
  export type AuthorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Authors.
     */
    data: AuthorCreateManyInput | AuthorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Author createManyAndReturn
   */
  export type AuthorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * The data used to create many Authors.
     */
    data: AuthorCreateManyInput | AuthorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Author update
   */
  export type AuthorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
    /**
     * The data needed to update a Author.
     */
    data: XOR<AuthorUpdateInput, AuthorUncheckedUpdateInput>
    /**
     * Choose, which Author to update.
     */
    where: AuthorWhereUniqueInput
  }

  /**
   * Author updateMany
   */
  export type AuthorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Authors.
     */
    data: XOR<AuthorUpdateManyMutationInput, AuthorUncheckedUpdateManyInput>
    /**
     * Filter which Authors to update
     */
    where?: AuthorWhereInput
    /**
     * Limit how many Authors to update.
     */
    limit?: number
  }

  /**
   * Author updateManyAndReturn
   */
  export type AuthorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * The data used to update Authors.
     */
    data: XOR<AuthorUpdateManyMutationInput, AuthorUncheckedUpdateManyInput>
    /**
     * Filter which Authors to update
     */
    where?: AuthorWhereInput
    /**
     * Limit how many Authors to update.
     */
    limit?: number
  }

  /**
   * Author upsert
   */
  export type AuthorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
    /**
     * The filter to search for the Author to update in case it exists.
     */
    where: AuthorWhereUniqueInput
    /**
     * In case the Author found by the `where` argument doesn't exist, create a new Author with this data.
     */
    create: XOR<AuthorCreateInput, AuthorUncheckedCreateInput>
    /**
     * In case the Author was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuthorUpdateInput, AuthorUncheckedUpdateInput>
  }

  /**
   * Author delete
   */
  export type AuthorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
    /**
     * Filter which Author to delete.
     */
    where: AuthorWhereUniqueInput
  }

  /**
   * Author deleteMany
   */
  export type AuthorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Authors to delete
     */
    where?: AuthorWhereInput
    /**
     * Limit how many Authors to delete.
     */
    limit?: number
  }

  /**
   * Author.posts
   */
  export type Author$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    where?: BlogPostWhereInput
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    cursor?: BlogPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * Author.postVersions
   */
  export type Author$postVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostVersion
     */
    select?: PostVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostVersion
     */
    omit?: PostVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostVersionInclude<ExtArgs> | null
    where?: PostVersionWhereInput
    orderBy?: PostVersionOrderByWithRelationInput | PostVersionOrderByWithRelationInput[]
    cursor?: PostVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostVersionScalarFieldEnum | PostVersionScalarFieldEnum[]
  }

  /**
   * Author without action
   */
  export type AuthorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    postCount: number | null
    totalViews: number | null
  }

  export type CategorySumAggregateOutputType = {
    postCount: number | null
    totalViews: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    color: string | null
    icon: string | null
    metaTitle: string | null
    metaDescription: string | null
    parentId: string | null
    postCount: number | null
    totalViews: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    color: string | null
    icon: string | null
    metaTitle: string | null
    metaDescription: string | null
    parentId: string | null
    postCount: number | null
    totalViews: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    color: number
    icon: number
    metaTitle: number
    metaDescription: number
    keywords: number
    parentId: number
    postCount: number
    totalViews: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    postCount?: true
    totalViews?: true
  }

  export type CategorySumAggregateInputType = {
    postCount?: true
    totalViews?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    color?: true
    icon?: true
    metaTitle?: true
    metaDescription?: true
    parentId?: true
    postCount?: true
    totalViews?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    color?: true
    icon?: true
    metaTitle?: true
    metaDescription?: true
    parentId?: true
    postCount?: true
    totalViews?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    color?: true
    icon?: true
    metaTitle?: true
    metaDescription?: true
    keywords?: true
    parentId?: true
    postCount?: true
    totalViews?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    color: string | null
    icon: string | null
    metaTitle: string | null
    metaDescription: string | null
    keywords: string[]
    parentId: string | null
    postCount: number
    totalViews: number
    createdAt: Date
    updatedAt: Date
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    color?: boolean
    icon?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    keywords?: boolean
    parentId?: boolean
    postCount?: boolean
    totalViews?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | Category$parentArgs<ExtArgs>
    children?: boolean | Category$childrenArgs<ExtArgs>
    posts?: boolean | Category$postsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    color?: boolean
    icon?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    keywords?: boolean
    parentId?: boolean
    postCount?: boolean
    totalViews?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | Category$parentArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    color?: boolean
    icon?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    keywords?: boolean
    parentId?: boolean
    postCount?: boolean
    totalViews?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | Category$parentArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    color?: boolean
    icon?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    keywords?: boolean
    parentId?: boolean
    postCount?: boolean
    totalViews?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "description" | "color" | "icon" | "metaTitle" | "metaDescription" | "keywords" | "parentId" | "postCount" | "totalViews" | "createdAt" | "updatedAt", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Category$parentArgs<ExtArgs>
    children?: boolean | Category$childrenArgs<ExtArgs>
    posts?: boolean | Category$postsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Category$parentArgs<ExtArgs>
  }
  export type CategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Category$parentArgs<ExtArgs>
  }

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      parent: Prisma.$CategoryPayload<ExtArgs> | null
      children: Prisma.$CategoryPayload<ExtArgs>[]
      posts: Prisma.$BlogPostPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      color: string | null
      icon: string | null
      metaTitle: string | null
      metaDescription: string | null
      keywords: string[]
      parentId: string | null
      postCount: number
      totalViews: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {CategoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends Category$parentArgs<ExtArgs> = {}>(args?: Subset<T, Category$parentArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends Category$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Category$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    posts<T extends Category$postsArgs<ExtArgs> = {}>(args?: Subset<T, Category$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly name: FieldRef<"Category", 'String'>
    readonly slug: FieldRef<"Category", 'String'>
    readonly description: FieldRef<"Category", 'String'>
    readonly color: FieldRef<"Category", 'String'>
    readonly icon: FieldRef<"Category", 'String'>
    readonly metaTitle: FieldRef<"Category", 'String'>
    readonly metaDescription: FieldRef<"Category", 'String'>
    readonly keywords: FieldRef<"Category", 'String[]'>
    readonly parentId: FieldRef<"Category", 'String'>
    readonly postCount: FieldRef<"Category", 'Int'>
    readonly totalViews: FieldRef<"Category", 'Int'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
    readonly updatedAt: FieldRef<"Category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category updateManyAndReturn
   */
  export type CategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category.parent
   */
  export type Category$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * Category.children
   */
  export type Category$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category.posts
   */
  export type Category$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    where?: BlogPostWhereInput
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    cursor?: BlogPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _avg: TagAvgAggregateOutputType | null
    _sum: TagSumAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagAvgAggregateOutputType = {
    postCount: number | null
    totalViews: number | null
  }

  export type TagSumAggregateOutputType = {
    postCount: number | null
    totalViews: number | null
  }

  export type TagMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    color: string | null
    metaDescription: string | null
    postCount: number | null
    totalViews: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    color: string | null
    metaDescription: string | null
    postCount: number | null
    totalViews: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    color: number
    metaDescription: number
    postCount: number
    totalViews: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TagAvgAggregateInputType = {
    postCount?: true
    totalViews?: true
  }

  export type TagSumAggregateInputType = {
    postCount?: true
    totalViews?: true
  }

  export type TagMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    color?: true
    metaDescription?: true
    postCount?: true
    totalViews?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    color?: true
    metaDescription?: true
    postCount?: true
    totalViews?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    color?: true
    metaDescription?: true
    postCount?: true
    totalViews?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _avg?: TagAvgAggregateInputType
    _sum?: TagSumAggregateInputType
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    color: string | null
    metaDescription: string | null
    postCount: number
    totalViews: number
    createdAt: Date
    updatedAt: Date
    _count: TagCountAggregateOutputType | null
    _avg: TagAvgAggregateOutputType | null
    _sum: TagSumAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    color?: boolean
    metaDescription?: boolean
    postCount?: boolean
    totalViews?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    posts?: boolean | Tag$postsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    color?: boolean
    metaDescription?: boolean
    postCount?: boolean
    totalViews?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    color?: boolean
    metaDescription?: boolean
    postCount?: boolean
    totalViews?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    color?: boolean
    metaDescription?: boolean
    postCount?: boolean
    totalViews?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "description" | "color" | "metaDescription" | "postCount" | "totalViews" | "createdAt" | "updatedAt", ExtArgs["result"]["tag"]>
  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | Tag$postsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      posts: Prisma.$PostTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      color: string | null
      metaDescription: string | null
      postCount: number
      totalViews: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagFindManyArgs>(args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends TagCreateArgs>(args: SelectSubset<T, TagCreateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagCreateManyArgs>(args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {TagCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagCreateManyAndReturnArgs>(args?: SelectSubset<T, TagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends TagDeleteArgs>(args: SelectSubset<T, TagDeleteArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagUpdateArgs>(args: SelectSubset<T, TagUpdateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagDeleteManyArgs>(args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagUpdateManyArgs>(args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags and returns the data updated in the database.
     * @param {TagUpdateManyAndReturnArgs} args - Arguments to update many Tags.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TagUpdateManyAndReturnArgs>(args: SelectSubset<T, TagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(args: SelectSubset<T, TagUpsertArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    posts<T extends Tag$postsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tag model
   */
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", 'String'>
    readonly name: FieldRef<"Tag", 'String'>
    readonly slug: FieldRef<"Tag", 'String'>
    readonly description: FieldRef<"Tag", 'String'>
    readonly color: FieldRef<"Tag", 'String'>
    readonly metaDescription: FieldRef<"Tag", 'String'>
    readonly postCount: FieldRef<"Tag", 'Int'>
    readonly totalViews: FieldRef<"Tag", 'Int'>
    readonly createdAt: FieldRef<"Tag", 'DateTime'>
    readonly updatedAt: FieldRef<"Tag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag createManyAndReturn
   */
  export type TagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag updateManyAndReturn
   */
  export type TagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }

  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to delete.
     */
    limit?: number
  }

  /**
   * Tag.posts
   */
  export type Tag$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    where?: PostTagWhereInput
    orderBy?: PostTagOrderByWithRelationInput | PostTagOrderByWithRelationInput[]
    cursor?: PostTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostTagScalarFieldEnum | PostTagScalarFieldEnum[]
  }

  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
  }


  /**
   * Model PostTag
   */

  export type AggregatePostTag = {
    _count: PostTagCountAggregateOutputType | null
    _min: PostTagMinAggregateOutputType | null
    _max: PostTagMaxAggregateOutputType | null
  }

  export type PostTagMinAggregateOutputType = {
    postId: string | null
    tagId: string | null
    createdAt: Date | null
  }

  export type PostTagMaxAggregateOutputType = {
    postId: string | null
    tagId: string | null
    createdAt: Date | null
  }

  export type PostTagCountAggregateOutputType = {
    postId: number
    tagId: number
    createdAt: number
    _all: number
  }


  export type PostTagMinAggregateInputType = {
    postId?: true
    tagId?: true
    createdAt?: true
  }

  export type PostTagMaxAggregateInputType = {
    postId?: true
    tagId?: true
    createdAt?: true
  }

  export type PostTagCountAggregateInputType = {
    postId?: true
    tagId?: true
    createdAt?: true
    _all?: true
  }

  export type PostTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostTag to aggregate.
     */
    where?: PostTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostTags to fetch.
     */
    orderBy?: PostTagOrderByWithRelationInput | PostTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostTags
    **/
    _count?: true | PostTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostTagMaxAggregateInputType
  }

  export type GetPostTagAggregateType<T extends PostTagAggregateArgs> = {
        [P in keyof T & keyof AggregatePostTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostTag[P]>
      : GetScalarType<T[P], AggregatePostTag[P]>
  }




  export type PostTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostTagWhereInput
    orderBy?: PostTagOrderByWithAggregationInput | PostTagOrderByWithAggregationInput[]
    by: PostTagScalarFieldEnum[] | PostTagScalarFieldEnum
    having?: PostTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostTagCountAggregateInputType | true
    _min?: PostTagMinAggregateInputType
    _max?: PostTagMaxAggregateInputType
  }

  export type PostTagGroupByOutputType = {
    postId: string
    tagId: string
    createdAt: Date
    _count: PostTagCountAggregateOutputType | null
    _min: PostTagMinAggregateOutputType | null
    _max: PostTagMaxAggregateOutputType | null
  }

  type GetPostTagGroupByPayload<T extends PostTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostTagGroupByOutputType[P]>
            : GetScalarType<T[P], PostTagGroupByOutputType[P]>
        }
      >
    >


  export type PostTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    postId?: boolean
    tagId?: boolean
    createdAt?: boolean
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postTag"]>

  export type PostTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    postId?: boolean
    tagId?: boolean
    createdAt?: boolean
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postTag"]>

  export type PostTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    postId?: boolean
    tagId?: boolean
    createdAt?: boolean
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postTag"]>

  export type PostTagSelectScalar = {
    postId?: boolean
    tagId?: boolean
    createdAt?: boolean
  }

  export type PostTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"postId" | "tagId" | "createdAt", ExtArgs["result"]["postTag"]>
  export type PostTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type PostTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type PostTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }

  export type $PostTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PostTag"
    objects: {
      post: Prisma.$BlogPostPayload<ExtArgs>
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      postId: string
      tagId: string
      createdAt: Date
    }, ExtArgs["result"]["postTag"]>
    composites: {}
  }

  type PostTagGetPayload<S extends boolean | null | undefined | PostTagDefaultArgs> = $Result.GetResult<Prisma.$PostTagPayload, S>

  type PostTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostTagCountAggregateInputType | true
    }

  export interface PostTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostTag'], meta: { name: 'PostTag' } }
    /**
     * Find zero or one PostTag that matches the filter.
     * @param {PostTagFindUniqueArgs} args - Arguments to find a PostTag
     * @example
     * // Get one PostTag
     * const postTag = await prisma.postTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostTagFindUniqueArgs>(args: SelectSubset<T, PostTagFindUniqueArgs<ExtArgs>>): Prisma__PostTagClient<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PostTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostTagFindUniqueOrThrowArgs} args - Arguments to find a PostTag
     * @example
     * // Get one PostTag
     * const postTag = await prisma.postTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostTagFindUniqueOrThrowArgs>(args: SelectSubset<T, PostTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostTagClient<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTagFindFirstArgs} args - Arguments to find a PostTag
     * @example
     * // Get one PostTag
     * const postTag = await prisma.postTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostTagFindFirstArgs>(args?: SelectSubset<T, PostTagFindFirstArgs<ExtArgs>>): Prisma__PostTagClient<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTagFindFirstOrThrowArgs} args - Arguments to find a PostTag
     * @example
     * // Get one PostTag
     * const postTag = await prisma.postTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostTagFindFirstOrThrowArgs>(args?: SelectSubset<T, PostTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostTagClient<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PostTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostTags
     * const postTags = await prisma.postTag.findMany()
     * 
     * // Get first 10 PostTags
     * const postTags = await prisma.postTag.findMany({ take: 10 })
     * 
     * // Only select the `postId`
     * const postTagWithPostIdOnly = await prisma.postTag.findMany({ select: { postId: true } })
     * 
     */
    findMany<T extends PostTagFindManyArgs>(args?: SelectSubset<T, PostTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PostTag.
     * @param {PostTagCreateArgs} args - Arguments to create a PostTag.
     * @example
     * // Create one PostTag
     * const PostTag = await prisma.postTag.create({
     *   data: {
     *     // ... data to create a PostTag
     *   }
     * })
     * 
     */
    create<T extends PostTagCreateArgs>(args: SelectSubset<T, PostTagCreateArgs<ExtArgs>>): Prisma__PostTagClient<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PostTags.
     * @param {PostTagCreateManyArgs} args - Arguments to create many PostTags.
     * @example
     * // Create many PostTags
     * const postTag = await prisma.postTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostTagCreateManyArgs>(args?: SelectSubset<T, PostTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PostTags and returns the data saved in the database.
     * @param {PostTagCreateManyAndReturnArgs} args - Arguments to create many PostTags.
     * @example
     * // Create many PostTags
     * const postTag = await prisma.postTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PostTags and only return the `postId`
     * const postTagWithPostIdOnly = await prisma.postTag.createManyAndReturn({
     *   select: { postId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostTagCreateManyAndReturnArgs>(args?: SelectSubset<T, PostTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PostTag.
     * @param {PostTagDeleteArgs} args - Arguments to delete one PostTag.
     * @example
     * // Delete one PostTag
     * const PostTag = await prisma.postTag.delete({
     *   where: {
     *     // ... filter to delete one PostTag
     *   }
     * })
     * 
     */
    delete<T extends PostTagDeleteArgs>(args: SelectSubset<T, PostTagDeleteArgs<ExtArgs>>): Prisma__PostTagClient<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PostTag.
     * @param {PostTagUpdateArgs} args - Arguments to update one PostTag.
     * @example
     * // Update one PostTag
     * const postTag = await prisma.postTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostTagUpdateArgs>(args: SelectSubset<T, PostTagUpdateArgs<ExtArgs>>): Prisma__PostTagClient<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PostTags.
     * @param {PostTagDeleteManyArgs} args - Arguments to filter PostTags to delete.
     * @example
     * // Delete a few PostTags
     * const { count } = await prisma.postTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostTagDeleteManyArgs>(args?: SelectSubset<T, PostTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostTags
     * const postTag = await prisma.postTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostTagUpdateManyArgs>(args: SelectSubset<T, PostTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostTags and returns the data updated in the database.
     * @param {PostTagUpdateManyAndReturnArgs} args - Arguments to update many PostTags.
     * @example
     * // Update many PostTags
     * const postTag = await prisma.postTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PostTags and only return the `postId`
     * const postTagWithPostIdOnly = await prisma.postTag.updateManyAndReturn({
     *   select: { postId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PostTagUpdateManyAndReturnArgs>(args: SelectSubset<T, PostTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PostTag.
     * @param {PostTagUpsertArgs} args - Arguments to update or create a PostTag.
     * @example
     * // Update or create a PostTag
     * const postTag = await prisma.postTag.upsert({
     *   create: {
     *     // ... data to create a PostTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostTag we want to update
     *   }
     * })
     */
    upsert<T extends PostTagUpsertArgs>(args: SelectSubset<T, PostTagUpsertArgs<ExtArgs>>): Prisma__PostTagClient<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PostTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTagCountArgs} args - Arguments to filter PostTags to count.
     * @example
     * // Count the number of PostTags
     * const count = await prisma.postTag.count({
     *   where: {
     *     // ... the filter for the PostTags we want to count
     *   }
     * })
    **/
    count<T extends PostTagCountArgs>(
      args?: Subset<T, PostTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostTagAggregateArgs>(args: Subset<T, PostTagAggregateArgs>): Prisma.PrismaPromise<GetPostTagAggregateType<T>>

    /**
     * Group by PostTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostTagGroupByArgs['orderBy'] }
        : { orderBy?: PostTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PostTag model
   */
  readonly fields: PostTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PostTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends BlogPostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BlogPostDefaultArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PostTag model
   */
  interface PostTagFieldRefs {
    readonly postId: FieldRef<"PostTag", 'String'>
    readonly tagId: FieldRef<"PostTag", 'String'>
    readonly createdAt: FieldRef<"PostTag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PostTag findUnique
   */
  export type PostTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * Filter, which PostTag to fetch.
     */
    where: PostTagWhereUniqueInput
  }

  /**
   * PostTag findUniqueOrThrow
   */
  export type PostTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * Filter, which PostTag to fetch.
     */
    where: PostTagWhereUniqueInput
  }

  /**
   * PostTag findFirst
   */
  export type PostTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * Filter, which PostTag to fetch.
     */
    where?: PostTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostTags to fetch.
     */
    orderBy?: PostTagOrderByWithRelationInput | PostTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostTags.
     */
    cursor?: PostTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostTags.
     */
    distinct?: PostTagScalarFieldEnum | PostTagScalarFieldEnum[]
  }

  /**
   * PostTag findFirstOrThrow
   */
  export type PostTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * Filter, which PostTag to fetch.
     */
    where?: PostTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostTags to fetch.
     */
    orderBy?: PostTagOrderByWithRelationInput | PostTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostTags.
     */
    cursor?: PostTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostTags.
     */
    distinct?: PostTagScalarFieldEnum | PostTagScalarFieldEnum[]
  }

  /**
   * PostTag findMany
   */
  export type PostTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * Filter, which PostTags to fetch.
     */
    where?: PostTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostTags to fetch.
     */
    orderBy?: PostTagOrderByWithRelationInput | PostTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostTags.
     */
    cursor?: PostTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostTags.
     */
    skip?: number
    distinct?: PostTagScalarFieldEnum | PostTagScalarFieldEnum[]
  }

  /**
   * PostTag create
   */
  export type PostTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * The data needed to create a PostTag.
     */
    data: XOR<PostTagCreateInput, PostTagUncheckedCreateInput>
  }

  /**
   * PostTag createMany
   */
  export type PostTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PostTags.
     */
    data: PostTagCreateManyInput | PostTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PostTag createManyAndReturn
   */
  export type PostTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * The data used to create many PostTags.
     */
    data: PostTagCreateManyInput | PostTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostTag update
   */
  export type PostTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * The data needed to update a PostTag.
     */
    data: XOR<PostTagUpdateInput, PostTagUncheckedUpdateInput>
    /**
     * Choose, which PostTag to update.
     */
    where: PostTagWhereUniqueInput
  }

  /**
   * PostTag updateMany
   */
  export type PostTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PostTags.
     */
    data: XOR<PostTagUpdateManyMutationInput, PostTagUncheckedUpdateManyInput>
    /**
     * Filter which PostTags to update
     */
    where?: PostTagWhereInput
    /**
     * Limit how many PostTags to update.
     */
    limit?: number
  }

  /**
   * PostTag updateManyAndReturn
   */
  export type PostTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * The data used to update PostTags.
     */
    data: XOR<PostTagUpdateManyMutationInput, PostTagUncheckedUpdateManyInput>
    /**
     * Filter which PostTags to update
     */
    where?: PostTagWhereInput
    /**
     * Limit how many PostTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostTag upsert
   */
  export type PostTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * The filter to search for the PostTag to update in case it exists.
     */
    where: PostTagWhereUniqueInput
    /**
     * In case the PostTag found by the `where` argument doesn't exist, create a new PostTag with this data.
     */
    create: XOR<PostTagCreateInput, PostTagUncheckedCreateInput>
    /**
     * In case the PostTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostTagUpdateInput, PostTagUncheckedUpdateInput>
  }

  /**
   * PostTag delete
   */
  export type PostTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * Filter which PostTag to delete.
     */
    where: PostTagWhereUniqueInput
  }

  /**
   * PostTag deleteMany
   */
  export type PostTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostTags to delete
     */
    where?: PostTagWhereInput
    /**
     * Limit how many PostTags to delete.
     */
    limit?: number
  }

  /**
   * PostTag without action
   */
  export type PostTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
  }


  /**
   * Model PostRelation
   */

  export type AggregatePostRelation = {
    _count: PostRelationCountAggregateOutputType | null
    _min: PostRelationMinAggregateOutputType | null
    _max: PostRelationMaxAggregateOutputType | null
  }

  export type PostRelationMinAggregateOutputType = {
    id: string | null
    originalPostId: string | null
    relatedPostId: string | null
    relationType: $Enums.RelationType | null
    createdAt: Date | null
  }

  export type PostRelationMaxAggregateOutputType = {
    id: string | null
    originalPostId: string | null
    relatedPostId: string | null
    relationType: $Enums.RelationType | null
    createdAt: Date | null
  }

  export type PostRelationCountAggregateOutputType = {
    id: number
    originalPostId: number
    relatedPostId: number
    relationType: number
    createdAt: number
    _all: number
  }


  export type PostRelationMinAggregateInputType = {
    id?: true
    originalPostId?: true
    relatedPostId?: true
    relationType?: true
    createdAt?: true
  }

  export type PostRelationMaxAggregateInputType = {
    id?: true
    originalPostId?: true
    relatedPostId?: true
    relationType?: true
    createdAt?: true
  }

  export type PostRelationCountAggregateInputType = {
    id?: true
    originalPostId?: true
    relatedPostId?: true
    relationType?: true
    createdAt?: true
    _all?: true
  }

  export type PostRelationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostRelation to aggregate.
     */
    where?: PostRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostRelations to fetch.
     */
    orderBy?: PostRelationOrderByWithRelationInput | PostRelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostRelations
    **/
    _count?: true | PostRelationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostRelationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostRelationMaxAggregateInputType
  }

  export type GetPostRelationAggregateType<T extends PostRelationAggregateArgs> = {
        [P in keyof T & keyof AggregatePostRelation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostRelation[P]>
      : GetScalarType<T[P], AggregatePostRelation[P]>
  }




  export type PostRelationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostRelationWhereInput
    orderBy?: PostRelationOrderByWithAggregationInput | PostRelationOrderByWithAggregationInput[]
    by: PostRelationScalarFieldEnum[] | PostRelationScalarFieldEnum
    having?: PostRelationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostRelationCountAggregateInputType | true
    _min?: PostRelationMinAggregateInputType
    _max?: PostRelationMaxAggregateInputType
  }

  export type PostRelationGroupByOutputType = {
    id: string
    originalPostId: string
    relatedPostId: string
    relationType: $Enums.RelationType
    createdAt: Date
    _count: PostRelationCountAggregateOutputType | null
    _min: PostRelationMinAggregateOutputType | null
    _max: PostRelationMaxAggregateOutputType | null
  }

  type GetPostRelationGroupByPayload<T extends PostRelationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostRelationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostRelationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostRelationGroupByOutputType[P]>
            : GetScalarType<T[P], PostRelationGroupByOutputType[P]>
        }
      >
    >


  export type PostRelationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    originalPostId?: boolean
    relatedPostId?: boolean
    relationType?: boolean
    createdAt?: boolean
    originalPost?: boolean | BlogPostDefaultArgs<ExtArgs>
    relatedPost?: boolean | BlogPostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postRelation"]>

  export type PostRelationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    originalPostId?: boolean
    relatedPostId?: boolean
    relationType?: boolean
    createdAt?: boolean
    originalPost?: boolean | BlogPostDefaultArgs<ExtArgs>
    relatedPost?: boolean | BlogPostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postRelation"]>

  export type PostRelationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    originalPostId?: boolean
    relatedPostId?: boolean
    relationType?: boolean
    createdAt?: boolean
    originalPost?: boolean | BlogPostDefaultArgs<ExtArgs>
    relatedPost?: boolean | BlogPostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postRelation"]>

  export type PostRelationSelectScalar = {
    id?: boolean
    originalPostId?: boolean
    relatedPostId?: boolean
    relationType?: boolean
    createdAt?: boolean
  }

  export type PostRelationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "originalPostId" | "relatedPostId" | "relationType" | "createdAt", ExtArgs["result"]["postRelation"]>
  export type PostRelationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    originalPost?: boolean | BlogPostDefaultArgs<ExtArgs>
    relatedPost?: boolean | BlogPostDefaultArgs<ExtArgs>
  }
  export type PostRelationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    originalPost?: boolean | BlogPostDefaultArgs<ExtArgs>
    relatedPost?: boolean | BlogPostDefaultArgs<ExtArgs>
  }
  export type PostRelationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    originalPost?: boolean | BlogPostDefaultArgs<ExtArgs>
    relatedPost?: boolean | BlogPostDefaultArgs<ExtArgs>
  }

  export type $PostRelationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PostRelation"
    objects: {
      originalPost: Prisma.$BlogPostPayload<ExtArgs>
      relatedPost: Prisma.$BlogPostPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      originalPostId: string
      relatedPostId: string
      relationType: $Enums.RelationType
      createdAt: Date
    }, ExtArgs["result"]["postRelation"]>
    composites: {}
  }

  type PostRelationGetPayload<S extends boolean | null | undefined | PostRelationDefaultArgs> = $Result.GetResult<Prisma.$PostRelationPayload, S>

  type PostRelationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostRelationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostRelationCountAggregateInputType | true
    }

  export interface PostRelationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostRelation'], meta: { name: 'PostRelation' } }
    /**
     * Find zero or one PostRelation that matches the filter.
     * @param {PostRelationFindUniqueArgs} args - Arguments to find a PostRelation
     * @example
     * // Get one PostRelation
     * const postRelation = await prisma.postRelation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostRelationFindUniqueArgs>(args: SelectSubset<T, PostRelationFindUniqueArgs<ExtArgs>>): Prisma__PostRelationClient<$Result.GetResult<Prisma.$PostRelationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PostRelation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostRelationFindUniqueOrThrowArgs} args - Arguments to find a PostRelation
     * @example
     * // Get one PostRelation
     * const postRelation = await prisma.postRelation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostRelationFindUniqueOrThrowArgs>(args: SelectSubset<T, PostRelationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostRelationClient<$Result.GetResult<Prisma.$PostRelationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostRelation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostRelationFindFirstArgs} args - Arguments to find a PostRelation
     * @example
     * // Get one PostRelation
     * const postRelation = await prisma.postRelation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostRelationFindFirstArgs>(args?: SelectSubset<T, PostRelationFindFirstArgs<ExtArgs>>): Prisma__PostRelationClient<$Result.GetResult<Prisma.$PostRelationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostRelation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostRelationFindFirstOrThrowArgs} args - Arguments to find a PostRelation
     * @example
     * // Get one PostRelation
     * const postRelation = await prisma.postRelation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostRelationFindFirstOrThrowArgs>(args?: SelectSubset<T, PostRelationFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostRelationClient<$Result.GetResult<Prisma.$PostRelationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PostRelations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostRelationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostRelations
     * const postRelations = await prisma.postRelation.findMany()
     * 
     * // Get first 10 PostRelations
     * const postRelations = await prisma.postRelation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postRelationWithIdOnly = await prisma.postRelation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostRelationFindManyArgs>(args?: SelectSubset<T, PostRelationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostRelationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PostRelation.
     * @param {PostRelationCreateArgs} args - Arguments to create a PostRelation.
     * @example
     * // Create one PostRelation
     * const PostRelation = await prisma.postRelation.create({
     *   data: {
     *     // ... data to create a PostRelation
     *   }
     * })
     * 
     */
    create<T extends PostRelationCreateArgs>(args: SelectSubset<T, PostRelationCreateArgs<ExtArgs>>): Prisma__PostRelationClient<$Result.GetResult<Prisma.$PostRelationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PostRelations.
     * @param {PostRelationCreateManyArgs} args - Arguments to create many PostRelations.
     * @example
     * // Create many PostRelations
     * const postRelation = await prisma.postRelation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostRelationCreateManyArgs>(args?: SelectSubset<T, PostRelationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PostRelations and returns the data saved in the database.
     * @param {PostRelationCreateManyAndReturnArgs} args - Arguments to create many PostRelations.
     * @example
     * // Create many PostRelations
     * const postRelation = await prisma.postRelation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PostRelations and only return the `id`
     * const postRelationWithIdOnly = await prisma.postRelation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostRelationCreateManyAndReturnArgs>(args?: SelectSubset<T, PostRelationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostRelationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PostRelation.
     * @param {PostRelationDeleteArgs} args - Arguments to delete one PostRelation.
     * @example
     * // Delete one PostRelation
     * const PostRelation = await prisma.postRelation.delete({
     *   where: {
     *     // ... filter to delete one PostRelation
     *   }
     * })
     * 
     */
    delete<T extends PostRelationDeleteArgs>(args: SelectSubset<T, PostRelationDeleteArgs<ExtArgs>>): Prisma__PostRelationClient<$Result.GetResult<Prisma.$PostRelationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PostRelation.
     * @param {PostRelationUpdateArgs} args - Arguments to update one PostRelation.
     * @example
     * // Update one PostRelation
     * const postRelation = await prisma.postRelation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostRelationUpdateArgs>(args: SelectSubset<T, PostRelationUpdateArgs<ExtArgs>>): Prisma__PostRelationClient<$Result.GetResult<Prisma.$PostRelationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PostRelations.
     * @param {PostRelationDeleteManyArgs} args - Arguments to filter PostRelations to delete.
     * @example
     * // Delete a few PostRelations
     * const { count } = await prisma.postRelation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostRelationDeleteManyArgs>(args?: SelectSubset<T, PostRelationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostRelations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostRelationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostRelations
     * const postRelation = await prisma.postRelation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostRelationUpdateManyArgs>(args: SelectSubset<T, PostRelationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostRelations and returns the data updated in the database.
     * @param {PostRelationUpdateManyAndReturnArgs} args - Arguments to update many PostRelations.
     * @example
     * // Update many PostRelations
     * const postRelation = await prisma.postRelation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PostRelations and only return the `id`
     * const postRelationWithIdOnly = await prisma.postRelation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PostRelationUpdateManyAndReturnArgs>(args: SelectSubset<T, PostRelationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostRelationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PostRelation.
     * @param {PostRelationUpsertArgs} args - Arguments to update or create a PostRelation.
     * @example
     * // Update or create a PostRelation
     * const postRelation = await prisma.postRelation.upsert({
     *   create: {
     *     // ... data to create a PostRelation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostRelation we want to update
     *   }
     * })
     */
    upsert<T extends PostRelationUpsertArgs>(args: SelectSubset<T, PostRelationUpsertArgs<ExtArgs>>): Prisma__PostRelationClient<$Result.GetResult<Prisma.$PostRelationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PostRelations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostRelationCountArgs} args - Arguments to filter PostRelations to count.
     * @example
     * // Count the number of PostRelations
     * const count = await prisma.postRelation.count({
     *   where: {
     *     // ... the filter for the PostRelations we want to count
     *   }
     * })
    **/
    count<T extends PostRelationCountArgs>(
      args?: Subset<T, PostRelationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostRelationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostRelation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostRelationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostRelationAggregateArgs>(args: Subset<T, PostRelationAggregateArgs>): Prisma.PrismaPromise<GetPostRelationAggregateType<T>>

    /**
     * Group by PostRelation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostRelationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostRelationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostRelationGroupByArgs['orderBy'] }
        : { orderBy?: PostRelationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostRelationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostRelationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PostRelation model
   */
  readonly fields: PostRelationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PostRelation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostRelationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    originalPost<T extends BlogPostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BlogPostDefaultArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    relatedPost<T extends BlogPostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BlogPostDefaultArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PostRelation model
   */
  interface PostRelationFieldRefs {
    readonly id: FieldRef<"PostRelation", 'String'>
    readonly originalPostId: FieldRef<"PostRelation", 'String'>
    readonly relatedPostId: FieldRef<"PostRelation", 'String'>
    readonly relationType: FieldRef<"PostRelation", 'RelationType'>
    readonly createdAt: FieldRef<"PostRelation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PostRelation findUnique
   */
  export type PostRelationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostRelation
     */
    select?: PostRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostRelation
     */
    omit?: PostRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostRelationInclude<ExtArgs> | null
    /**
     * Filter, which PostRelation to fetch.
     */
    where: PostRelationWhereUniqueInput
  }

  /**
   * PostRelation findUniqueOrThrow
   */
  export type PostRelationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostRelation
     */
    select?: PostRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostRelation
     */
    omit?: PostRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostRelationInclude<ExtArgs> | null
    /**
     * Filter, which PostRelation to fetch.
     */
    where: PostRelationWhereUniqueInput
  }

  /**
   * PostRelation findFirst
   */
  export type PostRelationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostRelation
     */
    select?: PostRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostRelation
     */
    omit?: PostRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostRelationInclude<ExtArgs> | null
    /**
     * Filter, which PostRelation to fetch.
     */
    where?: PostRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostRelations to fetch.
     */
    orderBy?: PostRelationOrderByWithRelationInput | PostRelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostRelations.
     */
    cursor?: PostRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostRelations.
     */
    distinct?: PostRelationScalarFieldEnum | PostRelationScalarFieldEnum[]
  }

  /**
   * PostRelation findFirstOrThrow
   */
  export type PostRelationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostRelation
     */
    select?: PostRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostRelation
     */
    omit?: PostRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostRelationInclude<ExtArgs> | null
    /**
     * Filter, which PostRelation to fetch.
     */
    where?: PostRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostRelations to fetch.
     */
    orderBy?: PostRelationOrderByWithRelationInput | PostRelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostRelations.
     */
    cursor?: PostRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostRelations.
     */
    distinct?: PostRelationScalarFieldEnum | PostRelationScalarFieldEnum[]
  }

  /**
   * PostRelation findMany
   */
  export type PostRelationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostRelation
     */
    select?: PostRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostRelation
     */
    omit?: PostRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostRelationInclude<ExtArgs> | null
    /**
     * Filter, which PostRelations to fetch.
     */
    where?: PostRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostRelations to fetch.
     */
    orderBy?: PostRelationOrderByWithRelationInput | PostRelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostRelations.
     */
    cursor?: PostRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostRelations.
     */
    skip?: number
    distinct?: PostRelationScalarFieldEnum | PostRelationScalarFieldEnum[]
  }

  /**
   * PostRelation create
   */
  export type PostRelationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostRelation
     */
    select?: PostRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostRelation
     */
    omit?: PostRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostRelationInclude<ExtArgs> | null
    /**
     * The data needed to create a PostRelation.
     */
    data: XOR<PostRelationCreateInput, PostRelationUncheckedCreateInput>
  }

  /**
   * PostRelation createMany
   */
  export type PostRelationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PostRelations.
     */
    data: PostRelationCreateManyInput | PostRelationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PostRelation createManyAndReturn
   */
  export type PostRelationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostRelation
     */
    select?: PostRelationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostRelation
     */
    omit?: PostRelationOmit<ExtArgs> | null
    /**
     * The data used to create many PostRelations.
     */
    data: PostRelationCreateManyInput | PostRelationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostRelationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostRelation update
   */
  export type PostRelationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostRelation
     */
    select?: PostRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostRelation
     */
    omit?: PostRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostRelationInclude<ExtArgs> | null
    /**
     * The data needed to update a PostRelation.
     */
    data: XOR<PostRelationUpdateInput, PostRelationUncheckedUpdateInput>
    /**
     * Choose, which PostRelation to update.
     */
    where: PostRelationWhereUniqueInput
  }

  /**
   * PostRelation updateMany
   */
  export type PostRelationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PostRelations.
     */
    data: XOR<PostRelationUpdateManyMutationInput, PostRelationUncheckedUpdateManyInput>
    /**
     * Filter which PostRelations to update
     */
    where?: PostRelationWhereInput
    /**
     * Limit how many PostRelations to update.
     */
    limit?: number
  }

  /**
   * PostRelation updateManyAndReturn
   */
  export type PostRelationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostRelation
     */
    select?: PostRelationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostRelation
     */
    omit?: PostRelationOmit<ExtArgs> | null
    /**
     * The data used to update PostRelations.
     */
    data: XOR<PostRelationUpdateManyMutationInput, PostRelationUncheckedUpdateManyInput>
    /**
     * Filter which PostRelations to update
     */
    where?: PostRelationWhereInput
    /**
     * Limit how many PostRelations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostRelationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostRelation upsert
   */
  export type PostRelationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostRelation
     */
    select?: PostRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostRelation
     */
    omit?: PostRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostRelationInclude<ExtArgs> | null
    /**
     * The filter to search for the PostRelation to update in case it exists.
     */
    where: PostRelationWhereUniqueInput
    /**
     * In case the PostRelation found by the `where` argument doesn't exist, create a new PostRelation with this data.
     */
    create: XOR<PostRelationCreateInput, PostRelationUncheckedCreateInput>
    /**
     * In case the PostRelation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostRelationUpdateInput, PostRelationUncheckedUpdateInput>
  }

  /**
   * PostRelation delete
   */
  export type PostRelationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostRelation
     */
    select?: PostRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostRelation
     */
    omit?: PostRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostRelationInclude<ExtArgs> | null
    /**
     * Filter which PostRelation to delete.
     */
    where: PostRelationWhereUniqueInput
  }

  /**
   * PostRelation deleteMany
   */
  export type PostRelationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostRelations to delete
     */
    where?: PostRelationWhereInput
    /**
     * Limit how many PostRelations to delete.
     */
    limit?: number
  }

  /**
   * PostRelation without action
   */
  export type PostRelationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostRelation
     */
    select?: PostRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostRelation
     */
    omit?: PostRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostRelationInclude<ExtArgs> | null
  }


  /**
   * Model PostVersion
   */

  export type AggregatePostVersion = {
    _count: PostVersionCountAggregateOutputType | null
    _avg: PostVersionAvgAggregateOutputType | null
    _sum: PostVersionSumAggregateOutputType | null
    _min: PostVersionMinAggregateOutputType | null
    _max: PostVersionMaxAggregateOutputType | null
  }

  export type PostVersionAvgAggregateOutputType = {
    version: number | null
  }

  export type PostVersionSumAggregateOutputType = {
    version: number | null
  }

  export type PostVersionMinAggregateOutputType = {
    id: string | null
    postId: string | null
    version: number | null
    title: string | null
    content: string | null
    excerpt: string | null
    changeType: $Enums.ChangeType | null
    changeNotes: string | null
    authorId: string | null
    createdAt: Date | null
  }

  export type PostVersionMaxAggregateOutputType = {
    id: string | null
    postId: string | null
    version: number | null
    title: string | null
    content: string | null
    excerpt: string | null
    changeType: $Enums.ChangeType | null
    changeNotes: string | null
    authorId: string | null
    createdAt: Date | null
  }

  export type PostVersionCountAggregateOutputType = {
    id: number
    postId: number
    version: number
    title: number
    content: number
    excerpt: number
    changeType: number
    changeNotes: number
    authorId: number
    createdAt: number
    _all: number
  }


  export type PostVersionAvgAggregateInputType = {
    version?: true
  }

  export type PostVersionSumAggregateInputType = {
    version?: true
  }

  export type PostVersionMinAggregateInputType = {
    id?: true
    postId?: true
    version?: true
    title?: true
    content?: true
    excerpt?: true
    changeType?: true
    changeNotes?: true
    authorId?: true
    createdAt?: true
  }

  export type PostVersionMaxAggregateInputType = {
    id?: true
    postId?: true
    version?: true
    title?: true
    content?: true
    excerpt?: true
    changeType?: true
    changeNotes?: true
    authorId?: true
    createdAt?: true
  }

  export type PostVersionCountAggregateInputType = {
    id?: true
    postId?: true
    version?: true
    title?: true
    content?: true
    excerpt?: true
    changeType?: true
    changeNotes?: true
    authorId?: true
    createdAt?: true
    _all?: true
  }

  export type PostVersionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostVersion to aggregate.
     */
    where?: PostVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostVersions to fetch.
     */
    orderBy?: PostVersionOrderByWithRelationInput | PostVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostVersions
    **/
    _count?: true | PostVersionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostVersionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostVersionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostVersionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostVersionMaxAggregateInputType
  }

  export type GetPostVersionAggregateType<T extends PostVersionAggregateArgs> = {
        [P in keyof T & keyof AggregatePostVersion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostVersion[P]>
      : GetScalarType<T[P], AggregatePostVersion[P]>
  }




  export type PostVersionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostVersionWhereInput
    orderBy?: PostVersionOrderByWithAggregationInput | PostVersionOrderByWithAggregationInput[]
    by: PostVersionScalarFieldEnum[] | PostVersionScalarFieldEnum
    having?: PostVersionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostVersionCountAggregateInputType | true
    _avg?: PostVersionAvgAggregateInputType
    _sum?: PostVersionSumAggregateInputType
    _min?: PostVersionMinAggregateInputType
    _max?: PostVersionMaxAggregateInputType
  }

  export type PostVersionGroupByOutputType = {
    id: string
    postId: string
    version: number
    title: string
    content: string
    excerpt: string | null
    changeType: $Enums.ChangeType
    changeNotes: string | null
    authorId: string
    createdAt: Date
    _count: PostVersionCountAggregateOutputType | null
    _avg: PostVersionAvgAggregateOutputType | null
    _sum: PostVersionSumAggregateOutputType | null
    _min: PostVersionMinAggregateOutputType | null
    _max: PostVersionMaxAggregateOutputType | null
  }

  type GetPostVersionGroupByPayload<T extends PostVersionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostVersionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostVersionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostVersionGroupByOutputType[P]>
            : GetScalarType<T[P], PostVersionGroupByOutputType[P]>
        }
      >
    >


  export type PostVersionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    version?: boolean
    title?: boolean
    content?: boolean
    excerpt?: boolean
    changeType?: boolean
    changeNotes?: boolean
    authorId?: boolean
    createdAt?: boolean
    author?: boolean | AuthorDefaultArgs<ExtArgs>
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postVersion"]>

  export type PostVersionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    version?: boolean
    title?: boolean
    content?: boolean
    excerpt?: boolean
    changeType?: boolean
    changeNotes?: boolean
    authorId?: boolean
    createdAt?: boolean
    author?: boolean | AuthorDefaultArgs<ExtArgs>
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postVersion"]>

  export type PostVersionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    version?: boolean
    title?: boolean
    content?: boolean
    excerpt?: boolean
    changeType?: boolean
    changeNotes?: boolean
    authorId?: boolean
    createdAt?: boolean
    author?: boolean | AuthorDefaultArgs<ExtArgs>
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postVersion"]>

  export type PostVersionSelectScalar = {
    id?: boolean
    postId?: boolean
    version?: boolean
    title?: boolean
    content?: boolean
    excerpt?: boolean
    changeType?: boolean
    changeNotes?: boolean
    authorId?: boolean
    createdAt?: boolean
  }

  export type PostVersionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "postId" | "version" | "title" | "content" | "excerpt" | "changeType" | "changeNotes" | "authorId" | "createdAt", ExtArgs["result"]["postVersion"]>
  export type PostVersionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | AuthorDefaultArgs<ExtArgs>
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
  }
  export type PostVersionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | AuthorDefaultArgs<ExtArgs>
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
  }
  export type PostVersionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | AuthorDefaultArgs<ExtArgs>
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
  }

  export type $PostVersionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PostVersion"
    objects: {
      author: Prisma.$AuthorPayload<ExtArgs>
      post: Prisma.$BlogPostPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postId: string
      version: number
      title: string
      content: string
      excerpt: string | null
      changeType: $Enums.ChangeType
      changeNotes: string | null
      authorId: string
      createdAt: Date
    }, ExtArgs["result"]["postVersion"]>
    composites: {}
  }

  type PostVersionGetPayload<S extends boolean | null | undefined | PostVersionDefaultArgs> = $Result.GetResult<Prisma.$PostVersionPayload, S>

  type PostVersionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostVersionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostVersionCountAggregateInputType | true
    }

  export interface PostVersionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostVersion'], meta: { name: 'PostVersion' } }
    /**
     * Find zero or one PostVersion that matches the filter.
     * @param {PostVersionFindUniqueArgs} args - Arguments to find a PostVersion
     * @example
     * // Get one PostVersion
     * const postVersion = await prisma.postVersion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostVersionFindUniqueArgs>(args: SelectSubset<T, PostVersionFindUniqueArgs<ExtArgs>>): Prisma__PostVersionClient<$Result.GetResult<Prisma.$PostVersionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PostVersion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostVersionFindUniqueOrThrowArgs} args - Arguments to find a PostVersion
     * @example
     * // Get one PostVersion
     * const postVersion = await prisma.postVersion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostVersionFindUniqueOrThrowArgs>(args: SelectSubset<T, PostVersionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostVersionClient<$Result.GetResult<Prisma.$PostVersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostVersion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostVersionFindFirstArgs} args - Arguments to find a PostVersion
     * @example
     * // Get one PostVersion
     * const postVersion = await prisma.postVersion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostVersionFindFirstArgs>(args?: SelectSubset<T, PostVersionFindFirstArgs<ExtArgs>>): Prisma__PostVersionClient<$Result.GetResult<Prisma.$PostVersionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostVersion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostVersionFindFirstOrThrowArgs} args - Arguments to find a PostVersion
     * @example
     * // Get one PostVersion
     * const postVersion = await prisma.postVersion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostVersionFindFirstOrThrowArgs>(args?: SelectSubset<T, PostVersionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostVersionClient<$Result.GetResult<Prisma.$PostVersionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PostVersions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostVersionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostVersions
     * const postVersions = await prisma.postVersion.findMany()
     * 
     * // Get first 10 PostVersions
     * const postVersions = await prisma.postVersion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postVersionWithIdOnly = await prisma.postVersion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostVersionFindManyArgs>(args?: SelectSubset<T, PostVersionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostVersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PostVersion.
     * @param {PostVersionCreateArgs} args - Arguments to create a PostVersion.
     * @example
     * // Create one PostVersion
     * const PostVersion = await prisma.postVersion.create({
     *   data: {
     *     // ... data to create a PostVersion
     *   }
     * })
     * 
     */
    create<T extends PostVersionCreateArgs>(args: SelectSubset<T, PostVersionCreateArgs<ExtArgs>>): Prisma__PostVersionClient<$Result.GetResult<Prisma.$PostVersionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PostVersions.
     * @param {PostVersionCreateManyArgs} args - Arguments to create many PostVersions.
     * @example
     * // Create many PostVersions
     * const postVersion = await prisma.postVersion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostVersionCreateManyArgs>(args?: SelectSubset<T, PostVersionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PostVersions and returns the data saved in the database.
     * @param {PostVersionCreateManyAndReturnArgs} args - Arguments to create many PostVersions.
     * @example
     * // Create many PostVersions
     * const postVersion = await prisma.postVersion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PostVersions and only return the `id`
     * const postVersionWithIdOnly = await prisma.postVersion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostVersionCreateManyAndReturnArgs>(args?: SelectSubset<T, PostVersionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostVersionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PostVersion.
     * @param {PostVersionDeleteArgs} args - Arguments to delete one PostVersion.
     * @example
     * // Delete one PostVersion
     * const PostVersion = await prisma.postVersion.delete({
     *   where: {
     *     // ... filter to delete one PostVersion
     *   }
     * })
     * 
     */
    delete<T extends PostVersionDeleteArgs>(args: SelectSubset<T, PostVersionDeleteArgs<ExtArgs>>): Prisma__PostVersionClient<$Result.GetResult<Prisma.$PostVersionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PostVersion.
     * @param {PostVersionUpdateArgs} args - Arguments to update one PostVersion.
     * @example
     * // Update one PostVersion
     * const postVersion = await prisma.postVersion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostVersionUpdateArgs>(args: SelectSubset<T, PostVersionUpdateArgs<ExtArgs>>): Prisma__PostVersionClient<$Result.GetResult<Prisma.$PostVersionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PostVersions.
     * @param {PostVersionDeleteManyArgs} args - Arguments to filter PostVersions to delete.
     * @example
     * // Delete a few PostVersions
     * const { count } = await prisma.postVersion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostVersionDeleteManyArgs>(args?: SelectSubset<T, PostVersionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostVersionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostVersions
     * const postVersion = await prisma.postVersion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostVersionUpdateManyArgs>(args: SelectSubset<T, PostVersionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostVersions and returns the data updated in the database.
     * @param {PostVersionUpdateManyAndReturnArgs} args - Arguments to update many PostVersions.
     * @example
     * // Update many PostVersions
     * const postVersion = await prisma.postVersion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PostVersions and only return the `id`
     * const postVersionWithIdOnly = await prisma.postVersion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PostVersionUpdateManyAndReturnArgs>(args: SelectSubset<T, PostVersionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostVersionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PostVersion.
     * @param {PostVersionUpsertArgs} args - Arguments to update or create a PostVersion.
     * @example
     * // Update or create a PostVersion
     * const postVersion = await prisma.postVersion.upsert({
     *   create: {
     *     // ... data to create a PostVersion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostVersion we want to update
     *   }
     * })
     */
    upsert<T extends PostVersionUpsertArgs>(args: SelectSubset<T, PostVersionUpsertArgs<ExtArgs>>): Prisma__PostVersionClient<$Result.GetResult<Prisma.$PostVersionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PostVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostVersionCountArgs} args - Arguments to filter PostVersions to count.
     * @example
     * // Count the number of PostVersions
     * const count = await prisma.postVersion.count({
     *   where: {
     *     // ... the filter for the PostVersions we want to count
     *   }
     * })
    **/
    count<T extends PostVersionCountArgs>(
      args?: Subset<T, PostVersionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostVersionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostVersionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostVersionAggregateArgs>(args: Subset<T, PostVersionAggregateArgs>): Prisma.PrismaPromise<GetPostVersionAggregateType<T>>

    /**
     * Group by PostVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostVersionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostVersionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostVersionGroupByArgs['orderBy'] }
        : { orderBy?: PostVersionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostVersionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostVersionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PostVersion model
   */
  readonly fields: PostVersionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PostVersion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostVersionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends AuthorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AuthorDefaultArgs<ExtArgs>>): Prisma__AuthorClient<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    post<T extends BlogPostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BlogPostDefaultArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PostVersion model
   */
  interface PostVersionFieldRefs {
    readonly id: FieldRef<"PostVersion", 'String'>
    readonly postId: FieldRef<"PostVersion", 'String'>
    readonly version: FieldRef<"PostVersion", 'Int'>
    readonly title: FieldRef<"PostVersion", 'String'>
    readonly content: FieldRef<"PostVersion", 'String'>
    readonly excerpt: FieldRef<"PostVersion", 'String'>
    readonly changeType: FieldRef<"PostVersion", 'ChangeType'>
    readonly changeNotes: FieldRef<"PostVersion", 'String'>
    readonly authorId: FieldRef<"PostVersion", 'String'>
    readonly createdAt: FieldRef<"PostVersion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PostVersion findUnique
   */
  export type PostVersionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostVersion
     */
    select?: PostVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostVersion
     */
    omit?: PostVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostVersionInclude<ExtArgs> | null
    /**
     * Filter, which PostVersion to fetch.
     */
    where: PostVersionWhereUniqueInput
  }

  /**
   * PostVersion findUniqueOrThrow
   */
  export type PostVersionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostVersion
     */
    select?: PostVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostVersion
     */
    omit?: PostVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostVersionInclude<ExtArgs> | null
    /**
     * Filter, which PostVersion to fetch.
     */
    where: PostVersionWhereUniqueInput
  }

  /**
   * PostVersion findFirst
   */
  export type PostVersionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostVersion
     */
    select?: PostVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostVersion
     */
    omit?: PostVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostVersionInclude<ExtArgs> | null
    /**
     * Filter, which PostVersion to fetch.
     */
    where?: PostVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostVersions to fetch.
     */
    orderBy?: PostVersionOrderByWithRelationInput | PostVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostVersions.
     */
    cursor?: PostVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostVersions.
     */
    distinct?: PostVersionScalarFieldEnum | PostVersionScalarFieldEnum[]
  }

  /**
   * PostVersion findFirstOrThrow
   */
  export type PostVersionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostVersion
     */
    select?: PostVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostVersion
     */
    omit?: PostVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostVersionInclude<ExtArgs> | null
    /**
     * Filter, which PostVersion to fetch.
     */
    where?: PostVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostVersions to fetch.
     */
    orderBy?: PostVersionOrderByWithRelationInput | PostVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostVersions.
     */
    cursor?: PostVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostVersions.
     */
    distinct?: PostVersionScalarFieldEnum | PostVersionScalarFieldEnum[]
  }

  /**
   * PostVersion findMany
   */
  export type PostVersionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostVersion
     */
    select?: PostVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostVersion
     */
    omit?: PostVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostVersionInclude<ExtArgs> | null
    /**
     * Filter, which PostVersions to fetch.
     */
    where?: PostVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostVersions to fetch.
     */
    orderBy?: PostVersionOrderByWithRelationInput | PostVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostVersions.
     */
    cursor?: PostVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostVersions.
     */
    skip?: number
    distinct?: PostVersionScalarFieldEnum | PostVersionScalarFieldEnum[]
  }

  /**
   * PostVersion create
   */
  export type PostVersionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostVersion
     */
    select?: PostVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostVersion
     */
    omit?: PostVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostVersionInclude<ExtArgs> | null
    /**
     * The data needed to create a PostVersion.
     */
    data: XOR<PostVersionCreateInput, PostVersionUncheckedCreateInput>
  }

  /**
   * PostVersion createMany
   */
  export type PostVersionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PostVersions.
     */
    data: PostVersionCreateManyInput | PostVersionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PostVersion createManyAndReturn
   */
  export type PostVersionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostVersion
     */
    select?: PostVersionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostVersion
     */
    omit?: PostVersionOmit<ExtArgs> | null
    /**
     * The data used to create many PostVersions.
     */
    data: PostVersionCreateManyInput | PostVersionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostVersionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostVersion update
   */
  export type PostVersionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostVersion
     */
    select?: PostVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostVersion
     */
    omit?: PostVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostVersionInclude<ExtArgs> | null
    /**
     * The data needed to update a PostVersion.
     */
    data: XOR<PostVersionUpdateInput, PostVersionUncheckedUpdateInput>
    /**
     * Choose, which PostVersion to update.
     */
    where: PostVersionWhereUniqueInput
  }

  /**
   * PostVersion updateMany
   */
  export type PostVersionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PostVersions.
     */
    data: XOR<PostVersionUpdateManyMutationInput, PostVersionUncheckedUpdateManyInput>
    /**
     * Filter which PostVersions to update
     */
    where?: PostVersionWhereInput
    /**
     * Limit how many PostVersions to update.
     */
    limit?: number
  }

  /**
   * PostVersion updateManyAndReturn
   */
  export type PostVersionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostVersion
     */
    select?: PostVersionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostVersion
     */
    omit?: PostVersionOmit<ExtArgs> | null
    /**
     * The data used to update PostVersions.
     */
    data: XOR<PostVersionUpdateManyMutationInput, PostVersionUncheckedUpdateManyInput>
    /**
     * Filter which PostVersions to update
     */
    where?: PostVersionWhereInput
    /**
     * Limit how many PostVersions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostVersionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostVersion upsert
   */
  export type PostVersionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostVersion
     */
    select?: PostVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostVersion
     */
    omit?: PostVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostVersionInclude<ExtArgs> | null
    /**
     * The filter to search for the PostVersion to update in case it exists.
     */
    where: PostVersionWhereUniqueInput
    /**
     * In case the PostVersion found by the `where` argument doesn't exist, create a new PostVersion with this data.
     */
    create: XOR<PostVersionCreateInput, PostVersionUncheckedCreateInput>
    /**
     * In case the PostVersion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostVersionUpdateInput, PostVersionUncheckedUpdateInput>
  }

  /**
   * PostVersion delete
   */
  export type PostVersionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostVersion
     */
    select?: PostVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostVersion
     */
    omit?: PostVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostVersionInclude<ExtArgs> | null
    /**
     * Filter which PostVersion to delete.
     */
    where: PostVersionWhereUniqueInput
  }

  /**
   * PostVersion deleteMany
   */
  export type PostVersionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostVersions to delete
     */
    where?: PostVersionWhereInput
    /**
     * Limit how many PostVersions to delete.
     */
    limit?: number
  }

  /**
   * PostVersion without action
   */
  export type PostVersionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostVersion
     */
    select?: PostVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostVersion
     */
    omit?: PostVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostVersionInclude<ExtArgs> | null
  }


  /**
   * Model PostSeries
   */

  export type AggregatePostSeries = {
    _count: PostSeriesCountAggregateOutputType | null
    _avg: PostSeriesAvgAggregateOutputType | null
    _sum: PostSeriesSumAggregateOutputType | null
    _min: PostSeriesMinAggregateOutputType | null
    _max: PostSeriesMaxAggregateOutputType | null
  }

  export type PostSeriesAvgAggregateOutputType = {
    totalPosts: number | null
    totalViews: number | null
  }

  export type PostSeriesSumAggregateOutputType = {
    totalPosts: number | null
    totalViews: number | null
  }

  export type PostSeriesMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    metaTitle: string | null
    metaDescription: string | null
    coverImage: string | null
    color: string | null
    totalPosts: number | null
    totalViews: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostSeriesMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    metaTitle: string | null
    metaDescription: string | null
    coverImage: string | null
    color: string | null
    totalPosts: number | null
    totalViews: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostSeriesCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    metaTitle: number
    metaDescription: number
    coverImage: number
    color: number
    totalPosts: number
    totalViews: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PostSeriesAvgAggregateInputType = {
    totalPosts?: true
    totalViews?: true
  }

  export type PostSeriesSumAggregateInputType = {
    totalPosts?: true
    totalViews?: true
  }

  export type PostSeriesMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    metaTitle?: true
    metaDescription?: true
    coverImage?: true
    color?: true
    totalPosts?: true
    totalViews?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostSeriesMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    metaTitle?: true
    metaDescription?: true
    coverImage?: true
    color?: true
    totalPosts?: true
    totalViews?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostSeriesCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    metaTitle?: true
    metaDescription?: true
    coverImage?: true
    color?: true
    totalPosts?: true
    totalViews?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PostSeriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostSeries to aggregate.
     */
    where?: PostSeriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostSeries to fetch.
     */
    orderBy?: PostSeriesOrderByWithRelationInput | PostSeriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostSeriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostSeries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostSeries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostSeries
    **/
    _count?: true | PostSeriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostSeriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostSeriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostSeriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostSeriesMaxAggregateInputType
  }

  export type GetPostSeriesAggregateType<T extends PostSeriesAggregateArgs> = {
        [P in keyof T & keyof AggregatePostSeries]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostSeries[P]>
      : GetScalarType<T[P], AggregatePostSeries[P]>
  }




  export type PostSeriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostSeriesWhereInput
    orderBy?: PostSeriesOrderByWithAggregationInput | PostSeriesOrderByWithAggregationInput[]
    by: PostSeriesScalarFieldEnum[] | PostSeriesScalarFieldEnum
    having?: PostSeriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostSeriesCountAggregateInputType | true
    _avg?: PostSeriesAvgAggregateInputType
    _sum?: PostSeriesSumAggregateInputType
    _min?: PostSeriesMinAggregateInputType
    _max?: PostSeriesMaxAggregateInputType
  }

  export type PostSeriesGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    metaTitle: string | null
    metaDescription: string | null
    coverImage: string | null
    color: string | null
    totalPosts: number
    totalViews: number
    createdAt: Date
    updatedAt: Date
    _count: PostSeriesCountAggregateOutputType | null
    _avg: PostSeriesAvgAggregateOutputType | null
    _sum: PostSeriesSumAggregateOutputType | null
    _min: PostSeriesMinAggregateOutputType | null
    _max: PostSeriesMaxAggregateOutputType | null
  }

  type GetPostSeriesGroupByPayload<T extends PostSeriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostSeriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostSeriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostSeriesGroupByOutputType[P]>
            : GetScalarType<T[P], PostSeriesGroupByOutputType[P]>
        }
      >
    >


  export type PostSeriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    coverImage?: boolean
    color?: boolean
    totalPosts?: boolean
    totalViews?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    posts?: boolean | PostSeries$postsArgs<ExtArgs>
    _count?: boolean | PostSeriesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postSeries"]>

  export type PostSeriesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    coverImage?: boolean
    color?: boolean
    totalPosts?: boolean
    totalViews?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["postSeries"]>

  export type PostSeriesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    coverImage?: boolean
    color?: boolean
    totalPosts?: boolean
    totalViews?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["postSeries"]>

  export type PostSeriesSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    coverImage?: boolean
    color?: boolean
    totalPosts?: boolean
    totalViews?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PostSeriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "description" | "metaTitle" | "metaDescription" | "coverImage" | "color" | "totalPosts" | "totalViews" | "createdAt" | "updatedAt", ExtArgs["result"]["postSeries"]>
  export type PostSeriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | PostSeries$postsArgs<ExtArgs>
    _count?: boolean | PostSeriesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PostSeriesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PostSeriesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PostSeriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PostSeries"
    objects: {
      posts: Prisma.$SeriesPostPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      metaTitle: string | null
      metaDescription: string | null
      coverImage: string | null
      color: string | null
      totalPosts: number
      totalViews: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["postSeries"]>
    composites: {}
  }

  type PostSeriesGetPayload<S extends boolean | null | undefined | PostSeriesDefaultArgs> = $Result.GetResult<Prisma.$PostSeriesPayload, S>

  type PostSeriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostSeriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostSeriesCountAggregateInputType | true
    }

  export interface PostSeriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostSeries'], meta: { name: 'PostSeries' } }
    /**
     * Find zero or one PostSeries that matches the filter.
     * @param {PostSeriesFindUniqueArgs} args - Arguments to find a PostSeries
     * @example
     * // Get one PostSeries
     * const postSeries = await prisma.postSeries.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostSeriesFindUniqueArgs>(args: SelectSubset<T, PostSeriesFindUniqueArgs<ExtArgs>>): Prisma__PostSeriesClient<$Result.GetResult<Prisma.$PostSeriesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PostSeries that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostSeriesFindUniqueOrThrowArgs} args - Arguments to find a PostSeries
     * @example
     * // Get one PostSeries
     * const postSeries = await prisma.postSeries.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostSeriesFindUniqueOrThrowArgs>(args: SelectSubset<T, PostSeriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostSeriesClient<$Result.GetResult<Prisma.$PostSeriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostSeries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostSeriesFindFirstArgs} args - Arguments to find a PostSeries
     * @example
     * // Get one PostSeries
     * const postSeries = await prisma.postSeries.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostSeriesFindFirstArgs>(args?: SelectSubset<T, PostSeriesFindFirstArgs<ExtArgs>>): Prisma__PostSeriesClient<$Result.GetResult<Prisma.$PostSeriesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostSeries that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostSeriesFindFirstOrThrowArgs} args - Arguments to find a PostSeries
     * @example
     * // Get one PostSeries
     * const postSeries = await prisma.postSeries.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostSeriesFindFirstOrThrowArgs>(args?: SelectSubset<T, PostSeriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostSeriesClient<$Result.GetResult<Prisma.$PostSeriesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PostSeries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostSeriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostSeries
     * const postSeries = await prisma.postSeries.findMany()
     * 
     * // Get first 10 PostSeries
     * const postSeries = await prisma.postSeries.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postSeriesWithIdOnly = await prisma.postSeries.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostSeriesFindManyArgs>(args?: SelectSubset<T, PostSeriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostSeriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PostSeries.
     * @param {PostSeriesCreateArgs} args - Arguments to create a PostSeries.
     * @example
     * // Create one PostSeries
     * const PostSeries = await prisma.postSeries.create({
     *   data: {
     *     // ... data to create a PostSeries
     *   }
     * })
     * 
     */
    create<T extends PostSeriesCreateArgs>(args: SelectSubset<T, PostSeriesCreateArgs<ExtArgs>>): Prisma__PostSeriesClient<$Result.GetResult<Prisma.$PostSeriesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PostSeries.
     * @param {PostSeriesCreateManyArgs} args - Arguments to create many PostSeries.
     * @example
     * // Create many PostSeries
     * const postSeries = await prisma.postSeries.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostSeriesCreateManyArgs>(args?: SelectSubset<T, PostSeriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PostSeries and returns the data saved in the database.
     * @param {PostSeriesCreateManyAndReturnArgs} args - Arguments to create many PostSeries.
     * @example
     * // Create many PostSeries
     * const postSeries = await prisma.postSeries.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PostSeries and only return the `id`
     * const postSeriesWithIdOnly = await prisma.postSeries.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostSeriesCreateManyAndReturnArgs>(args?: SelectSubset<T, PostSeriesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostSeriesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PostSeries.
     * @param {PostSeriesDeleteArgs} args - Arguments to delete one PostSeries.
     * @example
     * // Delete one PostSeries
     * const PostSeries = await prisma.postSeries.delete({
     *   where: {
     *     // ... filter to delete one PostSeries
     *   }
     * })
     * 
     */
    delete<T extends PostSeriesDeleteArgs>(args: SelectSubset<T, PostSeriesDeleteArgs<ExtArgs>>): Prisma__PostSeriesClient<$Result.GetResult<Prisma.$PostSeriesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PostSeries.
     * @param {PostSeriesUpdateArgs} args - Arguments to update one PostSeries.
     * @example
     * // Update one PostSeries
     * const postSeries = await prisma.postSeries.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostSeriesUpdateArgs>(args: SelectSubset<T, PostSeriesUpdateArgs<ExtArgs>>): Prisma__PostSeriesClient<$Result.GetResult<Prisma.$PostSeriesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PostSeries.
     * @param {PostSeriesDeleteManyArgs} args - Arguments to filter PostSeries to delete.
     * @example
     * // Delete a few PostSeries
     * const { count } = await prisma.postSeries.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostSeriesDeleteManyArgs>(args?: SelectSubset<T, PostSeriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostSeries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostSeriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostSeries
     * const postSeries = await prisma.postSeries.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostSeriesUpdateManyArgs>(args: SelectSubset<T, PostSeriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostSeries and returns the data updated in the database.
     * @param {PostSeriesUpdateManyAndReturnArgs} args - Arguments to update many PostSeries.
     * @example
     * // Update many PostSeries
     * const postSeries = await prisma.postSeries.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PostSeries and only return the `id`
     * const postSeriesWithIdOnly = await prisma.postSeries.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PostSeriesUpdateManyAndReturnArgs>(args: SelectSubset<T, PostSeriesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostSeriesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PostSeries.
     * @param {PostSeriesUpsertArgs} args - Arguments to update or create a PostSeries.
     * @example
     * // Update or create a PostSeries
     * const postSeries = await prisma.postSeries.upsert({
     *   create: {
     *     // ... data to create a PostSeries
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostSeries we want to update
     *   }
     * })
     */
    upsert<T extends PostSeriesUpsertArgs>(args: SelectSubset<T, PostSeriesUpsertArgs<ExtArgs>>): Prisma__PostSeriesClient<$Result.GetResult<Prisma.$PostSeriesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PostSeries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostSeriesCountArgs} args - Arguments to filter PostSeries to count.
     * @example
     * // Count the number of PostSeries
     * const count = await prisma.postSeries.count({
     *   where: {
     *     // ... the filter for the PostSeries we want to count
     *   }
     * })
    **/
    count<T extends PostSeriesCountArgs>(
      args?: Subset<T, PostSeriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostSeriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostSeries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostSeriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostSeriesAggregateArgs>(args: Subset<T, PostSeriesAggregateArgs>): Prisma.PrismaPromise<GetPostSeriesAggregateType<T>>

    /**
     * Group by PostSeries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostSeriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostSeriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostSeriesGroupByArgs['orderBy'] }
        : { orderBy?: PostSeriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostSeriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostSeriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PostSeries model
   */
  readonly fields: PostSeriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PostSeries.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostSeriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    posts<T extends PostSeries$postsArgs<ExtArgs> = {}>(args?: Subset<T, PostSeries$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeriesPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PostSeries model
   */
  interface PostSeriesFieldRefs {
    readonly id: FieldRef<"PostSeries", 'String'>
    readonly name: FieldRef<"PostSeries", 'String'>
    readonly slug: FieldRef<"PostSeries", 'String'>
    readonly description: FieldRef<"PostSeries", 'String'>
    readonly metaTitle: FieldRef<"PostSeries", 'String'>
    readonly metaDescription: FieldRef<"PostSeries", 'String'>
    readonly coverImage: FieldRef<"PostSeries", 'String'>
    readonly color: FieldRef<"PostSeries", 'String'>
    readonly totalPosts: FieldRef<"PostSeries", 'Int'>
    readonly totalViews: FieldRef<"PostSeries", 'Int'>
    readonly createdAt: FieldRef<"PostSeries", 'DateTime'>
    readonly updatedAt: FieldRef<"PostSeries", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PostSeries findUnique
   */
  export type PostSeriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostSeries
     */
    select?: PostSeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostSeries
     */
    omit?: PostSeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostSeriesInclude<ExtArgs> | null
    /**
     * Filter, which PostSeries to fetch.
     */
    where: PostSeriesWhereUniqueInput
  }

  /**
   * PostSeries findUniqueOrThrow
   */
  export type PostSeriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostSeries
     */
    select?: PostSeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostSeries
     */
    omit?: PostSeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostSeriesInclude<ExtArgs> | null
    /**
     * Filter, which PostSeries to fetch.
     */
    where: PostSeriesWhereUniqueInput
  }

  /**
   * PostSeries findFirst
   */
  export type PostSeriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostSeries
     */
    select?: PostSeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostSeries
     */
    omit?: PostSeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostSeriesInclude<ExtArgs> | null
    /**
     * Filter, which PostSeries to fetch.
     */
    where?: PostSeriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostSeries to fetch.
     */
    orderBy?: PostSeriesOrderByWithRelationInput | PostSeriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostSeries.
     */
    cursor?: PostSeriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostSeries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostSeries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostSeries.
     */
    distinct?: PostSeriesScalarFieldEnum | PostSeriesScalarFieldEnum[]
  }

  /**
   * PostSeries findFirstOrThrow
   */
  export type PostSeriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostSeries
     */
    select?: PostSeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostSeries
     */
    omit?: PostSeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostSeriesInclude<ExtArgs> | null
    /**
     * Filter, which PostSeries to fetch.
     */
    where?: PostSeriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostSeries to fetch.
     */
    orderBy?: PostSeriesOrderByWithRelationInput | PostSeriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostSeries.
     */
    cursor?: PostSeriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostSeries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostSeries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostSeries.
     */
    distinct?: PostSeriesScalarFieldEnum | PostSeriesScalarFieldEnum[]
  }

  /**
   * PostSeries findMany
   */
  export type PostSeriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostSeries
     */
    select?: PostSeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostSeries
     */
    omit?: PostSeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostSeriesInclude<ExtArgs> | null
    /**
     * Filter, which PostSeries to fetch.
     */
    where?: PostSeriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostSeries to fetch.
     */
    orderBy?: PostSeriesOrderByWithRelationInput | PostSeriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostSeries.
     */
    cursor?: PostSeriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostSeries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostSeries.
     */
    skip?: number
    distinct?: PostSeriesScalarFieldEnum | PostSeriesScalarFieldEnum[]
  }

  /**
   * PostSeries create
   */
  export type PostSeriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostSeries
     */
    select?: PostSeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostSeries
     */
    omit?: PostSeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostSeriesInclude<ExtArgs> | null
    /**
     * The data needed to create a PostSeries.
     */
    data: XOR<PostSeriesCreateInput, PostSeriesUncheckedCreateInput>
  }

  /**
   * PostSeries createMany
   */
  export type PostSeriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PostSeries.
     */
    data: PostSeriesCreateManyInput | PostSeriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PostSeries createManyAndReturn
   */
  export type PostSeriesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostSeries
     */
    select?: PostSeriesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostSeries
     */
    omit?: PostSeriesOmit<ExtArgs> | null
    /**
     * The data used to create many PostSeries.
     */
    data: PostSeriesCreateManyInput | PostSeriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PostSeries update
   */
  export type PostSeriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostSeries
     */
    select?: PostSeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostSeries
     */
    omit?: PostSeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostSeriesInclude<ExtArgs> | null
    /**
     * The data needed to update a PostSeries.
     */
    data: XOR<PostSeriesUpdateInput, PostSeriesUncheckedUpdateInput>
    /**
     * Choose, which PostSeries to update.
     */
    where: PostSeriesWhereUniqueInput
  }

  /**
   * PostSeries updateMany
   */
  export type PostSeriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PostSeries.
     */
    data: XOR<PostSeriesUpdateManyMutationInput, PostSeriesUncheckedUpdateManyInput>
    /**
     * Filter which PostSeries to update
     */
    where?: PostSeriesWhereInput
    /**
     * Limit how many PostSeries to update.
     */
    limit?: number
  }

  /**
   * PostSeries updateManyAndReturn
   */
  export type PostSeriesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostSeries
     */
    select?: PostSeriesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostSeries
     */
    omit?: PostSeriesOmit<ExtArgs> | null
    /**
     * The data used to update PostSeries.
     */
    data: XOR<PostSeriesUpdateManyMutationInput, PostSeriesUncheckedUpdateManyInput>
    /**
     * Filter which PostSeries to update
     */
    where?: PostSeriesWhereInput
    /**
     * Limit how many PostSeries to update.
     */
    limit?: number
  }

  /**
   * PostSeries upsert
   */
  export type PostSeriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostSeries
     */
    select?: PostSeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostSeries
     */
    omit?: PostSeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostSeriesInclude<ExtArgs> | null
    /**
     * The filter to search for the PostSeries to update in case it exists.
     */
    where: PostSeriesWhereUniqueInput
    /**
     * In case the PostSeries found by the `where` argument doesn't exist, create a new PostSeries with this data.
     */
    create: XOR<PostSeriesCreateInput, PostSeriesUncheckedCreateInput>
    /**
     * In case the PostSeries was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostSeriesUpdateInput, PostSeriesUncheckedUpdateInput>
  }

  /**
   * PostSeries delete
   */
  export type PostSeriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostSeries
     */
    select?: PostSeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostSeries
     */
    omit?: PostSeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostSeriesInclude<ExtArgs> | null
    /**
     * Filter which PostSeries to delete.
     */
    where: PostSeriesWhereUniqueInput
  }

  /**
   * PostSeries deleteMany
   */
  export type PostSeriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostSeries to delete
     */
    where?: PostSeriesWhereInput
    /**
     * Limit how many PostSeries to delete.
     */
    limit?: number
  }

  /**
   * PostSeries.posts
   */
  export type PostSeries$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeriesPost
     */
    select?: SeriesPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeriesPost
     */
    omit?: SeriesPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesPostInclude<ExtArgs> | null
    where?: SeriesPostWhereInput
    orderBy?: SeriesPostOrderByWithRelationInput | SeriesPostOrderByWithRelationInput[]
    cursor?: SeriesPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SeriesPostScalarFieldEnum | SeriesPostScalarFieldEnum[]
  }

  /**
   * PostSeries without action
   */
  export type PostSeriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostSeries
     */
    select?: PostSeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostSeries
     */
    omit?: PostSeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostSeriesInclude<ExtArgs> | null
  }


  /**
   * Model SeriesPost
   */

  export type AggregateSeriesPost = {
    _count: SeriesPostCountAggregateOutputType | null
    _avg: SeriesPostAvgAggregateOutputType | null
    _sum: SeriesPostSumAggregateOutputType | null
    _min: SeriesPostMinAggregateOutputType | null
    _max: SeriesPostMaxAggregateOutputType | null
  }

  export type SeriesPostAvgAggregateOutputType = {
    order: number | null
  }

  export type SeriesPostSumAggregateOutputType = {
    order: number | null
  }

  export type SeriesPostMinAggregateOutputType = {
    seriesId: string | null
    postId: string | null
    order: number | null
    createdAt: Date | null
  }

  export type SeriesPostMaxAggregateOutputType = {
    seriesId: string | null
    postId: string | null
    order: number | null
    createdAt: Date | null
  }

  export type SeriesPostCountAggregateOutputType = {
    seriesId: number
    postId: number
    order: number
    createdAt: number
    _all: number
  }


  export type SeriesPostAvgAggregateInputType = {
    order?: true
  }

  export type SeriesPostSumAggregateInputType = {
    order?: true
  }

  export type SeriesPostMinAggregateInputType = {
    seriesId?: true
    postId?: true
    order?: true
    createdAt?: true
  }

  export type SeriesPostMaxAggregateInputType = {
    seriesId?: true
    postId?: true
    order?: true
    createdAt?: true
  }

  export type SeriesPostCountAggregateInputType = {
    seriesId?: true
    postId?: true
    order?: true
    createdAt?: true
    _all?: true
  }

  export type SeriesPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SeriesPost to aggregate.
     */
    where?: SeriesPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeriesPosts to fetch.
     */
    orderBy?: SeriesPostOrderByWithRelationInput | SeriesPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SeriesPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeriesPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeriesPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SeriesPosts
    **/
    _count?: true | SeriesPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SeriesPostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SeriesPostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeriesPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeriesPostMaxAggregateInputType
  }

  export type GetSeriesPostAggregateType<T extends SeriesPostAggregateArgs> = {
        [P in keyof T & keyof AggregateSeriesPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeriesPost[P]>
      : GetScalarType<T[P], AggregateSeriesPost[P]>
  }




  export type SeriesPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeriesPostWhereInput
    orderBy?: SeriesPostOrderByWithAggregationInput | SeriesPostOrderByWithAggregationInput[]
    by: SeriesPostScalarFieldEnum[] | SeriesPostScalarFieldEnum
    having?: SeriesPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeriesPostCountAggregateInputType | true
    _avg?: SeriesPostAvgAggregateInputType
    _sum?: SeriesPostSumAggregateInputType
    _min?: SeriesPostMinAggregateInputType
    _max?: SeriesPostMaxAggregateInputType
  }

  export type SeriesPostGroupByOutputType = {
    seriesId: string
    postId: string
    order: number
    createdAt: Date
    _count: SeriesPostCountAggregateOutputType | null
    _avg: SeriesPostAvgAggregateOutputType | null
    _sum: SeriesPostSumAggregateOutputType | null
    _min: SeriesPostMinAggregateOutputType | null
    _max: SeriesPostMaxAggregateOutputType | null
  }

  type GetSeriesPostGroupByPayload<T extends SeriesPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeriesPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeriesPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeriesPostGroupByOutputType[P]>
            : GetScalarType<T[P], SeriesPostGroupByOutputType[P]>
        }
      >
    >


  export type SeriesPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    seriesId?: boolean
    postId?: boolean
    order?: boolean
    createdAt?: boolean
    series?: boolean | PostSeriesDefaultArgs<ExtArgs>
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seriesPost"]>

  export type SeriesPostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    seriesId?: boolean
    postId?: boolean
    order?: boolean
    createdAt?: boolean
    series?: boolean | PostSeriesDefaultArgs<ExtArgs>
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seriesPost"]>

  export type SeriesPostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    seriesId?: boolean
    postId?: boolean
    order?: boolean
    createdAt?: boolean
    series?: boolean | PostSeriesDefaultArgs<ExtArgs>
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seriesPost"]>

  export type SeriesPostSelectScalar = {
    seriesId?: boolean
    postId?: boolean
    order?: boolean
    createdAt?: boolean
  }

  export type SeriesPostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"seriesId" | "postId" | "order" | "createdAt", ExtArgs["result"]["seriesPost"]>
  export type SeriesPostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    series?: boolean | PostSeriesDefaultArgs<ExtArgs>
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
  }
  export type SeriesPostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    series?: boolean | PostSeriesDefaultArgs<ExtArgs>
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
  }
  export type SeriesPostIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    series?: boolean | PostSeriesDefaultArgs<ExtArgs>
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
  }

  export type $SeriesPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SeriesPost"
    objects: {
      series: Prisma.$PostSeriesPayload<ExtArgs>
      post: Prisma.$BlogPostPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      seriesId: string
      postId: string
      order: number
      createdAt: Date
    }, ExtArgs["result"]["seriesPost"]>
    composites: {}
  }

  type SeriesPostGetPayload<S extends boolean | null | undefined | SeriesPostDefaultArgs> = $Result.GetResult<Prisma.$SeriesPostPayload, S>

  type SeriesPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SeriesPostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SeriesPostCountAggregateInputType | true
    }

  export interface SeriesPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SeriesPost'], meta: { name: 'SeriesPost' } }
    /**
     * Find zero or one SeriesPost that matches the filter.
     * @param {SeriesPostFindUniqueArgs} args - Arguments to find a SeriesPost
     * @example
     * // Get one SeriesPost
     * const seriesPost = await prisma.seriesPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SeriesPostFindUniqueArgs>(args: SelectSubset<T, SeriesPostFindUniqueArgs<ExtArgs>>): Prisma__SeriesPostClient<$Result.GetResult<Prisma.$SeriesPostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SeriesPost that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SeriesPostFindUniqueOrThrowArgs} args - Arguments to find a SeriesPost
     * @example
     * // Get one SeriesPost
     * const seriesPost = await prisma.seriesPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SeriesPostFindUniqueOrThrowArgs>(args: SelectSubset<T, SeriesPostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SeriesPostClient<$Result.GetResult<Prisma.$SeriesPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SeriesPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesPostFindFirstArgs} args - Arguments to find a SeriesPost
     * @example
     * // Get one SeriesPost
     * const seriesPost = await prisma.seriesPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SeriesPostFindFirstArgs>(args?: SelectSubset<T, SeriesPostFindFirstArgs<ExtArgs>>): Prisma__SeriesPostClient<$Result.GetResult<Prisma.$SeriesPostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SeriesPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesPostFindFirstOrThrowArgs} args - Arguments to find a SeriesPost
     * @example
     * // Get one SeriesPost
     * const seriesPost = await prisma.seriesPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SeriesPostFindFirstOrThrowArgs>(args?: SelectSubset<T, SeriesPostFindFirstOrThrowArgs<ExtArgs>>): Prisma__SeriesPostClient<$Result.GetResult<Prisma.$SeriesPostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SeriesPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesPostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SeriesPosts
     * const seriesPosts = await prisma.seriesPost.findMany()
     * 
     * // Get first 10 SeriesPosts
     * const seriesPosts = await prisma.seriesPost.findMany({ take: 10 })
     * 
     * // Only select the `seriesId`
     * const seriesPostWithSeriesIdOnly = await prisma.seriesPost.findMany({ select: { seriesId: true } })
     * 
     */
    findMany<T extends SeriesPostFindManyArgs>(args?: SelectSubset<T, SeriesPostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeriesPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SeriesPost.
     * @param {SeriesPostCreateArgs} args - Arguments to create a SeriesPost.
     * @example
     * // Create one SeriesPost
     * const SeriesPost = await prisma.seriesPost.create({
     *   data: {
     *     // ... data to create a SeriesPost
     *   }
     * })
     * 
     */
    create<T extends SeriesPostCreateArgs>(args: SelectSubset<T, SeriesPostCreateArgs<ExtArgs>>): Prisma__SeriesPostClient<$Result.GetResult<Prisma.$SeriesPostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SeriesPosts.
     * @param {SeriesPostCreateManyArgs} args - Arguments to create many SeriesPosts.
     * @example
     * // Create many SeriesPosts
     * const seriesPost = await prisma.seriesPost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SeriesPostCreateManyArgs>(args?: SelectSubset<T, SeriesPostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SeriesPosts and returns the data saved in the database.
     * @param {SeriesPostCreateManyAndReturnArgs} args - Arguments to create many SeriesPosts.
     * @example
     * // Create many SeriesPosts
     * const seriesPost = await prisma.seriesPost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SeriesPosts and only return the `seriesId`
     * const seriesPostWithSeriesIdOnly = await prisma.seriesPost.createManyAndReturn({
     *   select: { seriesId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SeriesPostCreateManyAndReturnArgs>(args?: SelectSubset<T, SeriesPostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeriesPostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SeriesPost.
     * @param {SeriesPostDeleteArgs} args - Arguments to delete one SeriesPost.
     * @example
     * // Delete one SeriesPost
     * const SeriesPost = await prisma.seriesPost.delete({
     *   where: {
     *     // ... filter to delete one SeriesPost
     *   }
     * })
     * 
     */
    delete<T extends SeriesPostDeleteArgs>(args: SelectSubset<T, SeriesPostDeleteArgs<ExtArgs>>): Prisma__SeriesPostClient<$Result.GetResult<Prisma.$SeriesPostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SeriesPost.
     * @param {SeriesPostUpdateArgs} args - Arguments to update one SeriesPost.
     * @example
     * // Update one SeriesPost
     * const seriesPost = await prisma.seriesPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SeriesPostUpdateArgs>(args: SelectSubset<T, SeriesPostUpdateArgs<ExtArgs>>): Prisma__SeriesPostClient<$Result.GetResult<Prisma.$SeriesPostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SeriesPosts.
     * @param {SeriesPostDeleteManyArgs} args - Arguments to filter SeriesPosts to delete.
     * @example
     * // Delete a few SeriesPosts
     * const { count } = await prisma.seriesPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SeriesPostDeleteManyArgs>(args?: SelectSubset<T, SeriesPostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SeriesPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SeriesPosts
     * const seriesPost = await prisma.seriesPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SeriesPostUpdateManyArgs>(args: SelectSubset<T, SeriesPostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SeriesPosts and returns the data updated in the database.
     * @param {SeriesPostUpdateManyAndReturnArgs} args - Arguments to update many SeriesPosts.
     * @example
     * // Update many SeriesPosts
     * const seriesPost = await prisma.seriesPost.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SeriesPosts and only return the `seriesId`
     * const seriesPostWithSeriesIdOnly = await prisma.seriesPost.updateManyAndReturn({
     *   select: { seriesId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SeriesPostUpdateManyAndReturnArgs>(args: SelectSubset<T, SeriesPostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeriesPostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SeriesPost.
     * @param {SeriesPostUpsertArgs} args - Arguments to update or create a SeriesPost.
     * @example
     * // Update or create a SeriesPost
     * const seriesPost = await prisma.seriesPost.upsert({
     *   create: {
     *     // ... data to create a SeriesPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SeriesPost we want to update
     *   }
     * })
     */
    upsert<T extends SeriesPostUpsertArgs>(args: SelectSubset<T, SeriesPostUpsertArgs<ExtArgs>>): Prisma__SeriesPostClient<$Result.GetResult<Prisma.$SeriesPostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SeriesPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesPostCountArgs} args - Arguments to filter SeriesPosts to count.
     * @example
     * // Count the number of SeriesPosts
     * const count = await prisma.seriesPost.count({
     *   where: {
     *     // ... the filter for the SeriesPosts we want to count
     *   }
     * })
    **/
    count<T extends SeriesPostCountArgs>(
      args?: Subset<T, SeriesPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeriesPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SeriesPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeriesPostAggregateArgs>(args: Subset<T, SeriesPostAggregateArgs>): Prisma.PrismaPromise<GetSeriesPostAggregateType<T>>

    /**
     * Group by SeriesPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeriesPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeriesPostGroupByArgs['orderBy'] }
        : { orderBy?: SeriesPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeriesPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeriesPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SeriesPost model
   */
  readonly fields: SeriesPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SeriesPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SeriesPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    series<T extends PostSeriesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostSeriesDefaultArgs<ExtArgs>>): Prisma__PostSeriesClient<$Result.GetResult<Prisma.$PostSeriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    post<T extends BlogPostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BlogPostDefaultArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SeriesPost model
   */
  interface SeriesPostFieldRefs {
    readonly seriesId: FieldRef<"SeriesPost", 'String'>
    readonly postId: FieldRef<"SeriesPost", 'String'>
    readonly order: FieldRef<"SeriesPost", 'Int'>
    readonly createdAt: FieldRef<"SeriesPost", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SeriesPost findUnique
   */
  export type SeriesPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeriesPost
     */
    select?: SeriesPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeriesPost
     */
    omit?: SeriesPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesPostInclude<ExtArgs> | null
    /**
     * Filter, which SeriesPost to fetch.
     */
    where: SeriesPostWhereUniqueInput
  }

  /**
   * SeriesPost findUniqueOrThrow
   */
  export type SeriesPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeriesPost
     */
    select?: SeriesPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeriesPost
     */
    omit?: SeriesPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesPostInclude<ExtArgs> | null
    /**
     * Filter, which SeriesPost to fetch.
     */
    where: SeriesPostWhereUniqueInput
  }

  /**
   * SeriesPost findFirst
   */
  export type SeriesPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeriesPost
     */
    select?: SeriesPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeriesPost
     */
    omit?: SeriesPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesPostInclude<ExtArgs> | null
    /**
     * Filter, which SeriesPost to fetch.
     */
    where?: SeriesPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeriesPosts to fetch.
     */
    orderBy?: SeriesPostOrderByWithRelationInput | SeriesPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeriesPosts.
     */
    cursor?: SeriesPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeriesPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeriesPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeriesPosts.
     */
    distinct?: SeriesPostScalarFieldEnum | SeriesPostScalarFieldEnum[]
  }

  /**
   * SeriesPost findFirstOrThrow
   */
  export type SeriesPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeriesPost
     */
    select?: SeriesPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeriesPost
     */
    omit?: SeriesPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesPostInclude<ExtArgs> | null
    /**
     * Filter, which SeriesPost to fetch.
     */
    where?: SeriesPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeriesPosts to fetch.
     */
    orderBy?: SeriesPostOrderByWithRelationInput | SeriesPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeriesPosts.
     */
    cursor?: SeriesPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeriesPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeriesPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeriesPosts.
     */
    distinct?: SeriesPostScalarFieldEnum | SeriesPostScalarFieldEnum[]
  }

  /**
   * SeriesPost findMany
   */
  export type SeriesPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeriesPost
     */
    select?: SeriesPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeriesPost
     */
    omit?: SeriesPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesPostInclude<ExtArgs> | null
    /**
     * Filter, which SeriesPosts to fetch.
     */
    where?: SeriesPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeriesPosts to fetch.
     */
    orderBy?: SeriesPostOrderByWithRelationInput | SeriesPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SeriesPosts.
     */
    cursor?: SeriesPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeriesPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeriesPosts.
     */
    skip?: number
    distinct?: SeriesPostScalarFieldEnum | SeriesPostScalarFieldEnum[]
  }

  /**
   * SeriesPost create
   */
  export type SeriesPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeriesPost
     */
    select?: SeriesPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeriesPost
     */
    omit?: SeriesPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesPostInclude<ExtArgs> | null
    /**
     * The data needed to create a SeriesPost.
     */
    data: XOR<SeriesPostCreateInput, SeriesPostUncheckedCreateInput>
  }

  /**
   * SeriesPost createMany
   */
  export type SeriesPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SeriesPosts.
     */
    data: SeriesPostCreateManyInput | SeriesPostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SeriesPost createManyAndReturn
   */
  export type SeriesPostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeriesPost
     */
    select?: SeriesPostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SeriesPost
     */
    omit?: SeriesPostOmit<ExtArgs> | null
    /**
     * The data used to create many SeriesPosts.
     */
    data: SeriesPostCreateManyInput | SeriesPostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesPostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SeriesPost update
   */
  export type SeriesPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeriesPost
     */
    select?: SeriesPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeriesPost
     */
    omit?: SeriesPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesPostInclude<ExtArgs> | null
    /**
     * The data needed to update a SeriesPost.
     */
    data: XOR<SeriesPostUpdateInput, SeriesPostUncheckedUpdateInput>
    /**
     * Choose, which SeriesPost to update.
     */
    where: SeriesPostWhereUniqueInput
  }

  /**
   * SeriesPost updateMany
   */
  export type SeriesPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SeriesPosts.
     */
    data: XOR<SeriesPostUpdateManyMutationInput, SeriesPostUncheckedUpdateManyInput>
    /**
     * Filter which SeriesPosts to update
     */
    where?: SeriesPostWhereInput
    /**
     * Limit how many SeriesPosts to update.
     */
    limit?: number
  }

  /**
   * SeriesPost updateManyAndReturn
   */
  export type SeriesPostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeriesPost
     */
    select?: SeriesPostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SeriesPost
     */
    omit?: SeriesPostOmit<ExtArgs> | null
    /**
     * The data used to update SeriesPosts.
     */
    data: XOR<SeriesPostUpdateManyMutationInput, SeriesPostUncheckedUpdateManyInput>
    /**
     * Filter which SeriesPosts to update
     */
    where?: SeriesPostWhereInput
    /**
     * Limit how many SeriesPosts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesPostIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SeriesPost upsert
   */
  export type SeriesPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeriesPost
     */
    select?: SeriesPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeriesPost
     */
    omit?: SeriesPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesPostInclude<ExtArgs> | null
    /**
     * The filter to search for the SeriesPost to update in case it exists.
     */
    where: SeriesPostWhereUniqueInput
    /**
     * In case the SeriesPost found by the `where` argument doesn't exist, create a new SeriesPost with this data.
     */
    create: XOR<SeriesPostCreateInput, SeriesPostUncheckedCreateInput>
    /**
     * In case the SeriesPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeriesPostUpdateInput, SeriesPostUncheckedUpdateInput>
  }

  /**
   * SeriesPost delete
   */
  export type SeriesPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeriesPost
     */
    select?: SeriesPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeriesPost
     */
    omit?: SeriesPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesPostInclude<ExtArgs> | null
    /**
     * Filter which SeriesPost to delete.
     */
    where: SeriesPostWhereUniqueInput
  }

  /**
   * SeriesPost deleteMany
   */
  export type SeriesPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SeriesPosts to delete
     */
    where?: SeriesPostWhereInput
    /**
     * Limit how many SeriesPosts to delete.
     */
    limit?: number
  }

  /**
   * SeriesPost without action
   */
  export type SeriesPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeriesPost
     */
    select?: SeriesPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeriesPost
     */
    omit?: SeriesPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesPostInclude<ExtArgs> | null
  }


  /**
   * Model PostView
   */

  export type AggregatePostView = {
    _count: PostViewCountAggregateOutputType | null
    _avg: PostViewAvgAggregateOutputType | null
    _sum: PostViewSumAggregateOutputType | null
    _min: PostViewMinAggregateOutputType | null
    _max: PostViewMaxAggregateOutputType | null
  }

  export type PostViewAvgAggregateOutputType = {
    readingTime: number | null
    scrollDepth: number | null
  }

  export type PostViewSumAggregateOutputType = {
    readingTime: number | null
    scrollDepth: number | null
  }

  export type PostViewMinAggregateOutputType = {
    id: string | null
    postId: string | null
    visitorId: string | null
    sessionId: string | null
    ipAddress: string | null
    userAgent: string | null
    referer: string | null
    country: string | null
    region: string | null
    city: string | null
    readingTime: number | null
    scrollDepth: number | null
    viewedAt: Date | null
  }

  export type PostViewMaxAggregateOutputType = {
    id: string | null
    postId: string | null
    visitorId: string | null
    sessionId: string | null
    ipAddress: string | null
    userAgent: string | null
    referer: string | null
    country: string | null
    region: string | null
    city: string | null
    readingTime: number | null
    scrollDepth: number | null
    viewedAt: Date | null
  }

  export type PostViewCountAggregateOutputType = {
    id: number
    postId: number
    visitorId: number
    sessionId: number
    ipAddress: number
    userAgent: number
    referer: number
    country: number
    region: number
    city: number
    readingTime: number
    scrollDepth: number
    viewedAt: number
    _all: number
  }


  export type PostViewAvgAggregateInputType = {
    readingTime?: true
    scrollDepth?: true
  }

  export type PostViewSumAggregateInputType = {
    readingTime?: true
    scrollDepth?: true
  }

  export type PostViewMinAggregateInputType = {
    id?: true
    postId?: true
    visitorId?: true
    sessionId?: true
    ipAddress?: true
    userAgent?: true
    referer?: true
    country?: true
    region?: true
    city?: true
    readingTime?: true
    scrollDepth?: true
    viewedAt?: true
  }

  export type PostViewMaxAggregateInputType = {
    id?: true
    postId?: true
    visitorId?: true
    sessionId?: true
    ipAddress?: true
    userAgent?: true
    referer?: true
    country?: true
    region?: true
    city?: true
    readingTime?: true
    scrollDepth?: true
    viewedAt?: true
  }

  export type PostViewCountAggregateInputType = {
    id?: true
    postId?: true
    visitorId?: true
    sessionId?: true
    ipAddress?: true
    userAgent?: true
    referer?: true
    country?: true
    region?: true
    city?: true
    readingTime?: true
    scrollDepth?: true
    viewedAt?: true
    _all?: true
  }

  export type PostViewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostView to aggregate.
     */
    where?: PostViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostViews to fetch.
     */
    orderBy?: PostViewOrderByWithRelationInput | PostViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostViews
    **/
    _count?: true | PostViewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostViewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostViewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostViewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostViewMaxAggregateInputType
  }

  export type GetPostViewAggregateType<T extends PostViewAggregateArgs> = {
        [P in keyof T & keyof AggregatePostView]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostView[P]>
      : GetScalarType<T[P], AggregatePostView[P]>
  }




  export type PostViewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostViewWhereInput
    orderBy?: PostViewOrderByWithAggregationInput | PostViewOrderByWithAggregationInput[]
    by: PostViewScalarFieldEnum[] | PostViewScalarFieldEnum
    having?: PostViewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostViewCountAggregateInputType | true
    _avg?: PostViewAvgAggregateInputType
    _sum?: PostViewSumAggregateInputType
    _min?: PostViewMinAggregateInputType
    _max?: PostViewMaxAggregateInputType
  }

  export type PostViewGroupByOutputType = {
    id: string
    postId: string
    visitorId: string | null
    sessionId: string | null
    ipAddress: string | null
    userAgent: string | null
    referer: string | null
    country: string | null
    region: string | null
    city: string | null
    readingTime: number | null
    scrollDepth: number | null
    viewedAt: Date
    _count: PostViewCountAggregateOutputType | null
    _avg: PostViewAvgAggregateOutputType | null
    _sum: PostViewSumAggregateOutputType | null
    _min: PostViewMinAggregateOutputType | null
    _max: PostViewMaxAggregateOutputType | null
  }

  type GetPostViewGroupByPayload<T extends PostViewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostViewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostViewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostViewGroupByOutputType[P]>
            : GetScalarType<T[P], PostViewGroupByOutputType[P]>
        }
      >
    >


  export type PostViewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    visitorId?: boolean
    sessionId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    referer?: boolean
    country?: boolean
    region?: boolean
    city?: boolean
    readingTime?: boolean
    scrollDepth?: boolean
    viewedAt?: boolean
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postView"]>

  export type PostViewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    visitorId?: boolean
    sessionId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    referer?: boolean
    country?: boolean
    region?: boolean
    city?: boolean
    readingTime?: boolean
    scrollDepth?: boolean
    viewedAt?: boolean
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postView"]>

  export type PostViewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    visitorId?: boolean
    sessionId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    referer?: boolean
    country?: boolean
    region?: boolean
    city?: boolean
    readingTime?: boolean
    scrollDepth?: boolean
    viewedAt?: boolean
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postView"]>

  export type PostViewSelectScalar = {
    id?: boolean
    postId?: boolean
    visitorId?: boolean
    sessionId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    referer?: boolean
    country?: boolean
    region?: boolean
    city?: boolean
    readingTime?: boolean
    scrollDepth?: boolean
    viewedAt?: boolean
  }

  export type PostViewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "postId" | "visitorId" | "sessionId" | "ipAddress" | "userAgent" | "referer" | "country" | "region" | "city" | "readingTime" | "scrollDepth" | "viewedAt", ExtArgs["result"]["postView"]>
  export type PostViewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
  }
  export type PostViewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
  }
  export type PostViewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
  }

  export type $PostViewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PostView"
    objects: {
      post: Prisma.$BlogPostPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postId: string
      visitorId: string | null
      sessionId: string | null
      ipAddress: string | null
      userAgent: string | null
      referer: string | null
      country: string | null
      region: string | null
      city: string | null
      readingTime: number | null
      scrollDepth: number | null
      viewedAt: Date
    }, ExtArgs["result"]["postView"]>
    composites: {}
  }

  type PostViewGetPayload<S extends boolean | null | undefined | PostViewDefaultArgs> = $Result.GetResult<Prisma.$PostViewPayload, S>

  type PostViewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostViewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostViewCountAggregateInputType | true
    }

  export interface PostViewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostView'], meta: { name: 'PostView' } }
    /**
     * Find zero or one PostView that matches the filter.
     * @param {PostViewFindUniqueArgs} args - Arguments to find a PostView
     * @example
     * // Get one PostView
     * const postView = await prisma.postView.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostViewFindUniqueArgs>(args: SelectSubset<T, PostViewFindUniqueArgs<ExtArgs>>): Prisma__PostViewClient<$Result.GetResult<Prisma.$PostViewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PostView that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostViewFindUniqueOrThrowArgs} args - Arguments to find a PostView
     * @example
     * // Get one PostView
     * const postView = await prisma.postView.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostViewFindUniqueOrThrowArgs>(args: SelectSubset<T, PostViewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostViewClient<$Result.GetResult<Prisma.$PostViewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostView that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostViewFindFirstArgs} args - Arguments to find a PostView
     * @example
     * // Get one PostView
     * const postView = await prisma.postView.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostViewFindFirstArgs>(args?: SelectSubset<T, PostViewFindFirstArgs<ExtArgs>>): Prisma__PostViewClient<$Result.GetResult<Prisma.$PostViewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostView that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostViewFindFirstOrThrowArgs} args - Arguments to find a PostView
     * @example
     * // Get one PostView
     * const postView = await prisma.postView.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostViewFindFirstOrThrowArgs>(args?: SelectSubset<T, PostViewFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostViewClient<$Result.GetResult<Prisma.$PostViewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PostViews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostViewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostViews
     * const postViews = await prisma.postView.findMany()
     * 
     * // Get first 10 PostViews
     * const postViews = await prisma.postView.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postViewWithIdOnly = await prisma.postView.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostViewFindManyArgs>(args?: SelectSubset<T, PostViewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostViewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PostView.
     * @param {PostViewCreateArgs} args - Arguments to create a PostView.
     * @example
     * // Create one PostView
     * const PostView = await prisma.postView.create({
     *   data: {
     *     // ... data to create a PostView
     *   }
     * })
     * 
     */
    create<T extends PostViewCreateArgs>(args: SelectSubset<T, PostViewCreateArgs<ExtArgs>>): Prisma__PostViewClient<$Result.GetResult<Prisma.$PostViewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PostViews.
     * @param {PostViewCreateManyArgs} args - Arguments to create many PostViews.
     * @example
     * // Create many PostViews
     * const postView = await prisma.postView.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostViewCreateManyArgs>(args?: SelectSubset<T, PostViewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PostViews and returns the data saved in the database.
     * @param {PostViewCreateManyAndReturnArgs} args - Arguments to create many PostViews.
     * @example
     * // Create many PostViews
     * const postView = await prisma.postView.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PostViews and only return the `id`
     * const postViewWithIdOnly = await prisma.postView.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostViewCreateManyAndReturnArgs>(args?: SelectSubset<T, PostViewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostViewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PostView.
     * @param {PostViewDeleteArgs} args - Arguments to delete one PostView.
     * @example
     * // Delete one PostView
     * const PostView = await prisma.postView.delete({
     *   where: {
     *     // ... filter to delete one PostView
     *   }
     * })
     * 
     */
    delete<T extends PostViewDeleteArgs>(args: SelectSubset<T, PostViewDeleteArgs<ExtArgs>>): Prisma__PostViewClient<$Result.GetResult<Prisma.$PostViewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PostView.
     * @param {PostViewUpdateArgs} args - Arguments to update one PostView.
     * @example
     * // Update one PostView
     * const postView = await prisma.postView.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostViewUpdateArgs>(args: SelectSubset<T, PostViewUpdateArgs<ExtArgs>>): Prisma__PostViewClient<$Result.GetResult<Prisma.$PostViewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PostViews.
     * @param {PostViewDeleteManyArgs} args - Arguments to filter PostViews to delete.
     * @example
     * // Delete a few PostViews
     * const { count } = await prisma.postView.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostViewDeleteManyArgs>(args?: SelectSubset<T, PostViewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostViewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostViews
     * const postView = await prisma.postView.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostViewUpdateManyArgs>(args: SelectSubset<T, PostViewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostViews and returns the data updated in the database.
     * @param {PostViewUpdateManyAndReturnArgs} args - Arguments to update many PostViews.
     * @example
     * // Update many PostViews
     * const postView = await prisma.postView.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PostViews and only return the `id`
     * const postViewWithIdOnly = await prisma.postView.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PostViewUpdateManyAndReturnArgs>(args: SelectSubset<T, PostViewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostViewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PostView.
     * @param {PostViewUpsertArgs} args - Arguments to update or create a PostView.
     * @example
     * // Update or create a PostView
     * const postView = await prisma.postView.upsert({
     *   create: {
     *     // ... data to create a PostView
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostView we want to update
     *   }
     * })
     */
    upsert<T extends PostViewUpsertArgs>(args: SelectSubset<T, PostViewUpsertArgs<ExtArgs>>): Prisma__PostViewClient<$Result.GetResult<Prisma.$PostViewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PostViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostViewCountArgs} args - Arguments to filter PostViews to count.
     * @example
     * // Count the number of PostViews
     * const count = await prisma.postView.count({
     *   where: {
     *     // ... the filter for the PostViews we want to count
     *   }
     * })
    **/
    count<T extends PostViewCountArgs>(
      args?: Subset<T, PostViewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostViewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostView.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostViewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostViewAggregateArgs>(args: Subset<T, PostViewAggregateArgs>): Prisma.PrismaPromise<GetPostViewAggregateType<T>>

    /**
     * Group by PostView.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostViewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostViewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostViewGroupByArgs['orderBy'] }
        : { orderBy?: PostViewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostViewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostViewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PostView model
   */
  readonly fields: PostViewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PostView.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostViewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends BlogPostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BlogPostDefaultArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PostView model
   */
  interface PostViewFieldRefs {
    readonly id: FieldRef<"PostView", 'String'>
    readonly postId: FieldRef<"PostView", 'String'>
    readonly visitorId: FieldRef<"PostView", 'String'>
    readonly sessionId: FieldRef<"PostView", 'String'>
    readonly ipAddress: FieldRef<"PostView", 'String'>
    readonly userAgent: FieldRef<"PostView", 'String'>
    readonly referer: FieldRef<"PostView", 'String'>
    readonly country: FieldRef<"PostView", 'String'>
    readonly region: FieldRef<"PostView", 'String'>
    readonly city: FieldRef<"PostView", 'String'>
    readonly readingTime: FieldRef<"PostView", 'Int'>
    readonly scrollDepth: FieldRef<"PostView", 'Float'>
    readonly viewedAt: FieldRef<"PostView", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PostView findUnique
   */
  export type PostViewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostView
     */
    select?: PostViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostView
     */
    omit?: PostViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostViewInclude<ExtArgs> | null
    /**
     * Filter, which PostView to fetch.
     */
    where: PostViewWhereUniqueInput
  }

  /**
   * PostView findUniqueOrThrow
   */
  export type PostViewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostView
     */
    select?: PostViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostView
     */
    omit?: PostViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostViewInclude<ExtArgs> | null
    /**
     * Filter, which PostView to fetch.
     */
    where: PostViewWhereUniqueInput
  }

  /**
   * PostView findFirst
   */
  export type PostViewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostView
     */
    select?: PostViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostView
     */
    omit?: PostViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostViewInclude<ExtArgs> | null
    /**
     * Filter, which PostView to fetch.
     */
    where?: PostViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostViews to fetch.
     */
    orderBy?: PostViewOrderByWithRelationInput | PostViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostViews.
     */
    cursor?: PostViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostViews.
     */
    distinct?: PostViewScalarFieldEnum | PostViewScalarFieldEnum[]
  }

  /**
   * PostView findFirstOrThrow
   */
  export type PostViewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostView
     */
    select?: PostViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostView
     */
    omit?: PostViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostViewInclude<ExtArgs> | null
    /**
     * Filter, which PostView to fetch.
     */
    where?: PostViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostViews to fetch.
     */
    orderBy?: PostViewOrderByWithRelationInput | PostViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostViews.
     */
    cursor?: PostViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostViews.
     */
    distinct?: PostViewScalarFieldEnum | PostViewScalarFieldEnum[]
  }

  /**
   * PostView findMany
   */
  export type PostViewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostView
     */
    select?: PostViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostView
     */
    omit?: PostViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostViewInclude<ExtArgs> | null
    /**
     * Filter, which PostViews to fetch.
     */
    where?: PostViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostViews to fetch.
     */
    orderBy?: PostViewOrderByWithRelationInput | PostViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostViews.
     */
    cursor?: PostViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostViews.
     */
    skip?: number
    distinct?: PostViewScalarFieldEnum | PostViewScalarFieldEnum[]
  }

  /**
   * PostView create
   */
  export type PostViewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostView
     */
    select?: PostViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostView
     */
    omit?: PostViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostViewInclude<ExtArgs> | null
    /**
     * The data needed to create a PostView.
     */
    data: XOR<PostViewCreateInput, PostViewUncheckedCreateInput>
  }

  /**
   * PostView createMany
   */
  export type PostViewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PostViews.
     */
    data: PostViewCreateManyInput | PostViewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PostView createManyAndReturn
   */
  export type PostViewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostView
     */
    select?: PostViewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostView
     */
    omit?: PostViewOmit<ExtArgs> | null
    /**
     * The data used to create many PostViews.
     */
    data: PostViewCreateManyInput | PostViewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostViewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostView update
   */
  export type PostViewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostView
     */
    select?: PostViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostView
     */
    omit?: PostViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostViewInclude<ExtArgs> | null
    /**
     * The data needed to update a PostView.
     */
    data: XOR<PostViewUpdateInput, PostViewUncheckedUpdateInput>
    /**
     * Choose, which PostView to update.
     */
    where: PostViewWhereUniqueInput
  }

  /**
   * PostView updateMany
   */
  export type PostViewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PostViews.
     */
    data: XOR<PostViewUpdateManyMutationInput, PostViewUncheckedUpdateManyInput>
    /**
     * Filter which PostViews to update
     */
    where?: PostViewWhereInput
    /**
     * Limit how many PostViews to update.
     */
    limit?: number
  }

  /**
   * PostView updateManyAndReturn
   */
  export type PostViewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostView
     */
    select?: PostViewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostView
     */
    omit?: PostViewOmit<ExtArgs> | null
    /**
     * The data used to update PostViews.
     */
    data: XOR<PostViewUpdateManyMutationInput, PostViewUncheckedUpdateManyInput>
    /**
     * Filter which PostViews to update
     */
    where?: PostViewWhereInput
    /**
     * Limit how many PostViews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostViewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostView upsert
   */
  export type PostViewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostView
     */
    select?: PostViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostView
     */
    omit?: PostViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostViewInclude<ExtArgs> | null
    /**
     * The filter to search for the PostView to update in case it exists.
     */
    where: PostViewWhereUniqueInput
    /**
     * In case the PostView found by the `where` argument doesn't exist, create a new PostView with this data.
     */
    create: XOR<PostViewCreateInput, PostViewUncheckedCreateInput>
    /**
     * In case the PostView was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostViewUpdateInput, PostViewUncheckedUpdateInput>
  }

  /**
   * PostView delete
   */
  export type PostViewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostView
     */
    select?: PostViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostView
     */
    omit?: PostViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostViewInclude<ExtArgs> | null
    /**
     * Filter which PostView to delete.
     */
    where: PostViewWhereUniqueInput
  }

  /**
   * PostView deleteMany
   */
  export type PostViewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostViews to delete
     */
    where?: PostViewWhereInput
    /**
     * Limit how many PostViews to delete.
     */
    limit?: number
  }

  /**
   * PostView without action
   */
  export type PostViewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostView
     */
    select?: PostViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostView
     */
    omit?: PostViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostViewInclude<ExtArgs> | null
  }


  /**
   * Model PostInteraction
   */

  export type AggregatePostInteraction = {
    _count: PostInteractionCountAggregateOutputType | null
    _min: PostInteractionMinAggregateOutputType | null
    _max: PostInteractionMaxAggregateOutputType | null
  }

  export type PostInteractionMinAggregateOutputType = {
    id: string | null
    postId: string | null
    type: $Enums.InteractionType | null
    visitorId: string | null
    sessionId: string | null
    value: string | null
    createdAt: Date | null
  }

  export type PostInteractionMaxAggregateOutputType = {
    id: string | null
    postId: string | null
    type: $Enums.InteractionType | null
    visitorId: string | null
    sessionId: string | null
    value: string | null
    createdAt: Date | null
  }

  export type PostInteractionCountAggregateOutputType = {
    id: number
    postId: number
    type: number
    visitorId: number
    sessionId: number
    value: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type PostInteractionMinAggregateInputType = {
    id?: true
    postId?: true
    type?: true
    visitorId?: true
    sessionId?: true
    value?: true
    createdAt?: true
  }

  export type PostInteractionMaxAggregateInputType = {
    id?: true
    postId?: true
    type?: true
    visitorId?: true
    sessionId?: true
    value?: true
    createdAt?: true
  }

  export type PostInteractionCountAggregateInputType = {
    id?: true
    postId?: true
    type?: true
    visitorId?: true
    sessionId?: true
    value?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type PostInteractionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostInteraction to aggregate.
     */
    where?: PostInteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostInteractions to fetch.
     */
    orderBy?: PostInteractionOrderByWithRelationInput | PostInteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostInteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostInteractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostInteractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostInteractions
    **/
    _count?: true | PostInteractionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostInteractionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostInteractionMaxAggregateInputType
  }

  export type GetPostInteractionAggregateType<T extends PostInteractionAggregateArgs> = {
        [P in keyof T & keyof AggregatePostInteraction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostInteraction[P]>
      : GetScalarType<T[P], AggregatePostInteraction[P]>
  }




  export type PostInteractionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostInteractionWhereInput
    orderBy?: PostInteractionOrderByWithAggregationInput | PostInteractionOrderByWithAggregationInput[]
    by: PostInteractionScalarFieldEnum[] | PostInteractionScalarFieldEnum
    having?: PostInteractionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostInteractionCountAggregateInputType | true
    _min?: PostInteractionMinAggregateInputType
    _max?: PostInteractionMaxAggregateInputType
  }

  export type PostInteractionGroupByOutputType = {
    id: string
    postId: string
    type: $Enums.InteractionType
    visitorId: string | null
    sessionId: string | null
    value: string | null
    metadata: JsonValue | null
    createdAt: Date
    _count: PostInteractionCountAggregateOutputType | null
    _min: PostInteractionMinAggregateOutputType | null
    _max: PostInteractionMaxAggregateOutputType | null
  }

  type GetPostInteractionGroupByPayload<T extends PostInteractionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostInteractionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostInteractionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostInteractionGroupByOutputType[P]>
            : GetScalarType<T[P], PostInteractionGroupByOutputType[P]>
        }
      >
    >


  export type PostInteractionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    type?: boolean
    visitorId?: boolean
    sessionId?: boolean
    value?: boolean
    metadata?: boolean
    createdAt?: boolean
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postInteraction"]>

  export type PostInteractionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    type?: boolean
    visitorId?: boolean
    sessionId?: boolean
    value?: boolean
    metadata?: boolean
    createdAt?: boolean
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postInteraction"]>

  export type PostInteractionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    type?: boolean
    visitorId?: boolean
    sessionId?: boolean
    value?: boolean
    metadata?: boolean
    createdAt?: boolean
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postInteraction"]>

  export type PostInteractionSelectScalar = {
    id?: boolean
    postId?: boolean
    type?: boolean
    visitorId?: boolean
    sessionId?: boolean
    value?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type PostInteractionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "postId" | "type" | "visitorId" | "sessionId" | "value" | "metadata" | "createdAt", ExtArgs["result"]["postInteraction"]>
  export type PostInteractionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
  }
  export type PostInteractionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
  }
  export type PostInteractionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
  }

  export type $PostInteractionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PostInteraction"
    objects: {
      post: Prisma.$BlogPostPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postId: string
      type: $Enums.InteractionType
      visitorId: string | null
      sessionId: string | null
      value: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["postInteraction"]>
    composites: {}
  }

  type PostInteractionGetPayload<S extends boolean | null | undefined | PostInteractionDefaultArgs> = $Result.GetResult<Prisma.$PostInteractionPayload, S>

  type PostInteractionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostInteractionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostInteractionCountAggregateInputType | true
    }

  export interface PostInteractionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostInteraction'], meta: { name: 'PostInteraction' } }
    /**
     * Find zero or one PostInteraction that matches the filter.
     * @param {PostInteractionFindUniqueArgs} args - Arguments to find a PostInteraction
     * @example
     * // Get one PostInteraction
     * const postInteraction = await prisma.postInteraction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostInteractionFindUniqueArgs>(args: SelectSubset<T, PostInteractionFindUniqueArgs<ExtArgs>>): Prisma__PostInteractionClient<$Result.GetResult<Prisma.$PostInteractionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PostInteraction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostInteractionFindUniqueOrThrowArgs} args - Arguments to find a PostInteraction
     * @example
     * // Get one PostInteraction
     * const postInteraction = await prisma.postInteraction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostInteractionFindUniqueOrThrowArgs>(args: SelectSubset<T, PostInteractionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostInteractionClient<$Result.GetResult<Prisma.$PostInteractionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostInteraction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostInteractionFindFirstArgs} args - Arguments to find a PostInteraction
     * @example
     * // Get one PostInteraction
     * const postInteraction = await prisma.postInteraction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostInteractionFindFirstArgs>(args?: SelectSubset<T, PostInteractionFindFirstArgs<ExtArgs>>): Prisma__PostInteractionClient<$Result.GetResult<Prisma.$PostInteractionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostInteraction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostInteractionFindFirstOrThrowArgs} args - Arguments to find a PostInteraction
     * @example
     * // Get one PostInteraction
     * const postInteraction = await prisma.postInteraction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostInteractionFindFirstOrThrowArgs>(args?: SelectSubset<T, PostInteractionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostInteractionClient<$Result.GetResult<Prisma.$PostInteractionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PostInteractions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostInteractionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostInteractions
     * const postInteractions = await prisma.postInteraction.findMany()
     * 
     * // Get first 10 PostInteractions
     * const postInteractions = await prisma.postInteraction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postInteractionWithIdOnly = await prisma.postInteraction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostInteractionFindManyArgs>(args?: SelectSubset<T, PostInteractionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostInteractionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PostInteraction.
     * @param {PostInteractionCreateArgs} args - Arguments to create a PostInteraction.
     * @example
     * // Create one PostInteraction
     * const PostInteraction = await prisma.postInteraction.create({
     *   data: {
     *     // ... data to create a PostInteraction
     *   }
     * })
     * 
     */
    create<T extends PostInteractionCreateArgs>(args: SelectSubset<T, PostInteractionCreateArgs<ExtArgs>>): Prisma__PostInteractionClient<$Result.GetResult<Prisma.$PostInteractionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PostInteractions.
     * @param {PostInteractionCreateManyArgs} args - Arguments to create many PostInteractions.
     * @example
     * // Create many PostInteractions
     * const postInteraction = await prisma.postInteraction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostInteractionCreateManyArgs>(args?: SelectSubset<T, PostInteractionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PostInteractions and returns the data saved in the database.
     * @param {PostInteractionCreateManyAndReturnArgs} args - Arguments to create many PostInteractions.
     * @example
     * // Create many PostInteractions
     * const postInteraction = await prisma.postInteraction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PostInteractions and only return the `id`
     * const postInteractionWithIdOnly = await prisma.postInteraction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostInteractionCreateManyAndReturnArgs>(args?: SelectSubset<T, PostInteractionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostInteractionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PostInteraction.
     * @param {PostInteractionDeleteArgs} args - Arguments to delete one PostInteraction.
     * @example
     * // Delete one PostInteraction
     * const PostInteraction = await prisma.postInteraction.delete({
     *   where: {
     *     // ... filter to delete one PostInteraction
     *   }
     * })
     * 
     */
    delete<T extends PostInteractionDeleteArgs>(args: SelectSubset<T, PostInteractionDeleteArgs<ExtArgs>>): Prisma__PostInteractionClient<$Result.GetResult<Prisma.$PostInteractionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PostInteraction.
     * @param {PostInteractionUpdateArgs} args - Arguments to update one PostInteraction.
     * @example
     * // Update one PostInteraction
     * const postInteraction = await prisma.postInteraction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostInteractionUpdateArgs>(args: SelectSubset<T, PostInteractionUpdateArgs<ExtArgs>>): Prisma__PostInteractionClient<$Result.GetResult<Prisma.$PostInteractionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PostInteractions.
     * @param {PostInteractionDeleteManyArgs} args - Arguments to filter PostInteractions to delete.
     * @example
     * // Delete a few PostInteractions
     * const { count } = await prisma.postInteraction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostInteractionDeleteManyArgs>(args?: SelectSubset<T, PostInteractionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostInteractions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostInteractionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostInteractions
     * const postInteraction = await prisma.postInteraction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostInteractionUpdateManyArgs>(args: SelectSubset<T, PostInteractionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostInteractions and returns the data updated in the database.
     * @param {PostInteractionUpdateManyAndReturnArgs} args - Arguments to update many PostInteractions.
     * @example
     * // Update many PostInteractions
     * const postInteraction = await prisma.postInteraction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PostInteractions and only return the `id`
     * const postInteractionWithIdOnly = await prisma.postInteraction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PostInteractionUpdateManyAndReturnArgs>(args: SelectSubset<T, PostInteractionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostInteractionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PostInteraction.
     * @param {PostInteractionUpsertArgs} args - Arguments to update or create a PostInteraction.
     * @example
     * // Update or create a PostInteraction
     * const postInteraction = await prisma.postInteraction.upsert({
     *   create: {
     *     // ... data to create a PostInteraction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostInteraction we want to update
     *   }
     * })
     */
    upsert<T extends PostInteractionUpsertArgs>(args: SelectSubset<T, PostInteractionUpsertArgs<ExtArgs>>): Prisma__PostInteractionClient<$Result.GetResult<Prisma.$PostInteractionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PostInteractions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostInteractionCountArgs} args - Arguments to filter PostInteractions to count.
     * @example
     * // Count the number of PostInteractions
     * const count = await prisma.postInteraction.count({
     *   where: {
     *     // ... the filter for the PostInteractions we want to count
     *   }
     * })
    **/
    count<T extends PostInteractionCountArgs>(
      args?: Subset<T, PostInteractionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostInteractionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostInteraction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostInteractionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostInteractionAggregateArgs>(args: Subset<T, PostInteractionAggregateArgs>): Prisma.PrismaPromise<GetPostInteractionAggregateType<T>>

    /**
     * Group by PostInteraction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostInteractionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostInteractionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostInteractionGroupByArgs['orderBy'] }
        : { orderBy?: PostInteractionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostInteractionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostInteractionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PostInteraction model
   */
  readonly fields: PostInteractionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PostInteraction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostInteractionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends BlogPostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BlogPostDefaultArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PostInteraction model
   */
  interface PostInteractionFieldRefs {
    readonly id: FieldRef<"PostInteraction", 'String'>
    readonly postId: FieldRef<"PostInteraction", 'String'>
    readonly type: FieldRef<"PostInteraction", 'InteractionType'>
    readonly visitorId: FieldRef<"PostInteraction", 'String'>
    readonly sessionId: FieldRef<"PostInteraction", 'String'>
    readonly value: FieldRef<"PostInteraction", 'String'>
    readonly metadata: FieldRef<"PostInteraction", 'Json'>
    readonly createdAt: FieldRef<"PostInteraction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PostInteraction findUnique
   */
  export type PostInteractionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostInteraction
     */
    select?: PostInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostInteraction
     */
    omit?: PostInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInteractionInclude<ExtArgs> | null
    /**
     * Filter, which PostInteraction to fetch.
     */
    where: PostInteractionWhereUniqueInput
  }

  /**
   * PostInteraction findUniqueOrThrow
   */
  export type PostInteractionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostInteraction
     */
    select?: PostInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostInteraction
     */
    omit?: PostInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInteractionInclude<ExtArgs> | null
    /**
     * Filter, which PostInteraction to fetch.
     */
    where: PostInteractionWhereUniqueInput
  }

  /**
   * PostInteraction findFirst
   */
  export type PostInteractionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostInteraction
     */
    select?: PostInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostInteraction
     */
    omit?: PostInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInteractionInclude<ExtArgs> | null
    /**
     * Filter, which PostInteraction to fetch.
     */
    where?: PostInteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostInteractions to fetch.
     */
    orderBy?: PostInteractionOrderByWithRelationInput | PostInteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostInteractions.
     */
    cursor?: PostInteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostInteractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostInteractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostInteractions.
     */
    distinct?: PostInteractionScalarFieldEnum | PostInteractionScalarFieldEnum[]
  }

  /**
   * PostInteraction findFirstOrThrow
   */
  export type PostInteractionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostInteraction
     */
    select?: PostInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostInteraction
     */
    omit?: PostInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInteractionInclude<ExtArgs> | null
    /**
     * Filter, which PostInteraction to fetch.
     */
    where?: PostInteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostInteractions to fetch.
     */
    orderBy?: PostInteractionOrderByWithRelationInput | PostInteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostInteractions.
     */
    cursor?: PostInteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostInteractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostInteractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostInteractions.
     */
    distinct?: PostInteractionScalarFieldEnum | PostInteractionScalarFieldEnum[]
  }

  /**
   * PostInteraction findMany
   */
  export type PostInteractionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostInteraction
     */
    select?: PostInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostInteraction
     */
    omit?: PostInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInteractionInclude<ExtArgs> | null
    /**
     * Filter, which PostInteractions to fetch.
     */
    where?: PostInteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostInteractions to fetch.
     */
    orderBy?: PostInteractionOrderByWithRelationInput | PostInteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostInteractions.
     */
    cursor?: PostInteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostInteractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostInteractions.
     */
    skip?: number
    distinct?: PostInteractionScalarFieldEnum | PostInteractionScalarFieldEnum[]
  }

  /**
   * PostInteraction create
   */
  export type PostInteractionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostInteraction
     */
    select?: PostInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostInteraction
     */
    omit?: PostInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInteractionInclude<ExtArgs> | null
    /**
     * The data needed to create a PostInteraction.
     */
    data: XOR<PostInteractionCreateInput, PostInteractionUncheckedCreateInput>
  }

  /**
   * PostInteraction createMany
   */
  export type PostInteractionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PostInteractions.
     */
    data: PostInteractionCreateManyInput | PostInteractionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PostInteraction createManyAndReturn
   */
  export type PostInteractionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostInteraction
     */
    select?: PostInteractionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostInteraction
     */
    omit?: PostInteractionOmit<ExtArgs> | null
    /**
     * The data used to create many PostInteractions.
     */
    data: PostInteractionCreateManyInput | PostInteractionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInteractionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostInteraction update
   */
  export type PostInteractionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostInteraction
     */
    select?: PostInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostInteraction
     */
    omit?: PostInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInteractionInclude<ExtArgs> | null
    /**
     * The data needed to update a PostInteraction.
     */
    data: XOR<PostInteractionUpdateInput, PostInteractionUncheckedUpdateInput>
    /**
     * Choose, which PostInteraction to update.
     */
    where: PostInteractionWhereUniqueInput
  }

  /**
   * PostInteraction updateMany
   */
  export type PostInteractionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PostInteractions.
     */
    data: XOR<PostInteractionUpdateManyMutationInput, PostInteractionUncheckedUpdateManyInput>
    /**
     * Filter which PostInteractions to update
     */
    where?: PostInteractionWhereInput
    /**
     * Limit how many PostInteractions to update.
     */
    limit?: number
  }

  /**
   * PostInteraction updateManyAndReturn
   */
  export type PostInteractionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostInteraction
     */
    select?: PostInteractionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostInteraction
     */
    omit?: PostInteractionOmit<ExtArgs> | null
    /**
     * The data used to update PostInteractions.
     */
    data: XOR<PostInteractionUpdateManyMutationInput, PostInteractionUncheckedUpdateManyInput>
    /**
     * Filter which PostInteractions to update
     */
    where?: PostInteractionWhereInput
    /**
     * Limit how many PostInteractions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInteractionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostInteraction upsert
   */
  export type PostInteractionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostInteraction
     */
    select?: PostInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostInteraction
     */
    omit?: PostInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInteractionInclude<ExtArgs> | null
    /**
     * The filter to search for the PostInteraction to update in case it exists.
     */
    where: PostInteractionWhereUniqueInput
    /**
     * In case the PostInteraction found by the `where` argument doesn't exist, create a new PostInteraction with this data.
     */
    create: XOR<PostInteractionCreateInput, PostInteractionUncheckedCreateInput>
    /**
     * In case the PostInteraction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostInteractionUpdateInput, PostInteractionUncheckedUpdateInput>
  }

  /**
   * PostInteraction delete
   */
  export type PostInteractionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostInteraction
     */
    select?: PostInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostInteraction
     */
    omit?: PostInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInteractionInclude<ExtArgs> | null
    /**
     * Filter which PostInteraction to delete.
     */
    where: PostInteractionWhereUniqueInput
  }

  /**
   * PostInteraction deleteMany
   */
  export type PostInteractionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostInteractions to delete
     */
    where?: PostInteractionWhereInput
    /**
     * Limit how many PostInteractions to delete.
     */
    limit?: number
  }

  /**
   * PostInteraction without action
   */
  export type PostInteractionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostInteraction
     */
    select?: PostInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostInteraction
     */
    omit?: PostInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInteractionInclude<ExtArgs> | null
  }


  /**
   * Model SEOEvent
   */

  export type AggregateSEOEvent = {
    _count: SEOEventCountAggregateOutputType | null
    _min: SEOEventMinAggregateOutputType | null
    _max: SEOEventMaxAggregateOutputType | null
  }

  export type SEOEventMinAggregateOutputType = {
    id: string | null
    postId: string | null
    type: $Enums.SEOEventType | null
    title: string | null
    description: string | null
    severity: $Enums.SEOSeverity | null
    oldValue: string | null
    newValue: string | null
    recommendations: string | null
    processed: boolean | null
    processedAt: Date | null
    createdAt: Date | null
  }

  export type SEOEventMaxAggregateOutputType = {
    id: string | null
    postId: string | null
    type: $Enums.SEOEventType | null
    title: string | null
    description: string | null
    severity: $Enums.SEOSeverity | null
    oldValue: string | null
    newValue: string | null
    recommendations: string | null
    processed: boolean | null
    processedAt: Date | null
    createdAt: Date | null
  }

  export type SEOEventCountAggregateOutputType = {
    id: number
    postId: number
    type: number
    title: number
    description: number
    severity: number
    oldValue: number
    newValue: number
    recommendations: number
    processed: number
    processedAt: number
    createdAt: number
    _all: number
  }


  export type SEOEventMinAggregateInputType = {
    id?: true
    postId?: true
    type?: true
    title?: true
    description?: true
    severity?: true
    oldValue?: true
    newValue?: true
    recommendations?: true
    processed?: true
    processedAt?: true
    createdAt?: true
  }

  export type SEOEventMaxAggregateInputType = {
    id?: true
    postId?: true
    type?: true
    title?: true
    description?: true
    severity?: true
    oldValue?: true
    newValue?: true
    recommendations?: true
    processed?: true
    processedAt?: true
    createdAt?: true
  }

  export type SEOEventCountAggregateInputType = {
    id?: true
    postId?: true
    type?: true
    title?: true
    description?: true
    severity?: true
    oldValue?: true
    newValue?: true
    recommendations?: true
    processed?: true
    processedAt?: true
    createdAt?: true
    _all?: true
  }

  export type SEOEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SEOEvent to aggregate.
     */
    where?: SEOEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SEOEvents to fetch.
     */
    orderBy?: SEOEventOrderByWithRelationInput | SEOEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SEOEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SEOEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SEOEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SEOEvents
    **/
    _count?: true | SEOEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SEOEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SEOEventMaxAggregateInputType
  }

  export type GetSEOEventAggregateType<T extends SEOEventAggregateArgs> = {
        [P in keyof T & keyof AggregateSEOEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSEOEvent[P]>
      : GetScalarType<T[P], AggregateSEOEvent[P]>
  }




  export type SEOEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SEOEventWhereInput
    orderBy?: SEOEventOrderByWithAggregationInput | SEOEventOrderByWithAggregationInput[]
    by: SEOEventScalarFieldEnum[] | SEOEventScalarFieldEnum
    having?: SEOEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SEOEventCountAggregateInputType | true
    _min?: SEOEventMinAggregateInputType
    _max?: SEOEventMaxAggregateInputType
  }

  export type SEOEventGroupByOutputType = {
    id: string
    postId: string | null
    type: $Enums.SEOEventType
    title: string
    description: string | null
    severity: $Enums.SEOSeverity
    oldValue: string | null
    newValue: string | null
    recommendations: string | null
    processed: boolean
    processedAt: Date | null
    createdAt: Date
    _count: SEOEventCountAggregateOutputType | null
    _min: SEOEventMinAggregateOutputType | null
    _max: SEOEventMaxAggregateOutputType | null
  }

  type GetSEOEventGroupByPayload<T extends SEOEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SEOEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SEOEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SEOEventGroupByOutputType[P]>
            : GetScalarType<T[P], SEOEventGroupByOutputType[P]>
        }
      >
    >


  export type SEOEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    severity?: boolean
    oldValue?: boolean
    newValue?: boolean
    recommendations?: boolean
    processed?: boolean
    processedAt?: boolean
    createdAt?: boolean
    post?: boolean | SEOEvent$postArgs<ExtArgs>
  }, ExtArgs["result"]["sEOEvent"]>

  export type SEOEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    severity?: boolean
    oldValue?: boolean
    newValue?: boolean
    recommendations?: boolean
    processed?: boolean
    processedAt?: boolean
    createdAt?: boolean
    post?: boolean | SEOEvent$postArgs<ExtArgs>
  }, ExtArgs["result"]["sEOEvent"]>

  export type SEOEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    severity?: boolean
    oldValue?: boolean
    newValue?: boolean
    recommendations?: boolean
    processed?: boolean
    processedAt?: boolean
    createdAt?: boolean
    post?: boolean | SEOEvent$postArgs<ExtArgs>
  }, ExtArgs["result"]["sEOEvent"]>

  export type SEOEventSelectScalar = {
    id?: boolean
    postId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    severity?: boolean
    oldValue?: boolean
    newValue?: boolean
    recommendations?: boolean
    processed?: boolean
    processedAt?: boolean
    createdAt?: boolean
  }

  export type SEOEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "postId" | "type" | "title" | "description" | "severity" | "oldValue" | "newValue" | "recommendations" | "processed" | "processedAt" | "createdAt", ExtArgs["result"]["sEOEvent"]>
  export type SEOEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | SEOEvent$postArgs<ExtArgs>
  }
  export type SEOEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | SEOEvent$postArgs<ExtArgs>
  }
  export type SEOEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | SEOEvent$postArgs<ExtArgs>
  }

  export type $SEOEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SEOEvent"
    objects: {
      post: Prisma.$BlogPostPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postId: string | null
      type: $Enums.SEOEventType
      title: string
      description: string | null
      severity: $Enums.SEOSeverity
      oldValue: string | null
      newValue: string | null
      recommendations: string | null
      processed: boolean
      processedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["sEOEvent"]>
    composites: {}
  }

  type SEOEventGetPayload<S extends boolean | null | undefined | SEOEventDefaultArgs> = $Result.GetResult<Prisma.$SEOEventPayload, S>

  type SEOEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SEOEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SEOEventCountAggregateInputType | true
    }

  export interface SEOEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SEOEvent'], meta: { name: 'SEOEvent' } }
    /**
     * Find zero or one SEOEvent that matches the filter.
     * @param {SEOEventFindUniqueArgs} args - Arguments to find a SEOEvent
     * @example
     * // Get one SEOEvent
     * const sEOEvent = await prisma.sEOEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SEOEventFindUniqueArgs>(args: SelectSubset<T, SEOEventFindUniqueArgs<ExtArgs>>): Prisma__SEOEventClient<$Result.GetResult<Prisma.$SEOEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SEOEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SEOEventFindUniqueOrThrowArgs} args - Arguments to find a SEOEvent
     * @example
     * // Get one SEOEvent
     * const sEOEvent = await prisma.sEOEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SEOEventFindUniqueOrThrowArgs>(args: SelectSubset<T, SEOEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SEOEventClient<$Result.GetResult<Prisma.$SEOEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SEOEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SEOEventFindFirstArgs} args - Arguments to find a SEOEvent
     * @example
     * // Get one SEOEvent
     * const sEOEvent = await prisma.sEOEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SEOEventFindFirstArgs>(args?: SelectSubset<T, SEOEventFindFirstArgs<ExtArgs>>): Prisma__SEOEventClient<$Result.GetResult<Prisma.$SEOEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SEOEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SEOEventFindFirstOrThrowArgs} args - Arguments to find a SEOEvent
     * @example
     * // Get one SEOEvent
     * const sEOEvent = await prisma.sEOEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SEOEventFindFirstOrThrowArgs>(args?: SelectSubset<T, SEOEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__SEOEventClient<$Result.GetResult<Prisma.$SEOEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SEOEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SEOEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SEOEvents
     * const sEOEvents = await prisma.sEOEvent.findMany()
     * 
     * // Get first 10 SEOEvents
     * const sEOEvents = await prisma.sEOEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sEOEventWithIdOnly = await prisma.sEOEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SEOEventFindManyArgs>(args?: SelectSubset<T, SEOEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SEOEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SEOEvent.
     * @param {SEOEventCreateArgs} args - Arguments to create a SEOEvent.
     * @example
     * // Create one SEOEvent
     * const SEOEvent = await prisma.sEOEvent.create({
     *   data: {
     *     // ... data to create a SEOEvent
     *   }
     * })
     * 
     */
    create<T extends SEOEventCreateArgs>(args: SelectSubset<T, SEOEventCreateArgs<ExtArgs>>): Prisma__SEOEventClient<$Result.GetResult<Prisma.$SEOEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SEOEvents.
     * @param {SEOEventCreateManyArgs} args - Arguments to create many SEOEvents.
     * @example
     * // Create many SEOEvents
     * const sEOEvent = await prisma.sEOEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SEOEventCreateManyArgs>(args?: SelectSubset<T, SEOEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SEOEvents and returns the data saved in the database.
     * @param {SEOEventCreateManyAndReturnArgs} args - Arguments to create many SEOEvents.
     * @example
     * // Create many SEOEvents
     * const sEOEvent = await prisma.sEOEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SEOEvents and only return the `id`
     * const sEOEventWithIdOnly = await prisma.sEOEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SEOEventCreateManyAndReturnArgs>(args?: SelectSubset<T, SEOEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SEOEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SEOEvent.
     * @param {SEOEventDeleteArgs} args - Arguments to delete one SEOEvent.
     * @example
     * // Delete one SEOEvent
     * const SEOEvent = await prisma.sEOEvent.delete({
     *   where: {
     *     // ... filter to delete one SEOEvent
     *   }
     * })
     * 
     */
    delete<T extends SEOEventDeleteArgs>(args: SelectSubset<T, SEOEventDeleteArgs<ExtArgs>>): Prisma__SEOEventClient<$Result.GetResult<Prisma.$SEOEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SEOEvent.
     * @param {SEOEventUpdateArgs} args - Arguments to update one SEOEvent.
     * @example
     * // Update one SEOEvent
     * const sEOEvent = await prisma.sEOEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SEOEventUpdateArgs>(args: SelectSubset<T, SEOEventUpdateArgs<ExtArgs>>): Prisma__SEOEventClient<$Result.GetResult<Prisma.$SEOEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SEOEvents.
     * @param {SEOEventDeleteManyArgs} args - Arguments to filter SEOEvents to delete.
     * @example
     * // Delete a few SEOEvents
     * const { count } = await prisma.sEOEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SEOEventDeleteManyArgs>(args?: SelectSubset<T, SEOEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SEOEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SEOEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SEOEvents
     * const sEOEvent = await prisma.sEOEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SEOEventUpdateManyArgs>(args: SelectSubset<T, SEOEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SEOEvents and returns the data updated in the database.
     * @param {SEOEventUpdateManyAndReturnArgs} args - Arguments to update many SEOEvents.
     * @example
     * // Update many SEOEvents
     * const sEOEvent = await prisma.sEOEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SEOEvents and only return the `id`
     * const sEOEventWithIdOnly = await prisma.sEOEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SEOEventUpdateManyAndReturnArgs>(args: SelectSubset<T, SEOEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SEOEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SEOEvent.
     * @param {SEOEventUpsertArgs} args - Arguments to update or create a SEOEvent.
     * @example
     * // Update or create a SEOEvent
     * const sEOEvent = await prisma.sEOEvent.upsert({
     *   create: {
     *     // ... data to create a SEOEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SEOEvent we want to update
     *   }
     * })
     */
    upsert<T extends SEOEventUpsertArgs>(args: SelectSubset<T, SEOEventUpsertArgs<ExtArgs>>): Prisma__SEOEventClient<$Result.GetResult<Prisma.$SEOEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SEOEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SEOEventCountArgs} args - Arguments to filter SEOEvents to count.
     * @example
     * // Count the number of SEOEvents
     * const count = await prisma.sEOEvent.count({
     *   where: {
     *     // ... the filter for the SEOEvents we want to count
     *   }
     * })
    **/
    count<T extends SEOEventCountArgs>(
      args?: Subset<T, SEOEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SEOEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SEOEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SEOEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SEOEventAggregateArgs>(args: Subset<T, SEOEventAggregateArgs>): Prisma.PrismaPromise<GetSEOEventAggregateType<T>>

    /**
     * Group by SEOEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SEOEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SEOEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SEOEventGroupByArgs['orderBy'] }
        : { orderBy?: SEOEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SEOEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSEOEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SEOEvent model
   */
  readonly fields: SEOEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SEOEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SEOEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends SEOEvent$postArgs<ExtArgs> = {}>(args?: Subset<T, SEOEvent$postArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SEOEvent model
   */
  interface SEOEventFieldRefs {
    readonly id: FieldRef<"SEOEvent", 'String'>
    readonly postId: FieldRef<"SEOEvent", 'String'>
    readonly type: FieldRef<"SEOEvent", 'SEOEventType'>
    readonly title: FieldRef<"SEOEvent", 'String'>
    readonly description: FieldRef<"SEOEvent", 'String'>
    readonly severity: FieldRef<"SEOEvent", 'SEOSeverity'>
    readonly oldValue: FieldRef<"SEOEvent", 'String'>
    readonly newValue: FieldRef<"SEOEvent", 'String'>
    readonly recommendations: FieldRef<"SEOEvent", 'String'>
    readonly processed: FieldRef<"SEOEvent", 'Boolean'>
    readonly processedAt: FieldRef<"SEOEvent", 'DateTime'>
    readonly createdAt: FieldRef<"SEOEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SEOEvent findUnique
   */
  export type SEOEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SEOEvent
     */
    select?: SEOEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SEOEvent
     */
    omit?: SEOEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SEOEventInclude<ExtArgs> | null
    /**
     * Filter, which SEOEvent to fetch.
     */
    where: SEOEventWhereUniqueInput
  }

  /**
   * SEOEvent findUniqueOrThrow
   */
  export type SEOEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SEOEvent
     */
    select?: SEOEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SEOEvent
     */
    omit?: SEOEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SEOEventInclude<ExtArgs> | null
    /**
     * Filter, which SEOEvent to fetch.
     */
    where: SEOEventWhereUniqueInput
  }

  /**
   * SEOEvent findFirst
   */
  export type SEOEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SEOEvent
     */
    select?: SEOEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SEOEvent
     */
    omit?: SEOEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SEOEventInclude<ExtArgs> | null
    /**
     * Filter, which SEOEvent to fetch.
     */
    where?: SEOEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SEOEvents to fetch.
     */
    orderBy?: SEOEventOrderByWithRelationInput | SEOEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SEOEvents.
     */
    cursor?: SEOEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SEOEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SEOEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SEOEvents.
     */
    distinct?: SEOEventScalarFieldEnum | SEOEventScalarFieldEnum[]
  }

  /**
   * SEOEvent findFirstOrThrow
   */
  export type SEOEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SEOEvent
     */
    select?: SEOEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SEOEvent
     */
    omit?: SEOEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SEOEventInclude<ExtArgs> | null
    /**
     * Filter, which SEOEvent to fetch.
     */
    where?: SEOEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SEOEvents to fetch.
     */
    orderBy?: SEOEventOrderByWithRelationInput | SEOEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SEOEvents.
     */
    cursor?: SEOEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SEOEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SEOEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SEOEvents.
     */
    distinct?: SEOEventScalarFieldEnum | SEOEventScalarFieldEnum[]
  }

  /**
   * SEOEvent findMany
   */
  export type SEOEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SEOEvent
     */
    select?: SEOEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SEOEvent
     */
    omit?: SEOEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SEOEventInclude<ExtArgs> | null
    /**
     * Filter, which SEOEvents to fetch.
     */
    where?: SEOEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SEOEvents to fetch.
     */
    orderBy?: SEOEventOrderByWithRelationInput | SEOEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SEOEvents.
     */
    cursor?: SEOEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SEOEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SEOEvents.
     */
    skip?: number
    distinct?: SEOEventScalarFieldEnum | SEOEventScalarFieldEnum[]
  }

  /**
   * SEOEvent create
   */
  export type SEOEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SEOEvent
     */
    select?: SEOEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SEOEvent
     */
    omit?: SEOEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SEOEventInclude<ExtArgs> | null
    /**
     * The data needed to create a SEOEvent.
     */
    data: XOR<SEOEventCreateInput, SEOEventUncheckedCreateInput>
  }

  /**
   * SEOEvent createMany
   */
  export type SEOEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SEOEvents.
     */
    data: SEOEventCreateManyInput | SEOEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SEOEvent createManyAndReturn
   */
  export type SEOEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SEOEvent
     */
    select?: SEOEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SEOEvent
     */
    omit?: SEOEventOmit<ExtArgs> | null
    /**
     * The data used to create many SEOEvents.
     */
    data: SEOEventCreateManyInput | SEOEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SEOEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SEOEvent update
   */
  export type SEOEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SEOEvent
     */
    select?: SEOEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SEOEvent
     */
    omit?: SEOEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SEOEventInclude<ExtArgs> | null
    /**
     * The data needed to update a SEOEvent.
     */
    data: XOR<SEOEventUpdateInput, SEOEventUncheckedUpdateInput>
    /**
     * Choose, which SEOEvent to update.
     */
    where: SEOEventWhereUniqueInput
  }

  /**
   * SEOEvent updateMany
   */
  export type SEOEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SEOEvents.
     */
    data: XOR<SEOEventUpdateManyMutationInput, SEOEventUncheckedUpdateManyInput>
    /**
     * Filter which SEOEvents to update
     */
    where?: SEOEventWhereInput
    /**
     * Limit how many SEOEvents to update.
     */
    limit?: number
  }

  /**
   * SEOEvent updateManyAndReturn
   */
  export type SEOEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SEOEvent
     */
    select?: SEOEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SEOEvent
     */
    omit?: SEOEventOmit<ExtArgs> | null
    /**
     * The data used to update SEOEvents.
     */
    data: XOR<SEOEventUpdateManyMutationInput, SEOEventUncheckedUpdateManyInput>
    /**
     * Filter which SEOEvents to update
     */
    where?: SEOEventWhereInput
    /**
     * Limit how many SEOEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SEOEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SEOEvent upsert
   */
  export type SEOEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SEOEvent
     */
    select?: SEOEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SEOEvent
     */
    omit?: SEOEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SEOEventInclude<ExtArgs> | null
    /**
     * The filter to search for the SEOEvent to update in case it exists.
     */
    where: SEOEventWhereUniqueInput
    /**
     * In case the SEOEvent found by the `where` argument doesn't exist, create a new SEOEvent with this data.
     */
    create: XOR<SEOEventCreateInput, SEOEventUncheckedCreateInput>
    /**
     * In case the SEOEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SEOEventUpdateInput, SEOEventUncheckedUpdateInput>
  }

  /**
   * SEOEvent delete
   */
  export type SEOEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SEOEvent
     */
    select?: SEOEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SEOEvent
     */
    omit?: SEOEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SEOEventInclude<ExtArgs> | null
    /**
     * Filter which SEOEvent to delete.
     */
    where: SEOEventWhereUniqueInput
  }

  /**
   * SEOEvent deleteMany
   */
  export type SEOEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SEOEvents to delete
     */
    where?: SEOEventWhereInput
    /**
     * Limit how many SEOEvents to delete.
     */
    limit?: number
  }

  /**
   * SEOEvent.post
   */
  export type SEOEvent$postArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    where?: BlogPostWhereInput
  }

  /**
   * SEOEvent without action
   */
  export type SEOEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SEOEvent
     */
    select?: SEOEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SEOEvent
     */
    omit?: SEOEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SEOEventInclude<ExtArgs> | null
  }


  /**
   * Model SEOKeyword
   */

  export type AggregateSEOKeyword = {
    _count: SEOKeywordCountAggregateOutputType | null
    _avg: SEOKeywordAvgAggregateOutputType | null
    _sum: SEOKeywordSumAggregateOutputType | null
    _min: SEOKeywordMinAggregateOutputType | null
    _max: SEOKeywordMaxAggregateOutputType | null
  }

  export type SEOKeywordAvgAggregateOutputType = {
    position: number | null
    searchVolume: number | null
    difficulty: number | null
    cpc: number | null
    clicks: number | null
    impressions: number | null
    ctr: number | null
  }

  export type SEOKeywordSumAggregateOutputType = {
    position: number | null
    searchVolume: number | null
    difficulty: number | null
    cpc: number | null
    clicks: number | null
    impressions: number | null
    ctr: number | null
  }

  export type SEOKeywordMinAggregateOutputType = {
    id: string | null
    keyword: string | null
    postId: string | null
    position: number | null
    searchVolume: number | null
    difficulty: number | null
    cpc: number | null
    clicks: number | null
    impressions: number | null
    ctr: number | null
    createdAt: Date | null
    updatedAt: Date | null
    lastChecked: Date | null
  }

  export type SEOKeywordMaxAggregateOutputType = {
    id: string | null
    keyword: string | null
    postId: string | null
    position: number | null
    searchVolume: number | null
    difficulty: number | null
    cpc: number | null
    clicks: number | null
    impressions: number | null
    ctr: number | null
    createdAt: Date | null
    updatedAt: Date | null
    lastChecked: Date | null
  }

  export type SEOKeywordCountAggregateOutputType = {
    id: number
    keyword: number
    postId: number
    position: number
    searchVolume: number
    difficulty: number
    cpc: number
    clicks: number
    impressions: number
    ctr: number
    createdAt: number
    updatedAt: number
    lastChecked: number
    _all: number
  }


  export type SEOKeywordAvgAggregateInputType = {
    position?: true
    searchVolume?: true
    difficulty?: true
    cpc?: true
    clicks?: true
    impressions?: true
    ctr?: true
  }

  export type SEOKeywordSumAggregateInputType = {
    position?: true
    searchVolume?: true
    difficulty?: true
    cpc?: true
    clicks?: true
    impressions?: true
    ctr?: true
  }

  export type SEOKeywordMinAggregateInputType = {
    id?: true
    keyword?: true
    postId?: true
    position?: true
    searchVolume?: true
    difficulty?: true
    cpc?: true
    clicks?: true
    impressions?: true
    ctr?: true
    createdAt?: true
    updatedAt?: true
    lastChecked?: true
  }

  export type SEOKeywordMaxAggregateInputType = {
    id?: true
    keyword?: true
    postId?: true
    position?: true
    searchVolume?: true
    difficulty?: true
    cpc?: true
    clicks?: true
    impressions?: true
    ctr?: true
    createdAt?: true
    updatedAt?: true
    lastChecked?: true
  }

  export type SEOKeywordCountAggregateInputType = {
    id?: true
    keyword?: true
    postId?: true
    position?: true
    searchVolume?: true
    difficulty?: true
    cpc?: true
    clicks?: true
    impressions?: true
    ctr?: true
    createdAt?: true
    updatedAt?: true
    lastChecked?: true
    _all?: true
  }

  export type SEOKeywordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SEOKeyword to aggregate.
     */
    where?: SEOKeywordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SEOKeywords to fetch.
     */
    orderBy?: SEOKeywordOrderByWithRelationInput | SEOKeywordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SEOKeywordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SEOKeywords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SEOKeywords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SEOKeywords
    **/
    _count?: true | SEOKeywordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SEOKeywordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SEOKeywordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SEOKeywordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SEOKeywordMaxAggregateInputType
  }

  export type GetSEOKeywordAggregateType<T extends SEOKeywordAggregateArgs> = {
        [P in keyof T & keyof AggregateSEOKeyword]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSEOKeyword[P]>
      : GetScalarType<T[P], AggregateSEOKeyword[P]>
  }




  export type SEOKeywordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SEOKeywordWhereInput
    orderBy?: SEOKeywordOrderByWithAggregationInput | SEOKeywordOrderByWithAggregationInput[]
    by: SEOKeywordScalarFieldEnum[] | SEOKeywordScalarFieldEnum
    having?: SEOKeywordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SEOKeywordCountAggregateInputType | true
    _avg?: SEOKeywordAvgAggregateInputType
    _sum?: SEOKeywordSumAggregateInputType
    _min?: SEOKeywordMinAggregateInputType
    _max?: SEOKeywordMaxAggregateInputType
  }

  export type SEOKeywordGroupByOutputType = {
    id: string
    keyword: string
    postId: string | null
    position: number | null
    searchVolume: number | null
    difficulty: number | null
    cpc: number | null
    clicks: number
    impressions: number
    ctr: number | null
    createdAt: Date
    updatedAt: Date
    lastChecked: Date | null
    _count: SEOKeywordCountAggregateOutputType | null
    _avg: SEOKeywordAvgAggregateOutputType | null
    _sum: SEOKeywordSumAggregateOutputType | null
    _min: SEOKeywordMinAggregateOutputType | null
    _max: SEOKeywordMaxAggregateOutputType | null
  }

  type GetSEOKeywordGroupByPayload<T extends SEOKeywordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SEOKeywordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SEOKeywordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SEOKeywordGroupByOutputType[P]>
            : GetScalarType<T[P], SEOKeywordGroupByOutputType[P]>
        }
      >
    >


  export type SEOKeywordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    keyword?: boolean
    postId?: boolean
    position?: boolean
    searchVolume?: boolean
    difficulty?: boolean
    cpc?: boolean
    clicks?: boolean
    impressions?: boolean
    ctr?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastChecked?: boolean
    post?: boolean | SEOKeyword$postArgs<ExtArgs>
  }, ExtArgs["result"]["sEOKeyword"]>

  export type SEOKeywordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    keyword?: boolean
    postId?: boolean
    position?: boolean
    searchVolume?: boolean
    difficulty?: boolean
    cpc?: boolean
    clicks?: boolean
    impressions?: boolean
    ctr?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastChecked?: boolean
    post?: boolean | SEOKeyword$postArgs<ExtArgs>
  }, ExtArgs["result"]["sEOKeyword"]>

  export type SEOKeywordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    keyword?: boolean
    postId?: boolean
    position?: boolean
    searchVolume?: boolean
    difficulty?: boolean
    cpc?: boolean
    clicks?: boolean
    impressions?: boolean
    ctr?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastChecked?: boolean
    post?: boolean | SEOKeyword$postArgs<ExtArgs>
  }, ExtArgs["result"]["sEOKeyword"]>

  export type SEOKeywordSelectScalar = {
    id?: boolean
    keyword?: boolean
    postId?: boolean
    position?: boolean
    searchVolume?: boolean
    difficulty?: boolean
    cpc?: boolean
    clicks?: boolean
    impressions?: boolean
    ctr?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastChecked?: boolean
  }

  export type SEOKeywordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "keyword" | "postId" | "position" | "searchVolume" | "difficulty" | "cpc" | "clicks" | "impressions" | "ctr" | "createdAt" | "updatedAt" | "lastChecked", ExtArgs["result"]["sEOKeyword"]>
  export type SEOKeywordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | SEOKeyword$postArgs<ExtArgs>
  }
  export type SEOKeywordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | SEOKeyword$postArgs<ExtArgs>
  }
  export type SEOKeywordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | SEOKeyword$postArgs<ExtArgs>
  }

  export type $SEOKeywordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SEOKeyword"
    objects: {
      post: Prisma.$BlogPostPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      keyword: string
      postId: string | null
      position: number | null
      searchVolume: number | null
      difficulty: number | null
      cpc: number | null
      clicks: number
      impressions: number
      ctr: number | null
      createdAt: Date
      updatedAt: Date
      lastChecked: Date | null
    }, ExtArgs["result"]["sEOKeyword"]>
    composites: {}
  }

  type SEOKeywordGetPayload<S extends boolean | null | undefined | SEOKeywordDefaultArgs> = $Result.GetResult<Prisma.$SEOKeywordPayload, S>

  type SEOKeywordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SEOKeywordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SEOKeywordCountAggregateInputType | true
    }

  export interface SEOKeywordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SEOKeyword'], meta: { name: 'SEOKeyword' } }
    /**
     * Find zero or one SEOKeyword that matches the filter.
     * @param {SEOKeywordFindUniqueArgs} args - Arguments to find a SEOKeyword
     * @example
     * // Get one SEOKeyword
     * const sEOKeyword = await prisma.sEOKeyword.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SEOKeywordFindUniqueArgs>(args: SelectSubset<T, SEOKeywordFindUniqueArgs<ExtArgs>>): Prisma__SEOKeywordClient<$Result.GetResult<Prisma.$SEOKeywordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SEOKeyword that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SEOKeywordFindUniqueOrThrowArgs} args - Arguments to find a SEOKeyword
     * @example
     * // Get one SEOKeyword
     * const sEOKeyword = await prisma.sEOKeyword.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SEOKeywordFindUniqueOrThrowArgs>(args: SelectSubset<T, SEOKeywordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SEOKeywordClient<$Result.GetResult<Prisma.$SEOKeywordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SEOKeyword that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SEOKeywordFindFirstArgs} args - Arguments to find a SEOKeyword
     * @example
     * // Get one SEOKeyword
     * const sEOKeyword = await prisma.sEOKeyword.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SEOKeywordFindFirstArgs>(args?: SelectSubset<T, SEOKeywordFindFirstArgs<ExtArgs>>): Prisma__SEOKeywordClient<$Result.GetResult<Prisma.$SEOKeywordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SEOKeyword that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SEOKeywordFindFirstOrThrowArgs} args - Arguments to find a SEOKeyword
     * @example
     * // Get one SEOKeyword
     * const sEOKeyword = await prisma.sEOKeyword.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SEOKeywordFindFirstOrThrowArgs>(args?: SelectSubset<T, SEOKeywordFindFirstOrThrowArgs<ExtArgs>>): Prisma__SEOKeywordClient<$Result.GetResult<Prisma.$SEOKeywordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SEOKeywords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SEOKeywordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SEOKeywords
     * const sEOKeywords = await prisma.sEOKeyword.findMany()
     * 
     * // Get first 10 SEOKeywords
     * const sEOKeywords = await prisma.sEOKeyword.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sEOKeywordWithIdOnly = await prisma.sEOKeyword.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SEOKeywordFindManyArgs>(args?: SelectSubset<T, SEOKeywordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SEOKeywordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SEOKeyword.
     * @param {SEOKeywordCreateArgs} args - Arguments to create a SEOKeyword.
     * @example
     * // Create one SEOKeyword
     * const SEOKeyword = await prisma.sEOKeyword.create({
     *   data: {
     *     // ... data to create a SEOKeyword
     *   }
     * })
     * 
     */
    create<T extends SEOKeywordCreateArgs>(args: SelectSubset<T, SEOKeywordCreateArgs<ExtArgs>>): Prisma__SEOKeywordClient<$Result.GetResult<Prisma.$SEOKeywordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SEOKeywords.
     * @param {SEOKeywordCreateManyArgs} args - Arguments to create many SEOKeywords.
     * @example
     * // Create many SEOKeywords
     * const sEOKeyword = await prisma.sEOKeyword.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SEOKeywordCreateManyArgs>(args?: SelectSubset<T, SEOKeywordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SEOKeywords and returns the data saved in the database.
     * @param {SEOKeywordCreateManyAndReturnArgs} args - Arguments to create many SEOKeywords.
     * @example
     * // Create many SEOKeywords
     * const sEOKeyword = await prisma.sEOKeyword.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SEOKeywords and only return the `id`
     * const sEOKeywordWithIdOnly = await prisma.sEOKeyword.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SEOKeywordCreateManyAndReturnArgs>(args?: SelectSubset<T, SEOKeywordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SEOKeywordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SEOKeyword.
     * @param {SEOKeywordDeleteArgs} args - Arguments to delete one SEOKeyword.
     * @example
     * // Delete one SEOKeyword
     * const SEOKeyword = await prisma.sEOKeyword.delete({
     *   where: {
     *     // ... filter to delete one SEOKeyword
     *   }
     * })
     * 
     */
    delete<T extends SEOKeywordDeleteArgs>(args: SelectSubset<T, SEOKeywordDeleteArgs<ExtArgs>>): Prisma__SEOKeywordClient<$Result.GetResult<Prisma.$SEOKeywordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SEOKeyword.
     * @param {SEOKeywordUpdateArgs} args - Arguments to update one SEOKeyword.
     * @example
     * // Update one SEOKeyword
     * const sEOKeyword = await prisma.sEOKeyword.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SEOKeywordUpdateArgs>(args: SelectSubset<T, SEOKeywordUpdateArgs<ExtArgs>>): Prisma__SEOKeywordClient<$Result.GetResult<Prisma.$SEOKeywordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SEOKeywords.
     * @param {SEOKeywordDeleteManyArgs} args - Arguments to filter SEOKeywords to delete.
     * @example
     * // Delete a few SEOKeywords
     * const { count } = await prisma.sEOKeyword.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SEOKeywordDeleteManyArgs>(args?: SelectSubset<T, SEOKeywordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SEOKeywords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SEOKeywordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SEOKeywords
     * const sEOKeyword = await prisma.sEOKeyword.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SEOKeywordUpdateManyArgs>(args: SelectSubset<T, SEOKeywordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SEOKeywords and returns the data updated in the database.
     * @param {SEOKeywordUpdateManyAndReturnArgs} args - Arguments to update many SEOKeywords.
     * @example
     * // Update many SEOKeywords
     * const sEOKeyword = await prisma.sEOKeyword.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SEOKeywords and only return the `id`
     * const sEOKeywordWithIdOnly = await prisma.sEOKeyword.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SEOKeywordUpdateManyAndReturnArgs>(args: SelectSubset<T, SEOKeywordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SEOKeywordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SEOKeyword.
     * @param {SEOKeywordUpsertArgs} args - Arguments to update or create a SEOKeyword.
     * @example
     * // Update or create a SEOKeyword
     * const sEOKeyword = await prisma.sEOKeyword.upsert({
     *   create: {
     *     // ... data to create a SEOKeyword
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SEOKeyword we want to update
     *   }
     * })
     */
    upsert<T extends SEOKeywordUpsertArgs>(args: SelectSubset<T, SEOKeywordUpsertArgs<ExtArgs>>): Prisma__SEOKeywordClient<$Result.GetResult<Prisma.$SEOKeywordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SEOKeywords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SEOKeywordCountArgs} args - Arguments to filter SEOKeywords to count.
     * @example
     * // Count the number of SEOKeywords
     * const count = await prisma.sEOKeyword.count({
     *   where: {
     *     // ... the filter for the SEOKeywords we want to count
     *   }
     * })
    **/
    count<T extends SEOKeywordCountArgs>(
      args?: Subset<T, SEOKeywordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SEOKeywordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SEOKeyword.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SEOKeywordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SEOKeywordAggregateArgs>(args: Subset<T, SEOKeywordAggregateArgs>): Prisma.PrismaPromise<GetSEOKeywordAggregateType<T>>

    /**
     * Group by SEOKeyword.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SEOKeywordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SEOKeywordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SEOKeywordGroupByArgs['orderBy'] }
        : { orderBy?: SEOKeywordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SEOKeywordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSEOKeywordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SEOKeyword model
   */
  readonly fields: SEOKeywordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SEOKeyword.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SEOKeywordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends SEOKeyword$postArgs<ExtArgs> = {}>(args?: Subset<T, SEOKeyword$postArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SEOKeyword model
   */
  interface SEOKeywordFieldRefs {
    readonly id: FieldRef<"SEOKeyword", 'String'>
    readonly keyword: FieldRef<"SEOKeyword", 'String'>
    readonly postId: FieldRef<"SEOKeyword", 'String'>
    readonly position: FieldRef<"SEOKeyword", 'Int'>
    readonly searchVolume: FieldRef<"SEOKeyword", 'Int'>
    readonly difficulty: FieldRef<"SEOKeyword", 'Float'>
    readonly cpc: FieldRef<"SEOKeyword", 'Float'>
    readonly clicks: FieldRef<"SEOKeyword", 'Int'>
    readonly impressions: FieldRef<"SEOKeyword", 'Int'>
    readonly ctr: FieldRef<"SEOKeyword", 'Float'>
    readonly createdAt: FieldRef<"SEOKeyword", 'DateTime'>
    readonly updatedAt: FieldRef<"SEOKeyword", 'DateTime'>
    readonly lastChecked: FieldRef<"SEOKeyword", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SEOKeyword findUnique
   */
  export type SEOKeywordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SEOKeyword
     */
    select?: SEOKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SEOKeyword
     */
    omit?: SEOKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SEOKeywordInclude<ExtArgs> | null
    /**
     * Filter, which SEOKeyword to fetch.
     */
    where: SEOKeywordWhereUniqueInput
  }

  /**
   * SEOKeyword findUniqueOrThrow
   */
  export type SEOKeywordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SEOKeyword
     */
    select?: SEOKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SEOKeyword
     */
    omit?: SEOKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SEOKeywordInclude<ExtArgs> | null
    /**
     * Filter, which SEOKeyword to fetch.
     */
    where: SEOKeywordWhereUniqueInput
  }

  /**
   * SEOKeyword findFirst
   */
  export type SEOKeywordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SEOKeyword
     */
    select?: SEOKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SEOKeyword
     */
    omit?: SEOKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SEOKeywordInclude<ExtArgs> | null
    /**
     * Filter, which SEOKeyword to fetch.
     */
    where?: SEOKeywordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SEOKeywords to fetch.
     */
    orderBy?: SEOKeywordOrderByWithRelationInput | SEOKeywordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SEOKeywords.
     */
    cursor?: SEOKeywordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SEOKeywords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SEOKeywords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SEOKeywords.
     */
    distinct?: SEOKeywordScalarFieldEnum | SEOKeywordScalarFieldEnum[]
  }

  /**
   * SEOKeyword findFirstOrThrow
   */
  export type SEOKeywordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SEOKeyword
     */
    select?: SEOKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SEOKeyword
     */
    omit?: SEOKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SEOKeywordInclude<ExtArgs> | null
    /**
     * Filter, which SEOKeyword to fetch.
     */
    where?: SEOKeywordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SEOKeywords to fetch.
     */
    orderBy?: SEOKeywordOrderByWithRelationInput | SEOKeywordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SEOKeywords.
     */
    cursor?: SEOKeywordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SEOKeywords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SEOKeywords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SEOKeywords.
     */
    distinct?: SEOKeywordScalarFieldEnum | SEOKeywordScalarFieldEnum[]
  }

  /**
   * SEOKeyword findMany
   */
  export type SEOKeywordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SEOKeyword
     */
    select?: SEOKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SEOKeyword
     */
    omit?: SEOKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SEOKeywordInclude<ExtArgs> | null
    /**
     * Filter, which SEOKeywords to fetch.
     */
    where?: SEOKeywordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SEOKeywords to fetch.
     */
    orderBy?: SEOKeywordOrderByWithRelationInput | SEOKeywordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SEOKeywords.
     */
    cursor?: SEOKeywordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SEOKeywords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SEOKeywords.
     */
    skip?: number
    distinct?: SEOKeywordScalarFieldEnum | SEOKeywordScalarFieldEnum[]
  }

  /**
   * SEOKeyword create
   */
  export type SEOKeywordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SEOKeyword
     */
    select?: SEOKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SEOKeyword
     */
    omit?: SEOKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SEOKeywordInclude<ExtArgs> | null
    /**
     * The data needed to create a SEOKeyword.
     */
    data: XOR<SEOKeywordCreateInput, SEOKeywordUncheckedCreateInput>
  }

  /**
   * SEOKeyword createMany
   */
  export type SEOKeywordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SEOKeywords.
     */
    data: SEOKeywordCreateManyInput | SEOKeywordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SEOKeyword createManyAndReturn
   */
  export type SEOKeywordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SEOKeyword
     */
    select?: SEOKeywordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SEOKeyword
     */
    omit?: SEOKeywordOmit<ExtArgs> | null
    /**
     * The data used to create many SEOKeywords.
     */
    data: SEOKeywordCreateManyInput | SEOKeywordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SEOKeywordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SEOKeyword update
   */
  export type SEOKeywordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SEOKeyword
     */
    select?: SEOKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SEOKeyword
     */
    omit?: SEOKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SEOKeywordInclude<ExtArgs> | null
    /**
     * The data needed to update a SEOKeyword.
     */
    data: XOR<SEOKeywordUpdateInput, SEOKeywordUncheckedUpdateInput>
    /**
     * Choose, which SEOKeyword to update.
     */
    where: SEOKeywordWhereUniqueInput
  }

  /**
   * SEOKeyword updateMany
   */
  export type SEOKeywordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SEOKeywords.
     */
    data: XOR<SEOKeywordUpdateManyMutationInput, SEOKeywordUncheckedUpdateManyInput>
    /**
     * Filter which SEOKeywords to update
     */
    where?: SEOKeywordWhereInput
    /**
     * Limit how many SEOKeywords to update.
     */
    limit?: number
  }

  /**
   * SEOKeyword updateManyAndReturn
   */
  export type SEOKeywordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SEOKeyword
     */
    select?: SEOKeywordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SEOKeyword
     */
    omit?: SEOKeywordOmit<ExtArgs> | null
    /**
     * The data used to update SEOKeywords.
     */
    data: XOR<SEOKeywordUpdateManyMutationInput, SEOKeywordUncheckedUpdateManyInput>
    /**
     * Filter which SEOKeywords to update
     */
    where?: SEOKeywordWhereInput
    /**
     * Limit how many SEOKeywords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SEOKeywordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SEOKeyword upsert
   */
  export type SEOKeywordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SEOKeyword
     */
    select?: SEOKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SEOKeyword
     */
    omit?: SEOKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SEOKeywordInclude<ExtArgs> | null
    /**
     * The filter to search for the SEOKeyword to update in case it exists.
     */
    where: SEOKeywordWhereUniqueInput
    /**
     * In case the SEOKeyword found by the `where` argument doesn't exist, create a new SEOKeyword with this data.
     */
    create: XOR<SEOKeywordCreateInput, SEOKeywordUncheckedCreateInput>
    /**
     * In case the SEOKeyword was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SEOKeywordUpdateInput, SEOKeywordUncheckedUpdateInput>
  }

  /**
   * SEOKeyword delete
   */
  export type SEOKeywordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SEOKeyword
     */
    select?: SEOKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SEOKeyword
     */
    omit?: SEOKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SEOKeywordInclude<ExtArgs> | null
    /**
     * Filter which SEOKeyword to delete.
     */
    where: SEOKeywordWhereUniqueInput
  }

  /**
   * SEOKeyword deleteMany
   */
  export type SEOKeywordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SEOKeywords to delete
     */
    where?: SEOKeywordWhereInput
    /**
     * Limit how many SEOKeywords to delete.
     */
    limit?: number
  }

  /**
   * SEOKeyword.post
   */
  export type SEOKeyword$postArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    where?: BlogPostWhereInput
  }

  /**
   * SEOKeyword without action
   */
  export type SEOKeywordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SEOKeyword
     */
    select?: SEOKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SEOKeyword
     */
    omit?: SEOKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SEOKeywordInclude<ExtArgs> | null
  }


  /**
   * Model SitemapEntry
   */

  export type AggregateSitemapEntry = {
    _count: SitemapEntryCountAggregateOutputType | null
    _avg: SitemapEntryAvgAggregateOutputType | null
    _sum: SitemapEntrySumAggregateOutputType | null
    _min: SitemapEntryMinAggregateOutputType | null
    _max: SitemapEntryMaxAggregateOutputType | null
  }

  export type SitemapEntryAvgAggregateOutputType = {
    priority: number | null
  }

  export type SitemapEntrySumAggregateOutputType = {
    priority: number | null
  }

  export type SitemapEntryMinAggregateOutputType = {
    id: string | null
    url: string | null
    lastMod: Date | null
    changeFreq: $Enums.ChangeFrequency | null
    priority: number | null
    postId: string | null
    included: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SitemapEntryMaxAggregateOutputType = {
    id: string | null
    url: string | null
    lastMod: Date | null
    changeFreq: $Enums.ChangeFrequency | null
    priority: number | null
    postId: string | null
    included: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SitemapEntryCountAggregateOutputType = {
    id: number
    url: number
    lastMod: number
    changeFreq: number
    priority: number
    postId: number
    included: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SitemapEntryAvgAggregateInputType = {
    priority?: true
  }

  export type SitemapEntrySumAggregateInputType = {
    priority?: true
  }

  export type SitemapEntryMinAggregateInputType = {
    id?: true
    url?: true
    lastMod?: true
    changeFreq?: true
    priority?: true
    postId?: true
    included?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SitemapEntryMaxAggregateInputType = {
    id?: true
    url?: true
    lastMod?: true
    changeFreq?: true
    priority?: true
    postId?: true
    included?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SitemapEntryCountAggregateInputType = {
    id?: true
    url?: true
    lastMod?: true
    changeFreq?: true
    priority?: true
    postId?: true
    included?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SitemapEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SitemapEntry to aggregate.
     */
    where?: SitemapEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SitemapEntries to fetch.
     */
    orderBy?: SitemapEntryOrderByWithRelationInput | SitemapEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SitemapEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SitemapEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SitemapEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SitemapEntries
    **/
    _count?: true | SitemapEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SitemapEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SitemapEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SitemapEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SitemapEntryMaxAggregateInputType
  }

  export type GetSitemapEntryAggregateType<T extends SitemapEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateSitemapEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSitemapEntry[P]>
      : GetScalarType<T[P], AggregateSitemapEntry[P]>
  }




  export type SitemapEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SitemapEntryWhereInput
    orderBy?: SitemapEntryOrderByWithAggregationInput | SitemapEntryOrderByWithAggregationInput[]
    by: SitemapEntryScalarFieldEnum[] | SitemapEntryScalarFieldEnum
    having?: SitemapEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SitemapEntryCountAggregateInputType | true
    _avg?: SitemapEntryAvgAggregateInputType
    _sum?: SitemapEntrySumAggregateInputType
    _min?: SitemapEntryMinAggregateInputType
    _max?: SitemapEntryMaxAggregateInputType
  }

  export type SitemapEntryGroupByOutputType = {
    id: string
    url: string
    lastMod: Date
    changeFreq: $Enums.ChangeFrequency
    priority: number
    postId: string | null
    included: boolean
    createdAt: Date
    updatedAt: Date
    _count: SitemapEntryCountAggregateOutputType | null
    _avg: SitemapEntryAvgAggregateOutputType | null
    _sum: SitemapEntrySumAggregateOutputType | null
    _min: SitemapEntryMinAggregateOutputType | null
    _max: SitemapEntryMaxAggregateOutputType | null
  }

  type GetSitemapEntryGroupByPayload<T extends SitemapEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SitemapEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SitemapEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SitemapEntryGroupByOutputType[P]>
            : GetScalarType<T[P], SitemapEntryGroupByOutputType[P]>
        }
      >
    >


  export type SitemapEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    lastMod?: boolean
    changeFreq?: boolean
    priority?: boolean
    postId?: boolean
    included?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    post?: boolean | SitemapEntry$postArgs<ExtArgs>
  }, ExtArgs["result"]["sitemapEntry"]>

  export type SitemapEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    lastMod?: boolean
    changeFreq?: boolean
    priority?: boolean
    postId?: boolean
    included?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    post?: boolean | SitemapEntry$postArgs<ExtArgs>
  }, ExtArgs["result"]["sitemapEntry"]>

  export type SitemapEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    lastMod?: boolean
    changeFreq?: boolean
    priority?: boolean
    postId?: boolean
    included?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    post?: boolean | SitemapEntry$postArgs<ExtArgs>
  }, ExtArgs["result"]["sitemapEntry"]>

  export type SitemapEntrySelectScalar = {
    id?: boolean
    url?: boolean
    lastMod?: boolean
    changeFreq?: boolean
    priority?: boolean
    postId?: boolean
    included?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SitemapEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "lastMod" | "changeFreq" | "priority" | "postId" | "included" | "createdAt" | "updatedAt", ExtArgs["result"]["sitemapEntry"]>
  export type SitemapEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | SitemapEntry$postArgs<ExtArgs>
  }
  export type SitemapEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | SitemapEntry$postArgs<ExtArgs>
  }
  export type SitemapEntryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | SitemapEntry$postArgs<ExtArgs>
  }

  export type $SitemapEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SitemapEntry"
    objects: {
      post: Prisma.$BlogPostPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string
      lastMod: Date
      changeFreq: $Enums.ChangeFrequency
      priority: number
      postId: string | null
      included: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sitemapEntry"]>
    composites: {}
  }

  type SitemapEntryGetPayload<S extends boolean | null | undefined | SitemapEntryDefaultArgs> = $Result.GetResult<Prisma.$SitemapEntryPayload, S>

  type SitemapEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SitemapEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SitemapEntryCountAggregateInputType | true
    }

  export interface SitemapEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SitemapEntry'], meta: { name: 'SitemapEntry' } }
    /**
     * Find zero or one SitemapEntry that matches the filter.
     * @param {SitemapEntryFindUniqueArgs} args - Arguments to find a SitemapEntry
     * @example
     * // Get one SitemapEntry
     * const sitemapEntry = await prisma.sitemapEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SitemapEntryFindUniqueArgs>(args: SelectSubset<T, SitemapEntryFindUniqueArgs<ExtArgs>>): Prisma__SitemapEntryClient<$Result.GetResult<Prisma.$SitemapEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SitemapEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SitemapEntryFindUniqueOrThrowArgs} args - Arguments to find a SitemapEntry
     * @example
     * // Get one SitemapEntry
     * const sitemapEntry = await prisma.sitemapEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SitemapEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, SitemapEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SitemapEntryClient<$Result.GetResult<Prisma.$SitemapEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SitemapEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SitemapEntryFindFirstArgs} args - Arguments to find a SitemapEntry
     * @example
     * // Get one SitemapEntry
     * const sitemapEntry = await prisma.sitemapEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SitemapEntryFindFirstArgs>(args?: SelectSubset<T, SitemapEntryFindFirstArgs<ExtArgs>>): Prisma__SitemapEntryClient<$Result.GetResult<Prisma.$SitemapEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SitemapEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SitemapEntryFindFirstOrThrowArgs} args - Arguments to find a SitemapEntry
     * @example
     * // Get one SitemapEntry
     * const sitemapEntry = await prisma.sitemapEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SitemapEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, SitemapEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__SitemapEntryClient<$Result.GetResult<Prisma.$SitemapEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SitemapEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SitemapEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SitemapEntries
     * const sitemapEntries = await prisma.sitemapEntry.findMany()
     * 
     * // Get first 10 SitemapEntries
     * const sitemapEntries = await prisma.sitemapEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sitemapEntryWithIdOnly = await prisma.sitemapEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SitemapEntryFindManyArgs>(args?: SelectSubset<T, SitemapEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SitemapEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SitemapEntry.
     * @param {SitemapEntryCreateArgs} args - Arguments to create a SitemapEntry.
     * @example
     * // Create one SitemapEntry
     * const SitemapEntry = await prisma.sitemapEntry.create({
     *   data: {
     *     // ... data to create a SitemapEntry
     *   }
     * })
     * 
     */
    create<T extends SitemapEntryCreateArgs>(args: SelectSubset<T, SitemapEntryCreateArgs<ExtArgs>>): Prisma__SitemapEntryClient<$Result.GetResult<Prisma.$SitemapEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SitemapEntries.
     * @param {SitemapEntryCreateManyArgs} args - Arguments to create many SitemapEntries.
     * @example
     * // Create many SitemapEntries
     * const sitemapEntry = await prisma.sitemapEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SitemapEntryCreateManyArgs>(args?: SelectSubset<T, SitemapEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SitemapEntries and returns the data saved in the database.
     * @param {SitemapEntryCreateManyAndReturnArgs} args - Arguments to create many SitemapEntries.
     * @example
     * // Create many SitemapEntries
     * const sitemapEntry = await prisma.sitemapEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SitemapEntries and only return the `id`
     * const sitemapEntryWithIdOnly = await prisma.sitemapEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SitemapEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, SitemapEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SitemapEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SitemapEntry.
     * @param {SitemapEntryDeleteArgs} args - Arguments to delete one SitemapEntry.
     * @example
     * // Delete one SitemapEntry
     * const SitemapEntry = await prisma.sitemapEntry.delete({
     *   where: {
     *     // ... filter to delete one SitemapEntry
     *   }
     * })
     * 
     */
    delete<T extends SitemapEntryDeleteArgs>(args: SelectSubset<T, SitemapEntryDeleteArgs<ExtArgs>>): Prisma__SitemapEntryClient<$Result.GetResult<Prisma.$SitemapEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SitemapEntry.
     * @param {SitemapEntryUpdateArgs} args - Arguments to update one SitemapEntry.
     * @example
     * // Update one SitemapEntry
     * const sitemapEntry = await prisma.sitemapEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SitemapEntryUpdateArgs>(args: SelectSubset<T, SitemapEntryUpdateArgs<ExtArgs>>): Prisma__SitemapEntryClient<$Result.GetResult<Prisma.$SitemapEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SitemapEntries.
     * @param {SitemapEntryDeleteManyArgs} args - Arguments to filter SitemapEntries to delete.
     * @example
     * // Delete a few SitemapEntries
     * const { count } = await prisma.sitemapEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SitemapEntryDeleteManyArgs>(args?: SelectSubset<T, SitemapEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SitemapEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SitemapEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SitemapEntries
     * const sitemapEntry = await prisma.sitemapEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SitemapEntryUpdateManyArgs>(args: SelectSubset<T, SitemapEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SitemapEntries and returns the data updated in the database.
     * @param {SitemapEntryUpdateManyAndReturnArgs} args - Arguments to update many SitemapEntries.
     * @example
     * // Update many SitemapEntries
     * const sitemapEntry = await prisma.sitemapEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SitemapEntries and only return the `id`
     * const sitemapEntryWithIdOnly = await prisma.sitemapEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SitemapEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, SitemapEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SitemapEntryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SitemapEntry.
     * @param {SitemapEntryUpsertArgs} args - Arguments to update or create a SitemapEntry.
     * @example
     * // Update or create a SitemapEntry
     * const sitemapEntry = await prisma.sitemapEntry.upsert({
     *   create: {
     *     // ... data to create a SitemapEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SitemapEntry we want to update
     *   }
     * })
     */
    upsert<T extends SitemapEntryUpsertArgs>(args: SelectSubset<T, SitemapEntryUpsertArgs<ExtArgs>>): Prisma__SitemapEntryClient<$Result.GetResult<Prisma.$SitemapEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SitemapEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SitemapEntryCountArgs} args - Arguments to filter SitemapEntries to count.
     * @example
     * // Count the number of SitemapEntries
     * const count = await prisma.sitemapEntry.count({
     *   where: {
     *     // ... the filter for the SitemapEntries we want to count
     *   }
     * })
    **/
    count<T extends SitemapEntryCountArgs>(
      args?: Subset<T, SitemapEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SitemapEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SitemapEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SitemapEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SitemapEntryAggregateArgs>(args: Subset<T, SitemapEntryAggregateArgs>): Prisma.PrismaPromise<GetSitemapEntryAggregateType<T>>

    /**
     * Group by SitemapEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SitemapEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SitemapEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SitemapEntryGroupByArgs['orderBy'] }
        : { orderBy?: SitemapEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SitemapEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSitemapEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SitemapEntry model
   */
  readonly fields: SitemapEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SitemapEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SitemapEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends SitemapEntry$postArgs<ExtArgs> = {}>(args?: Subset<T, SitemapEntry$postArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SitemapEntry model
   */
  interface SitemapEntryFieldRefs {
    readonly id: FieldRef<"SitemapEntry", 'String'>
    readonly url: FieldRef<"SitemapEntry", 'String'>
    readonly lastMod: FieldRef<"SitemapEntry", 'DateTime'>
    readonly changeFreq: FieldRef<"SitemapEntry", 'ChangeFrequency'>
    readonly priority: FieldRef<"SitemapEntry", 'Float'>
    readonly postId: FieldRef<"SitemapEntry", 'String'>
    readonly included: FieldRef<"SitemapEntry", 'Boolean'>
    readonly createdAt: FieldRef<"SitemapEntry", 'DateTime'>
    readonly updatedAt: FieldRef<"SitemapEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SitemapEntry findUnique
   */
  export type SitemapEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SitemapEntry
     */
    select?: SitemapEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SitemapEntry
     */
    omit?: SitemapEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SitemapEntryInclude<ExtArgs> | null
    /**
     * Filter, which SitemapEntry to fetch.
     */
    where: SitemapEntryWhereUniqueInput
  }

  /**
   * SitemapEntry findUniqueOrThrow
   */
  export type SitemapEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SitemapEntry
     */
    select?: SitemapEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SitemapEntry
     */
    omit?: SitemapEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SitemapEntryInclude<ExtArgs> | null
    /**
     * Filter, which SitemapEntry to fetch.
     */
    where: SitemapEntryWhereUniqueInput
  }

  /**
   * SitemapEntry findFirst
   */
  export type SitemapEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SitemapEntry
     */
    select?: SitemapEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SitemapEntry
     */
    omit?: SitemapEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SitemapEntryInclude<ExtArgs> | null
    /**
     * Filter, which SitemapEntry to fetch.
     */
    where?: SitemapEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SitemapEntries to fetch.
     */
    orderBy?: SitemapEntryOrderByWithRelationInput | SitemapEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SitemapEntries.
     */
    cursor?: SitemapEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SitemapEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SitemapEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SitemapEntries.
     */
    distinct?: SitemapEntryScalarFieldEnum | SitemapEntryScalarFieldEnum[]
  }

  /**
   * SitemapEntry findFirstOrThrow
   */
  export type SitemapEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SitemapEntry
     */
    select?: SitemapEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SitemapEntry
     */
    omit?: SitemapEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SitemapEntryInclude<ExtArgs> | null
    /**
     * Filter, which SitemapEntry to fetch.
     */
    where?: SitemapEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SitemapEntries to fetch.
     */
    orderBy?: SitemapEntryOrderByWithRelationInput | SitemapEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SitemapEntries.
     */
    cursor?: SitemapEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SitemapEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SitemapEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SitemapEntries.
     */
    distinct?: SitemapEntryScalarFieldEnum | SitemapEntryScalarFieldEnum[]
  }

  /**
   * SitemapEntry findMany
   */
  export type SitemapEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SitemapEntry
     */
    select?: SitemapEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SitemapEntry
     */
    omit?: SitemapEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SitemapEntryInclude<ExtArgs> | null
    /**
     * Filter, which SitemapEntries to fetch.
     */
    where?: SitemapEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SitemapEntries to fetch.
     */
    orderBy?: SitemapEntryOrderByWithRelationInput | SitemapEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SitemapEntries.
     */
    cursor?: SitemapEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SitemapEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SitemapEntries.
     */
    skip?: number
    distinct?: SitemapEntryScalarFieldEnum | SitemapEntryScalarFieldEnum[]
  }

  /**
   * SitemapEntry create
   */
  export type SitemapEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SitemapEntry
     */
    select?: SitemapEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SitemapEntry
     */
    omit?: SitemapEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SitemapEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a SitemapEntry.
     */
    data: XOR<SitemapEntryCreateInput, SitemapEntryUncheckedCreateInput>
  }

  /**
   * SitemapEntry createMany
   */
  export type SitemapEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SitemapEntries.
     */
    data: SitemapEntryCreateManyInput | SitemapEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SitemapEntry createManyAndReturn
   */
  export type SitemapEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SitemapEntry
     */
    select?: SitemapEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SitemapEntry
     */
    omit?: SitemapEntryOmit<ExtArgs> | null
    /**
     * The data used to create many SitemapEntries.
     */
    data: SitemapEntryCreateManyInput | SitemapEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SitemapEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SitemapEntry update
   */
  export type SitemapEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SitemapEntry
     */
    select?: SitemapEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SitemapEntry
     */
    omit?: SitemapEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SitemapEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a SitemapEntry.
     */
    data: XOR<SitemapEntryUpdateInput, SitemapEntryUncheckedUpdateInput>
    /**
     * Choose, which SitemapEntry to update.
     */
    where: SitemapEntryWhereUniqueInput
  }

  /**
   * SitemapEntry updateMany
   */
  export type SitemapEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SitemapEntries.
     */
    data: XOR<SitemapEntryUpdateManyMutationInput, SitemapEntryUncheckedUpdateManyInput>
    /**
     * Filter which SitemapEntries to update
     */
    where?: SitemapEntryWhereInput
    /**
     * Limit how many SitemapEntries to update.
     */
    limit?: number
  }

  /**
   * SitemapEntry updateManyAndReturn
   */
  export type SitemapEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SitemapEntry
     */
    select?: SitemapEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SitemapEntry
     */
    omit?: SitemapEntryOmit<ExtArgs> | null
    /**
     * The data used to update SitemapEntries.
     */
    data: XOR<SitemapEntryUpdateManyMutationInput, SitemapEntryUncheckedUpdateManyInput>
    /**
     * Filter which SitemapEntries to update
     */
    where?: SitemapEntryWhereInput
    /**
     * Limit how many SitemapEntries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SitemapEntryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SitemapEntry upsert
   */
  export type SitemapEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SitemapEntry
     */
    select?: SitemapEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SitemapEntry
     */
    omit?: SitemapEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SitemapEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the SitemapEntry to update in case it exists.
     */
    where: SitemapEntryWhereUniqueInput
    /**
     * In case the SitemapEntry found by the `where` argument doesn't exist, create a new SitemapEntry with this data.
     */
    create: XOR<SitemapEntryCreateInput, SitemapEntryUncheckedCreateInput>
    /**
     * In case the SitemapEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SitemapEntryUpdateInput, SitemapEntryUncheckedUpdateInput>
  }

  /**
   * SitemapEntry delete
   */
  export type SitemapEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SitemapEntry
     */
    select?: SitemapEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SitemapEntry
     */
    omit?: SitemapEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SitemapEntryInclude<ExtArgs> | null
    /**
     * Filter which SitemapEntry to delete.
     */
    where: SitemapEntryWhereUniqueInput
  }

  /**
   * SitemapEntry deleteMany
   */
  export type SitemapEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SitemapEntries to delete
     */
    where?: SitemapEntryWhereInput
    /**
     * Limit how many SitemapEntries to delete.
     */
    limit?: number
  }

  /**
   * SitemapEntry.post
   */
  export type SitemapEntry$postArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    where?: BlogPostWhereInput
  }

  /**
   * SitemapEntry without action
   */
  export type SitemapEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SitemapEntry
     */
    select?: SitemapEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SitemapEntry
     */
    omit?: SitemapEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SitemapEntryInclude<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectAvgAggregateOutputType = {
    year: number | null
    viewCount: number | null
    clickCount: number | null
  }

  export type ProjectSumAggregateOutputType = {
    year: number | null
    viewCount: number | null
    clickCount: number | null
  }

  export type ProjectMinAggregateOutputType = {
    id: string | null
    slug: string | null
    title: string | null
    description: string | null
    longDescription: string | null
    content: string | null
    image: string | null
    link: string | null
    github: string | null
    category: string | null
    featured: boolean | null
    client: string | null
    role: string | null
    duration: string | null
    year: number | null
    caseStudyUrl: string | null
    viewCount: number | null
    clickCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    title: string | null
    description: string | null
    longDescription: string | null
    content: string | null
    image: string | null
    link: string | null
    github: string | null
    category: string | null
    featured: boolean | null
    client: string | null
    role: string | null
    duration: string | null
    year: number | null
    caseStudyUrl: string | null
    viewCount: number | null
    clickCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    slug: number
    title: number
    description: number
    longDescription: number
    content: number
    image: number
    link: number
    github: number
    category: number
    tags: number
    featured: number
    client: number
    role: number
    duration: number
    year: number
    caseStudyUrl: number
    impact: number
    results: number
    displayMetrics: number
    metrics: number
    testimonial: number
    gallery: number
    details: number
    charts: number
    viewCount: number
    clickCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectAvgAggregateInputType = {
    year?: true
    viewCount?: true
    clickCount?: true
  }

  export type ProjectSumAggregateInputType = {
    year?: true
    viewCount?: true
    clickCount?: true
  }

  export type ProjectMinAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    description?: true
    longDescription?: true
    content?: true
    image?: true
    link?: true
    github?: true
    category?: true
    featured?: true
    client?: true
    role?: true
    duration?: true
    year?: true
    caseStudyUrl?: true
    viewCount?: true
    clickCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    description?: true
    longDescription?: true
    content?: true
    image?: true
    link?: true
    github?: true
    category?: true
    featured?: true
    client?: true
    role?: true
    duration?: true
    year?: true
    caseStudyUrl?: true
    viewCount?: true
    clickCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    description?: true
    longDescription?: true
    content?: true
    image?: true
    link?: true
    github?: true
    category?: true
    tags?: true
    featured?: true
    client?: true
    role?: true
    duration?: true
    year?: true
    caseStudyUrl?: true
    impact?: true
    results?: true
    displayMetrics?: true
    metrics?: true
    testimonial?: true
    gallery?: true
    details?: true
    charts?: true
    viewCount?: true
    clickCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _avg?: ProjectAvgAggregateInputType
    _sum?: ProjectSumAggregateInputType
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: string
    slug: string
    title: string
    description: string
    longDescription: string | null
    content: string | null
    image: string
    link: string | null
    github: string | null
    category: string
    tags: string[]
    featured: boolean
    client: string | null
    role: string | null
    duration: string | null
    year: number | null
    caseStudyUrl: string | null
    impact: JsonValue | null
    results: JsonValue | null
    displayMetrics: JsonValue | null
    metrics: JsonValue | null
    testimonial: JsonValue | null
    gallery: JsonValue | null
    details: JsonValue | null
    charts: JsonValue | null
    viewCount: number
    clickCount: number
    createdAt: Date
    updatedAt: Date
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    description?: boolean
    longDescription?: boolean
    content?: boolean
    image?: boolean
    link?: boolean
    github?: boolean
    category?: boolean
    tags?: boolean
    featured?: boolean
    client?: boolean
    role?: boolean
    duration?: boolean
    year?: boolean
    caseStudyUrl?: boolean
    impact?: boolean
    results?: boolean
    displayMetrics?: boolean
    metrics?: boolean
    testimonial?: boolean
    gallery?: boolean
    details?: boolean
    charts?: boolean
    viewCount?: boolean
    clickCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    description?: boolean
    longDescription?: boolean
    content?: boolean
    image?: boolean
    link?: boolean
    github?: boolean
    category?: boolean
    tags?: boolean
    featured?: boolean
    client?: boolean
    role?: boolean
    duration?: boolean
    year?: boolean
    caseStudyUrl?: boolean
    impact?: boolean
    results?: boolean
    displayMetrics?: boolean
    metrics?: boolean
    testimonial?: boolean
    gallery?: boolean
    details?: boolean
    charts?: boolean
    viewCount?: boolean
    clickCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    description?: boolean
    longDescription?: boolean
    content?: boolean
    image?: boolean
    link?: boolean
    github?: boolean
    category?: boolean
    tags?: boolean
    featured?: boolean
    client?: boolean
    role?: boolean
    duration?: boolean
    year?: boolean
    caseStudyUrl?: boolean
    impact?: boolean
    results?: boolean
    displayMetrics?: boolean
    metrics?: boolean
    testimonial?: boolean
    gallery?: boolean
    details?: boolean
    charts?: boolean
    viewCount?: boolean
    clickCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    slug?: boolean
    title?: boolean
    description?: boolean
    longDescription?: boolean
    content?: boolean
    image?: boolean
    link?: boolean
    github?: boolean
    category?: boolean
    tags?: boolean
    featured?: boolean
    client?: boolean
    role?: boolean
    duration?: boolean
    year?: boolean
    caseStudyUrl?: boolean
    impact?: boolean
    results?: boolean
    displayMetrics?: boolean
    metrics?: boolean
    testimonial?: boolean
    gallery?: boolean
    details?: boolean
    charts?: boolean
    viewCount?: boolean
    clickCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slug" | "title" | "description" | "longDescription" | "content" | "image" | "link" | "github" | "category" | "tags" | "featured" | "client" | "role" | "duration" | "year" | "caseStudyUrl" | "impact" | "results" | "displayMetrics" | "metrics" | "testimonial" | "gallery" | "details" | "charts" | "viewCount" | "clickCount" | "createdAt" | "updatedAt", ExtArgs["result"]["project"]>

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string
      title: string
      description: string
      longDescription: string | null
      content: string | null
      image: string
      link: string | null
      github: string | null
      category: string
      tags: string[]
      featured: boolean
      client: string | null
      role: string | null
      duration: string | null
      year: number | null
      caseStudyUrl: string | null
      impact: Prisma.JsonValue | null
      results: Prisma.JsonValue | null
      displayMetrics: Prisma.JsonValue | null
      metrics: Prisma.JsonValue | null
      testimonial: Prisma.JsonValue | null
      gallery: Prisma.JsonValue | null
      details: Prisma.JsonValue | null
      charts: Prisma.JsonValue | null
      viewCount: number
      clickCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects and returns the data updated in the database.
     * @param {ProjectUpdateManyAndReturnArgs} args - Arguments to update many Projects.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'String'>
    readonly slug: FieldRef<"Project", 'String'>
    readonly title: FieldRef<"Project", 'String'>
    readonly description: FieldRef<"Project", 'String'>
    readonly longDescription: FieldRef<"Project", 'String'>
    readonly content: FieldRef<"Project", 'String'>
    readonly image: FieldRef<"Project", 'String'>
    readonly link: FieldRef<"Project", 'String'>
    readonly github: FieldRef<"Project", 'String'>
    readonly category: FieldRef<"Project", 'String'>
    readonly tags: FieldRef<"Project", 'String[]'>
    readonly featured: FieldRef<"Project", 'Boolean'>
    readonly client: FieldRef<"Project", 'String'>
    readonly role: FieldRef<"Project", 'String'>
    readonly duration: FieldRef<"Project", 'String'>
    readonly year: FieldRef<"Project", 'Int'>
    readonly caseStudyUrl: FieldRef<"Project", 'String'>
    readonly impact: FieldRef<"Project", 'Json'>
    readonly results: FieldRef<"Project", 'Json'>
    readonly displayMetrics: FieldRef<"Project", 'Json'>
    readonly metrics: FieldRef<"Project", 'Json'>
    readonly testimonial: FieldRef<"Project", 'Json'>
    readonly gallery: FieldRef<"Project", 'Json'>
    readonly details: FieldRef<"Project", 'Json'>
    readonly charts: FieldRef<"Project", 'Json'>
    readonly viewCount: FieldRef<"Project", 'Int'>
    readonly clickCount: FieldRef<"Project", 'Int'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly updatedAt: FieldRef<"Project", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
  }

  /**
   * Project updateManyAndReturn
   */
  export type ProjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to delete.
     */
    limit?: number
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
  }


  /**
   * Model ContactSubmission
   */

  export type AggregateContactSubmission = {
    _count: ContactSubmissionCountAggregateOutputType | null
    _min: ContactSubmissionMinAggregateOutputType | null
    _max: ContactSubmissionMaxAggregateOutputType | null
  }

  export type ContactSubmissionMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    company: string | null
    phone: string | null
    subject: string | null
    message: string | null
    status: $Enums.SubmissionStatus | null
    responded: boolean | null
    respondedAt: Date | null
    notes: string | null
    ipAddress: string | null
    userAgent: string | null
    referer: string | null
    emailSent: boolean | null
    emailId: string | null
    emailError: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactSubmissionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    company: string | null
    phone: string | null
    subject: string | null
    message: string | null
    status: $Enums.SubmissionStatus | null
    responded: boolean | null
    respondedAt: Date | null
    notes: string | null
    ipAddress: string | null
    userAgent: string | null
    referer: string | null
    emailSent: boolean | null
    emailId: string | null
    emailError: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactSubmissionCountAggregateOutputType = {
    id: number
    name: number
    email: number
    company: number
    phone: number
    subject: number
    message: number
    status: number
    responded: number
    respondedAt: number
    notes: number
    ipAddress: number
    userAgent: number
    referer: number
    emailSent: number
    emailId: number
    emailError: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContactSubmissionMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    company?: true
    phone?: true
    subject?: true
    message?: true
    status?: true
    responded?: true
    respondedAt?: true
    notes?: true
    ipAddress?: true
    userAgent?: true
    referer?: true
    emailSent?: true
    emailId?: true
    emailError?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactSubmissionMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    company?: true
    phone?: true
    subject?: true
    message?: true
    status?: true
    responded?: true
    respondedAt?: true
    notes?: true
    ipAddress?: true
    userAgent?: true
    referer?: true
    emailSent?: true
    emailId?: true
    emailError?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactSubmissionCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    company?: true
    phone?: true
    subject?: true
    message?: true
    status?: true
    responded?: true
    respondedAt?: true
    notes?: true
    ipAddress?: true
    userAgent?: true
    referer?: true
    emailSent?: true
    emailId?: true
    emailError?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContactSubmissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactSubmission to aggregate.
     */
    where?: ContactSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactSubmissions to fetch.
     */
    orderBy?: ContactSubmissionOrderByWithRelationInput | ContactSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContactSubmissions
    **/
    _count?: true | ContactSubmissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactSubmissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactSubmissionMaxAggregateInputType
  }

  export type GetContactSubmissionAggregateType<T extends ContactSubmissionAggregateArgs> = {
        [P in keyof T & keyof AggregateContactSubmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactSubmission[P]>
      : GetScalarType<T[P], AggregateContactSubmission[P]>
  }




  export type ContactSubmissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactSubmissionWhereInput
    orderBy?: ContactSubmissionOrderByWithAggregationInput | ContactSubmissionOrderByWithAggregationInput[]
    by: ContactSubmissionScalarFieldEnum[] | ContactSubmissionScalarFieldEnum
    having?: ContactSubmissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactSubmissionCountAggregateInputType | true
    _min?: ContactSubmissionMinAggregateInputType
    _max?: ContactSubmissionMaxAggregateInputType
  }

  export type ContactSubmissionGroupByOutputType = {
    id: string
    name: string
    email: string
    company: string | null
    phone: string | null
    subject: string | null
    message: string
    status: $Enums.SubmissionStatus
    responded: boolean
    respondedAt: Date | null
    notes: string | null
    ipAddress: string | null
    userAgent: string | null
    referer: string | null
    emailSent: boolean
    emailId: string | null
    emailError: string | null
    createdAt: Date
    updatedAt: Date
    _count: ContactSubmissionCountAggregateOutputType | null
    _min: ContactSubmissionMinAggregateOutputType | null
    _max: ContactSubmissionMaxAggregateOutputType | null
  }

  type GetContactSubmissionGroupByPayload<T extends ContactSubmissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactSubmissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactSubmissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactSubmissionGroupByOutputType[P]>
            : GetScalarType<T[P], ContactSubmissionGroupByOutputType[P]>
        }
      >
    >


  export type ContactSubmissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    company?: boolean
    phone?: boolean
    subject?: boolean
    message?: boolean
    status?: boolean
    responded?: boolean
    respondedAt?: boolean
    notes?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    referer?: boolean
    emailSent?: boolean
    emailId?: boolean
    emailError?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contactSubmission"]>

  export type ContactSubmissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    company?: boolean
    phone?: boolean
    subject?: boolean
    message?: boolean
    status?: boolean
    responded?: boolean
    respondedAt?: boolean
    notes?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    referer?: boolean
    emailSent?: boolean
    emailId?: boolean
    emailError?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contactSubmission"]>

  export type ContactSubmissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    company?: boolean
    phone?: boolean
    subject?: boolean
    message?: boolean
    status?: boolean
    responded?: boolean
    respondedAt?: boolean
    notes?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    referer?: boolean
    emailSent?: boolean
    emailId?: boolean
    emailError?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contactSubmission"]>

  export type ContactSubmissionSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    company?: boolean
    phone?: boolean
    subject?: boolean
    message?: boolean
    status?: boolean
    responded?: boolean
    respondedAt?: boolean
    notes?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    referer?: boolean
    emailSent?: boolean
    emailId?: boolean
    emailError?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContactSubmissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "company" | "phone" | "subject" | "message" | "status" | "responded" | "respondedAt" | "notes" | "ipAddress" | "userAgent" | "referer" | "emailSent" | "emailId" | "emailError" | "createdAt" | "updatedAt", ExtArgs["result"]["contactSubmission"]>

  export type $ContactSubmissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactSubmission"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      company: string | null
      phone: string | null
      subject: string | null
      message: string
      status: $Enums.SubmissionStatus
      responded: boolean
      respondedAt: Date | null
      notes: string | null
      ipAddress: string | null
      userAgent: string | null
      referer: string | null
      emailSent: boolean
      emailId: string | null
      emailError: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contactSubmission"]>
    composites: {}
  }

  type ContactSubmissionGetPayload<S extends boolean | null | undefined | ContactSubmissionDefaultArgs> = $Result.GetResult<Prisma.$ContactSubmissionPayload, S>

  type ContactSubmissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactSubmissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactSubmissionCountAggregateInputType | true
    }

  export interface ContactSubmissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactSubmission'], meta: { name: 'ContactSubmission' } }
    /**
     * Find zero or one ContactSubmission that matches the filter.
     * @param {ContactSubmissionFindUniqueArgs} args - Arguments to find a ContactSubmission
     * @example
     * // Get one ContactSubmission
     * const contactSubmission = await prisma.contactSubmission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactSubmissionFindUniqueArgs>(args: SelectSubset<T, ContactSubmissionFindUniqueArgs<ExtArgs>>): Prisma__ContactSubmissionClient<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContactSubmission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactSubmissionFindUniqueOrThrowArgs} args - Arguments to find a ContactSubmission
     * @example
     * // Get one ContactSubmission
     * const contactSubmission = await prisma.contactSubmission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactSubmissionFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactSubmissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactSubmissionClient<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactSubmission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactSubmissionFindFirstArgs} args - Arguments to find a ContactSubmission
     * @example
     * // Get one ContactSubmission
     * const contactSubmission = await prisma.contactSubmission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactSubmissionFindFirstArgs>(args?: SelectSubset<T, ContactSubmissionFindFirstArgs<ExtArgs>>): Prisma__ContactSubmissionClient<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactSubmission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactSubmissionFindFirstOrThrowArgs} args - Arguments to find a ContactSubmission
     * @example
     * // Get one ContactSubmission
     * const contactSubmission = await prisma.contactSubmission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactSubmissionFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactSubmissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactSubmissionClient<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContactSubmissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactSubmissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContactSubmissions
     * const contactSubmissions = await prisma.contactSubmission.findMany()
     * 
     * // Get first 10 ContactSubmissions
     * const contactSubmissions = await prisma.contactSubmission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactSubmissionWithIdOnly = await prisma.contactSubmission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactSubmissionFindManyArgs>(args?: SelectSubset<T, ContactSubmissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContactSubmission.
     * @param {ContactSubmissionCreateArgs} args - Arguments to create a ContactSubmission.
     * @example
     * // Create one ContactSubmission
     * const ContactSubmission = await prisma.contactSubmission.create({
     *   data: {
     *     // ... data to create a ContactSubmission
     *   }
     * })
     * 
     */
    create<T extends ContactSubmissionCreateArgs>(args: SelectSubset<T, ContactSubmissionCreateArgs<ExtArgs>>): Prisma__ContactSubmissionClient<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContactSubmissions.
     * @param {ContactSubmissionCreateManyArgs} args - Arguments to create many ContactSubmissions.
     * @example
     * // Create many ContactSubmissions
     * const contactSubmission = await prisma.contactSubmission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactSubmissionCreateManyArgs>(args?: SelectSubset<T, ContactSubmissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContactSubmissions and returns the data saved in the database.
     * @param {ContactSubmissionCreateManyAndReturnArgs} args - Arguments to create many ContactSubmissions.
     * @example
     * // Create many ContactSubmissions
     * const contactSubmission = await prisma.contactSubmission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContactSubmissions and only return the `id`
     * const contactSubmissionWithIdOnly = await prisma.contactSubmission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactSubmissionCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactSubmissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContactSubmission.
     * @param {ContactSubmissionDeleteArgs} args - Arguments to delete one ContactSubmission.
     * @example
     * // Delete one ContactSubmission
     * const ContactSubmission = await prisma.contactSubmission.delete({
     *   where: {
     *     // ... filter to delete one ContactSubmission
     *   }
     * })
     * 
     */
    delete<T extends ContactSubmissionDeleteArgs>(args: SelectSubset<T, ContactSubmissionDeleteArgs<ExtArgs>>): Prisma__ContactSubmissionClient<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContactSubmission.
     * @param {ContactSubmissionUpdateArgs} args - Arguments to update one ContactSubmission.
     * @example
     * // Update one ContactSubmission
     * const contactSubmission = await prisma.contactSubmission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactSubmissionUpdateArgs>(args: SelectSubset<T, ContactSubmissionUpdateArgs<ExtArgs>>): Prisma__ContactSubmissionClient<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContactSubmissions.
     * @param {ContactSubmissionDeleteManyArgs} args - Arguments to filter ContactSubmissions to delete.
     * @example
     * // Delete a few ContactSubmissions
     * const { count } = await prisma.contactSubmission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactSubmissionDeleteManyArgs>(args?: SelectSubset<T, ContactSubmissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactSubmissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContactSubmissions
     * const contactSubmission = await prisma.contactSubmission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactSubmissionUpdateManyArgs>(args: SelectSubset<T, ContactSubmissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactSubmissions and returns the data updated in the database.
     * @param {ContactSubmissionUpdateManyAndReturnArgs} args - Arguments to update many ContactSubmissions.
     * @example
     * // Update many ContactSubmissions
     * const contactSubmission = await prisma.contactSubmission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContactSubmissions and only return the `id`
     * const contactSubmissionWithIdOnly = await prisma.contactSubmission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactSubmissionUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactSubmissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContactSubmission.
     * @param {ContactSubmissionUpsertArgs} args - Arguments to update or create a ContactSubmission.
     * @example
     * // Update or create a ContactSubmission
     * const contactSubmission = await prisma.contactSubmission.upsert({
     *   create: {
     *     // ... data to create a ContactSubmission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactSubmission we want to update
     *   }
     * })
     */
    upsert<T extends ContactSubmissionUpsertArgs>(args: SelectSubset<T, ContactSubmissionUpsertArgs<ExtArgs>>): Prisma__ContactSubmissionClient<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContactSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactSubmissionCountArgs} args - Arguments to filter ContactSubmissions to count.
     * @example
     * // Count the number of ContactSubmissions
     * const count = await prisma.contactSubmission.count({
     *   where: {
     *     // ... the filter for the ContactSubmissions we want to count
     *   }
     * })
    **/
    count<T extends ContactSubmissionCountArgs>(
      args?: Subset<T, ContactSubmissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactSubmissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactSubmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactSubmissionAggregateArgs>(args: Subset<T, ContactSubmissionAggregateArgs>): Prisma.PrismaPromise<GetContactSubmissionAggregateType<T>>

    /**
     * Group by ContactSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactSubmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactSubmissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactSubmissionGroupByArgs['orderBy'] }
        : { orderBy?: ContactSubmissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactSubmissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactSubmissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactSubmission model
   */
  readonly fields: ContactSubmissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactSubmission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactSubmissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContactSubmission model
   */
  interface ContactSubmissionFieldRefs {
    readonly id: FieldRef<"ContactSubmission", 'String'>
    readonly name: FieldRef<"ContactSubmission", 'String'>
    readonly email: FieldRef<"ContactSubmission", 'String'>
    readonly company: FieldRef<"ContactSubmission", 'String'>
    readonly phone: FieldRef<"ContactSubmission", 'String'>
    readonly subject: FieldRef<"ContactSubmission", 'String'>
    readonly message: FieldRef<"ContactSubmission", 'String'>
    readonly status: FieldRef<"ContactSubmission", 'SubmissionStatus'>
    readonly responded: FieldRef<"ContactSubmission", 'Boolean'>
    readonly respondedAt: FieldRef<"ContactSubmission", 'DateTime'>
    readonly notes: FieldRef<"ContactSubmission", 'String'>
    readonly ipAddress: FieldRef<"ContactSubmission", 'String'>
    readonly userAgent: FieldRef<"ContactSubmission", 'String'>
    readonly referer: FieldRef<"ContactSubmission", 'String'>
    readonly emailSent: FieldRef<"ContactSubmission", 'Boolean'>
    readonly emailId: FieldRef<"ContactSubmission", 'String'>
    readonly emailError: FieldRef<"ContactSubmission", 'String'>
    readonly createdAt: FieldRef<"ContactSubmission", 'DateTime'>
    readonly updatedAt: FieldRef<"ContactSubmission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContactSubmission findUnique
   */
  export type ContactSubmissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * Filter, which ContactSubmission to fetch.
     */
    where: ContactSubmissionWhereUniqueInput
  }

  /**
   * ContactSubmission findUniqueOrThrow
   */
  export type ContactSubmissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * Filter, which ContactSubmission to fetch.
     */
    where: ContactSubmissionWhereUniqueInput
  }

  /**
   * ContactSubmission findFirst
   */
  export type ContactSubmissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * Filter, which ContactSubmission to fetch.
     */
    where?: ContactSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactSubmissions to fetch.
     */
    orderBy?: ContactSubmissionOrderByWithRelationInput | ContactSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactSubmissions.
     */
    cursor?: ContactSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactSubmissions.
     */
    distinct?: ContactSubmissionScalarFieldEnum | ContactSubmissionScalarFieldEnum[]
  }

  /**
   * ContactSubmission findFirstOrThrow
   */
  export type ContactSubmissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * Filter, which ContactSubmission to fetch.
     */
    where?: ContactSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactSubmissions to fetch.
     */
    orderBy?: ContactSubmissionOrderByWithRelationInput | ContactSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactSubmissions.
     */
    cursor?: ContactSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactSubmissions.
     */
    distinct?: ContactSubmissionScalarFieldEnum | ContactSubmissionScalarFieldEnum[]
  }

  /**
   * ContactSubmission findMany
   */
  export type ContactSubmissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * Filter, which ContactSubmissions to fetch.
     */
    where?: ContactSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactSubmissions to fetch.
     */
    orderBy?: ContactSubmissionOrderByWithRelationInput | ContactSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContactSubmissions.
     */
    cursor?: ContactSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactSubmissions.
     */
    skip?: number
    distinct?: ContactSubmissionScalarFieldEnum | ContactSubmissionScalarFieldEnum[]
  }

  /**
   * ContactSubmission create
   */
  export type ContactSubmissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * The data needed to create a ContactSubmission.
     */
    data: XOR<ContactSubmissionCreateInput, ContactSubmissionUncheckedCreateInput>
  }

  /**
   * ContactSubmission createMany
   */
  export type ContactSubmissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContactSubmissions.
     */
    data: ContactSubmissionCreateManyInput | ContactSubmissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactSubmission createManyAndReturn
   */
  export type ContactSubmissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * The data used to create many ContactSubmissions.
     */
    data: ContactSubmissionCreateManyInput | ContactSubmissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactSubmission update
   */
  export type ContactSubmissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * The data needed to update a ContactSubmission.
     */
    data: XOR<ContactSubmissionUpdateInput, ContactSubmissionUncheckedUpdateInput>
    /**
     * Choose, which ContactSubmission to update.
     */
    where: ContactSubmissionWhereUniqueInput
  }

  /**
   * ContactSubmission updateMany
   */
  export type ContactSubmissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContactSubmissions.
     */
    data: XOR<ContactSubmissionUpdateManyMutationInput, ContactSubmissionUncheckedUpdateManyInput>
    /**
     * Filter which ContactSubmissions to update
     */
    where?: ContactSubmissionWhereInput
    /**
     * Limit how many ContactSubmissions to update.
     */
    limit?: number
  }

  /**
   * ContactSubmission updateManyAndReturn
   */
  export type ContactSubmissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * The data used to update ContactSubmissions.
     */
    data: XOR<ContactSubmissionUpdateManyMutationInput, ContactSubmissionUncheckedUpdateManyInput>
    /**
     * Filter which ContactSubmissions to update
     */
    where?: ContactSubmissionWhereInput
    /**
     * Limit how many ContactSubmissions to update.
     */
    limit?: number
  }

  /**
   * ContactSubmission upsert
   */
  export type ContactSubmissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * The filter to search for the ContactSubmission to update in case it exists.
     */
    where: ContactSubmissionWhereUniqueInput
    /**
     * In case the ContactSubmission found by the `where` argument doesn't exist, create a new ContactSubmission with this data.
     */
    create: XOR<ContactSubmissionCreateInput, ContactSubmissionUncheckedCreateInput>
    /**
     * In case the ContactSubmission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactSubmissionUpdateInput, ContactSubmissionUncheckedUpdateInput>
  }

  /**
   * ContactSubmission delete
   */
  export type ContactSubmissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * Filter which ContactSubmission to delete.
     */
    where: ContactSubmissionWhereUniqueInput
  }

  /**
   * ContactSubmission deleteMany
   */
  export type ContactSubmissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactSubmissions to delete
     */
    where?: ContactSubmissionWhereInput
    /**
     * Limit how many ContactSubmissions to delete.
     */
    limit?: number
  }

  /**
   * ContactSubmission without action
   */
  export type ContactSubmissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
  }


  /**
   * Model SecurityEvent
   */

  export type AggregateSecurityEvent = {
    _count: SecurityEventCountAggregateOutputType | null
    _min: SecurityEventMinAggregateOutputType | null
    _max: SecurityEventMaxAggregateOutputType | null
  }

  export type SecurityEventMinAggregateOutputType = {
    id: string | null
    type: $Enums.SecurityEventType | null
    severity: $Enums.SecuritySeverity | null
    message: string | null
    ipAddress: string | null
    userAgent: string | null
    path: string | null
    method: string | null
    clientId: string | null
    sessionId: string | null
    acknowledged: boolean | null
    acknowledgedAt: Date | null
    acknowledgedBy: string | null
    createdAt: Date | null
  }

  export type SecurityEventMaxAggregateOutputType = {
    id: string | null
    type: $Enums.SecurityEventType | null
    severity: $Enums.SecuritySeverity | null
    message: string | null
    ipAddress: string | null
    userAgent: string | null
    path: string | null
    method: string | null
    clientId: string | null
    sessionId: string | null
    acknowledged: boolean | null
    acknowledgedAt: Date | null
    acknowledgedBy: string | null
    createdAt: Date | null
  }

  export type SecurityEventCountAggregateOutputType = {
    id: number
    type: number
    severity: number
    message: number
    details: number
    ipAddress: number
    userAgent: number
    path: number
    method: number
    clientId: number
    sessionId: number
    acknowledged: number
    acknowledgedAt: number
    acknowledgedBy: number
    createdAt: number
    _all: number
  }


  export type SecurityEventMinAggregateInputType = {
    id?: true
    type?: true
    severity?: true
    message?: true
    ipAddress?: true
    userAgent?: true
    path?: true
    method?: true
    clientId?: true
    sessionId?: true
    acknowledged?: true
    acknowledgedAt?: true
    acknowledgedBy?: true
    createdAt?: true
  }

  export type SecurityEventMaxAggregateInputType = {
    id?: true
    type?: true
    severity?: true
    message?: true
    ipAddress?: true
    userAgent?: true
    path?: true
    method?: true
    clientId?: true
    sessionId?: true
    acknowledged?: true
    acknowledgedAt?: true
    acknowledgedBy?: true
    createdAt?: true
  }

  export type SecurityEventCountAggregateInputType = {
    id?: true
    type?: true
    severity?: true
    message?: true
    details?: true
    ipAddress?: true
    userAgent?: true
    path?: true
    method?: true
    clientId?: true
    sessionId?: true
    acknowledged?: true
    acknowledgedAt?: true
    acknowledgedBy?: true
    createdAt?: true
    _all?: true
  }

  export type SecurityEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SecurityEvent to aggregate.
     */
    where?: SecurityEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityEvents to fetch.
     */
    orderBy?: SecurityEventOrderByWithRelationInput | SecurityEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SecurityEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SecurityEvents
    **/
    _count?: true | SecurityEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SecurityEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SecurityEventMaxAggregateInputType
  }

  export type GetSecurityEventAggregateType<T extends SecurityEventAggregateArgs> = {
        [P in keyof T & keyof AggregateSecurityEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSecurityEvent[P]>
      : GetScalarType<T[P], AggregateSecurityEvent[P]>
  }




  export type SecurityEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SecurityEventWhereInput
    orderBy?: SecurityEventOrderByWithAggregationInput | SecurityEventOrderByWithAggregationInput[]
    by: SecurityEventScalarFieldEnum[] | SecurityEventScalarFieldEnum
    having?: SecurityEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SecurityEventCountAggregateInputType | true
    _min?: SecurityEventMinAggregateInputType
    _max?: SecurityEventMaxAggregateInputType
  }

  export type SecurityEventGroupByOutputType = {
    id: string
    type: $Enums.SecurityEventType
    severity: $Enums.SecuritySeverity
    message: string
    details: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    path: string | null
    method: string | null
    clientId: string | null
    sessionId: string | null
    acknowledged: boolean
    acknowledgedAt: Date | null
    acknowledgedBy: string | null
    createdAt: Date
    _count: SecurityEventCountAggregateOutputType | null
    _min: SecurityEventMinAggregateOutputType | null
    _max: SecurityEventMaxAggregateOutputType | null
  }

  type GetSecurityEventGroupByPayload<T extends SecurityEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SecurityEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SecurityEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SecurityEventGroupByOutputType[P]>
            : GetScalarType<T[P], SecurityEventGroupByOutputType[P]>
        }
      >
    >


  export type SecurityEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    severity?: boolean
    message?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    path?: boolean
    method?: boolean
    clientId?: boolean
    sessionId?: boolean
    acknowledged?: boolean
    acknowledgedAt?: boolean
    acknowledgedBy?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["securityEvent"]>

  export type SecurityEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    severity?: boolean
    message?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    path?: boolean
    method?: boolean
    clientId?: boolean
    sessionId?: boolean
    acknowledged?: boolean
    acknowledgedAt?: boolean
    acknowledgedBy?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["securityEvent"]>

  export type SecurityEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    severity?: boolean
    message?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    path?: boolean
    method?: boolean
    clientId?: boolean
    sessionId?: boolean
    acknowledged?: boolean
    acknowledgedAt?: boolean
    acknowledgedBy?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["securityEvent"]>

  export type SecurityEventSelectScalar = {
    id?: boolean
    type?: boolean
    severity?: boolean
    message?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    path?: boolean
    method?: boolean
    clientId?: boolean
    sessionId?: boolean
    acknowledged?: boolean
    acknowledgedAt?: boolean
    acknowledgedBy?: boolean
    createdAt?: boolean
  }

  export type SecurityEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "severity" | "message" | "details" | "ipAddress" | "userAgent" | "path" | "method" | "clientId" | "sessionId" | "acknowledged" | "acknowledgedAt" | "acknowledgedBy" | "createdAt", ExtArgs["result"]["securityEvent"]>

  export type $SecurityEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SecurityEvent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.SecurityEventType
      severity: $Enums.SecuritySeverity
      message: string
      details: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      path: string | null
      method: string | null
      clientId: string | null
      sessionId: string | null
      acknowledged: boolean
      acknowledgedAt: Date | null
      acknowledgedBy: string | null
      createdAt: Date
    }, ExtArgs["result"]["securityEvent"]>
    composites: {}
  }

  type SecurityEventGetPayload<S extends boolean | null | undefined | SecurityEventDefaultArgs> = $Result.GetResult<Prisma.$SecurityEventPayload, S>

  type SecurityEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SecurityEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SecurityEventCountAggregateInputType | true
    }

  export interface SecurityEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SecurityEvent'], meta: { name: 'SecurityEvent' } }
    /**
     * Find zero or one SecurityEvent that matches the filter.
     * @param {SecurityEventFindUniqueArgs} args - Arguments to find a SecurityEvent
     * @example
     * // Get one SecurityEvent
     * const securityEvent = await prisma.securityEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SecurityEventFindUniqueArgs>(args: SelectSubset<T, SecurityEventFindUniqueArgs<ExtArgs>>): Prisma__SecurityEventClient<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SecurityEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SecurityEventFindUniqueOrThrowArgs} args - Arguments to find a SecurityEvent
     * @example
     * // Get one SecurityEvent
     * const securityEvent = await prisma.securityEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SecurityEventFindUniqueOrThrowArgs>(args: SelectSubset<T, SecurityEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SecurityEventClient<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SecurityEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityEventFindFirstArgs} args - Arguments to find a SecurityEvent
     * @example
     * // Get one SecurityEvent
     * const securityEvent = await prisma.securityEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SecurityEventFindFirstArgs>(args?: SelectSubset<T, SecurityEventFindFirstArgs<ExtArgs>>): Prisma__SecurityEventClient<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SecurityEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityEventFindFirstOrThrowArgs} args - Arguments to find a SecurityEvent
     * @example
     * // Get one SecurityEvent
     * const securityEvent = await prisma.securityEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SecurityEventFindFirstOrThrowArgs>(args?: SelectSubset<T, SecurityEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__SecurityEventClient<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SecurityEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SecurityEvents
     * const securityEvents = await prisma.securityEvent.findMany()
     * 
     * // Get first 10 SecurityEvents
     * const securityEvents = await prisma.securityEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const securityEventWithIdOnly = await prisma.securityEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SecurityEventFindManyArgs>(args?: SelectSubset<T, SecurityEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SecurityEvent.
     * @param {SecurityEventCreateArgs} args - Arguments to create a SecurityEvent.
     * @example
     * // Create one SecurityEvent
     * const SecurityEvent = await prisma.securityEvent.create({
     *   data: {
     *     // ... data to create a SecurityEvent
     *   }
     * })
     * 
     */
    create<T extends SecurityEventCreateArgs>(args: SelectSubset<T, SecurityEventCreateArgs<ExtArgs>>): Prisma__SecurityEventClient<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SecurityEvents.
     * @param {SecurityEventCreateManyArgs} args - Arguments to create many SecurityEvents.
     * @example
     * // Create many SecurityEvents
     * const securityEvent = await prisma.securityEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SecurityEventCreateManyArgs>(args?: SelectSubset<T, SecurityEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SecurityEvents and returns the data saved in the database.
     * @param {SecurityEventCreateManyAndReturnArgs} args - Arguments to create many SecurityEvents.
     * @example
     * // Create many SecurityEvents
     * const securityEvent = await prisma.securityEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SecurityEvents and only return the `id`
     * const securityEventWithIdOnly = await prisma.securityEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SecurityEventCreateManyAndReturnArgs>(args?: SelectSubset<T, SecurityEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SecurityEvent.
     * @param {SecurityEventDeleteArgs} args - Arguments to delete one SecurityEvent.
     * @example
     * // Delete one SecurityEvent
     * const SecurityEvent = await prisma.securityEvent.delete({
     *   where: {
     *     // ... filter to delete one SecurityEvent
     *   }
     * })
     * 
     */
    delete<T extends SecurityEventDeleteArgs>(args: SelectSubset<T, SecurityEventDeleteArgs<ExtArgs>>): Prisma__SecurityEventClient<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SecurityEvent.
     * @param {SecurityEventUpdateArgs} args - Arguments to update one SecurityEvent.
     * @example
     * // Update one SecurityEvent
     * const securityEvent = await prisma.securityEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SecurityEventUpdateArgs>(args: SelectSubset<T, SecurityEventUpdateArgs<ExtArgs>>): Prisma__SecurityEventClient<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SecurityEvents.
     * @param {SecurityEventDeleteManyArgs} args - Arguments to filter SecurityEvents to delete.
     * @example
     * // Delete a few SecurityEvents
     * const { count } = await prisma.securityEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SecurityEventDeleteManyArgs>(args?: SelectSubset<T, SecurityEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SecurityEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SecurityEvents
     * const securityEvent = await prisma.securityEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SecurityEventUpdateManyArgs>(args: SelectSubset<T, SecurityEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SecurityEvents and returns the data updated in the database.
     * @param {SecurityEventUpdateManyAndReturnArgs} args - Arguments to update many SecurityEvents.
     * @example
     * // Update many SecurityEvents
     * const securityEvent = await prisma.securityEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SecurityEvents and only return the `id`
     * const securityEventWithIdOnly = await prisma.securityEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SecurityEventUpdateManyAndReturnArgs>(args: SelectSubset<T, SecurityEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SecurityEvent.
     * @param {SecurityEventUpsertArgs} args - Arguments to update or create a SecurityEvent.
     * @example
     * // Update or create a SecurityEvent
     * const securityEvent = await prisma.securityEvent.upsert({
     *   create: {
     *     // ... data to create a SecurityEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SecurityEvent we want to update
     *   }
     * })
     */
    upsert<T extends SecurityEventUpsertArgs>(args: SelectSubset<T, SecurityEventUpsertArgs<ExtArgs>>): Prisma__SecurityEventClient<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SecurityEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityEventCountArgs} args - Arguments to filter SecurityEvents to count.
     * @example
     * // Count the number of SecurityEvents
     * const count = await prisma.securityEvent.count({
     *   where: {
     *     // ... the filter for the SecurityEvents we want to count
     *   }
     * })
    **/
    count<T extends SecurityEventCountArgs>(
      args?: Subset<T, SecurityEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SecurityEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SecurityEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SecurityEventAggregateArgs>(args: Subset<T, SecurityEventAggregateArgs>): Prisma.PrismaPromise<GetSecurityEventAggregateType<T>>

    /**
     * Group by SecurityEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SecurityEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SecurityEventGroupByArgs['orderBy'] }
        : { orderBy?: SecurityEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SecurityEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSecurityEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SecurityEvent model
   */
  readonly fields: SecurityEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SecurityEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SecurityEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SecurityEvent model
   */
  interface SecurityEventFieldRefs {
    readonly id: FieldRef<"SecurityEvent", 'String'>
    readonly type: FieldRef<"SecurityEvent", 'SecurityEventType'>
    readonly severity: FieldRef<"SecurityEvent", 'SecuritySeverity'>
    readonly message: FieldRef<"SecurityEvent", 'String'>
    readonly details: FieldRef<"SecurityEvent", 'Json'>
    readonly ipAddress: FieldRef<"SecurityEvent", 'String'>
    readonly userAgent: FieldRef<"SecurityEvent", 'String'>
    readonly path: FieldRef<"SecurityEvent", 'String'>
    readonly method: FieldRef<"SecurityEvent", 'String'>
    readonly clientId: FieldRef<"SecurityEvent", 'String'>
    readonly sessionId: FieldRef<"SecurityEvent", 'String'>
    readonly acknowledged: FieldRef<"SecurityEvent", 'Boolean'>
    readonly acknowledgedAt: FieldRef<"SecurityEvent", 'DateTime'>
    readonly acknowledgedBy: FieldRef<"SecurityEvent", 'String'>
    readonly createdAt: FieldRef<"SecurityEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SecurityEvent findUnique
   */
  export type SecurityEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityEvent
     */
    omit?: SecurityEventOmit<ExtArgs> | null
    /**
     * Filter, which SecurityEvent to fetch.
     */
    where: SecurityEventWhereUniqueInput
  }

  /**
   * SecurityEvent findUniqueOrThrow
   */
  export type SecurityEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityEvent
     */
    omit?: SecurityEventOmit<ExtArgs> | null
    /**
     * Filter, which SecurityEvent to fetch.
     */
    where: SecurityEventWhereUniqueInput
  }

  /**
   * SecurityEvent findFirst
   */
  export type SecurityEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityEvent
     */
    omit?: SecurityEventOmit<ExtArgs> | null
    /**
     * Filter, which SecurityEvent to fetch.
     */
    where?: SecurityEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityEvents to fetch.
     */
    orderBy?: SecurityEventOrderByWithRelationInput | SecurityEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecurityEvents.
     */
    cursor?: SecurityEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecurityEvents.
     */
    distinct?: SecurityEventScalarFieldEnum | SecurityEventScalarFieldEnum[]
  }

  /**
   * SecurityEvent findFirstOrThrow
   */
  export type SecurityEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityEvent
     */
    omit?: SecurityEventOmit<ExtArgs> | null
    /**
     * Filter, which SecurityEvent to fetch.
     */
    where?: SecurityEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityEvents to fetch.
     */
    orderBy?: SecurityEventOrderByWithRelationInput | SecurityEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecurityEvents.
     */
    cursor?: SecurityEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecurityEvents.
     */
    distinct?: SecurityEventScalarFieldEnum | SecurityEventScalarFieldEnum[]
  }

  /**
   * SecurityEvent findMany
   */
  export type SecurityEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityEvent
     */
    omit?: SecurityEventOmit<ExtArgs> | null
    /**
     * Filter, which SecurityEvents to fetch.
     */
    where?: SecurityEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityEvents to fetch.
     */
    orderBy?: SecurityEventOrderByWithRelationInput | SecurityEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SecurityEvents.
     */
    cursor?: SecurityEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityEvents.
     */
    skip?: number
    distinct?: SecurityEventScalarFieldEnum | SecurityEventScalarFieldEnum[]
  }

  /**
   * SecurityEvent create
   */
  export type SecurityEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityEvent
     */
    omit?: SecurityEventOmit<ExtArgs> | null
    /**
     * The data needed to create a SecurityEvent.
     */
    data: XOR<SecurityEventCreateInput, SecurityEventUncheckedCreateInput>
  }

  /**
   * SecurityEvent createMany
   */
  export type SecurityEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SecurityEvents.
     */
    data: SecurityEventCreateManyInput | SecurityEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SecurityEvent createManyAndReturn
   */
  export type SecurityEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityEvent
     */
    omit?: SecurityEventOmit<ExtArgs> | null
    /**
     * The data used to create many SecurityEvents.
     */
    data: SecurityEventCreateManyInput | SecurityEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SecurityEvent update
   */
  export type SecurityEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityEvent
     */
    omit?: SecurityEventOmit<ExtArgs> | null
    /**
     * The data needed to update a SecurityEvent.
     */
    data: XOR<SecurityEventUpdateInput, SecurityEventUncheckedUpdateInput>
    /**
     * Choose, which SecurityEvent to update.
     */
    where: SecurityEventWhereUniqueInput
  }

  /**
   * SecurityEvent updateMany
   */
  export type SecurityEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SecurityEvents.
     */
    data: XOR<SecurityEventUpdateManyMutationInput, SecurityEventUncheckedUpdateManyInput>
    /**
     * Filter which SecurityEvents to update
     */
    where?: SecurityEventWhereInput
    /**
     * Limit how many SecurityEvents to update.
     */
    limit?: number
  }

  /**
   * SecurityEvent updateManyAndReturn
   */
  export type SecurityEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityEvent
     */
    omit?: SecurityEventOmit<ExtArgs> | null
    /**
     * The data used to update SecurityEvents.
     */
    data: XOR<SecurityEventUpdateManyMutationInput, SecurityEventUncheckedUpdateManyInput>
    /**
     * Filter which SecurityEvents to update
     */
    where?: SecurityEventWhereInput
    /**
     * Limit how many SecurityEvents to update.
     */
    limit?: number
  }

  /**
   * SecurityEvent upsert
   */
  export type SecurityEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityEvent
     */
    omit?: SecurityEventOmit<ExtArgs> | null
    /**
     * The filter to search for the SecurityEvent to update in case it exists.
     */
    where: SecurityEventWhereUniqueInput
    /**
     * In case the SecurityEvent found by the `where` argument doesn't exist, create a new SecurityEvent with this data.
     */
    create: XOR<SecurityEventCreateInput, SecurityEventUncheckedCreateInput>
    /**
     * In case the SecurityEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SecurityEventUpdateInput, SecurityEventUncheckedUpdateInput>
  }

  /**
   * SecurityEvent delete
   */
  export type SecurityEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityEvent
     */
    omit?: SecurityEventOmit<ExtArgs> | null
    /**
     * Filter which SecurityEvent to delete.
     */
    where: SecurityEventWhereUniqueInput
  }

  /**
   * SecurityEvent deleteMany
   */
  export type SecurityEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SecurityEvents to delete
     */
    where?: SecurityEventWhereInput
    /**
     * Limit how many SecurityEvents to delete.
     */
    limit?: number
  }

  /**
   * SecurityEvent without action
   */
  export type SecurityEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityEvent
     */
    omit?: SecurityEventOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const BlogPostScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    excerpt: 'excerpt',
    content: 'content',
    contentType: 'contentType',
    status: 'status',
    metaTitle: 'metaTitle',
    metaDescription: 'metaDescription',
    keywords: 'keywords',
    canonicalUrl: 'canonicalUrl',
    ogTitle: 'ogTitle',
    ogDescription: 'ogDescription',
    ogImage: 'ogImage',
    twitterTitle: 'twitterTitle',
    twitterDescription: 'twitterDescription',
    twitterImage: 'twitterImage',
    featuredImage: 'featuredImage',
    featuredImageAlt: 'featuredImageAlt',
    readingTime: 'readingTime',
    wordCount: 'wordCount',
    publishedAt: 'publishedAt',
    scheduledAt: 'scheduledAt',
    archivedAt: 'archivedAt',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    authorId: 'authorId',
    categoryId: 'categoryId',
    currentVersion: 'currentVersion',
    viewCount: 'viewCount',
    likeCount: 'likeCount',
    shareCount: 'shareCount',
    commentCount: 'commentCount',
    seoScore: 'seoScore',
    seoAnalysis: 'seoAnalysis',
    lastSeoCheck: 'lastSeoCheck'
  };

  export type BlogPostScalarFieldEnum = (typeof BlogPostScalarFieldEnum)[keyof typeof BlogPostScalarFieldEnum]


  export const AuthorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    slug: 'slug',
    bio: 'bio',
    avatar: 'avatar',
    website: 'website',
    twitter: 'twitter',
    linkedin: 'linkedin',
    github: 'github',
    metaDescription: 'metaDescription',
    totalViews: 'totalViews',
    totalPosts: 'totalPosts',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AuthorScalarFieldEnum = (typeof AuthorScalarFieldEnum)[keyof typeof AuthorScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    color: 'color',
    icon: 'icon',
    metaTitle: 'metaTitle',
    metaDescription: 'metaDescription',
    keywords: 'keywords',
    parentId: 'parentId',
    postCount: 'postCount',
    totalViews: 'totalViews',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    color: 'color',
    metaDescription: 'metaDescription',
    postCount: 'postCount',
    totalViews: 'totalViews',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const PostTagScalarFieldEnum: {
    postId: 'postId',
    tagId: 'tagId',
    createdAt: 'createdAt'
  };

  export type PostTagScalarFieldEnum = (typeof PostTagScalarFieldEnum)[keyof typeof PostTagScalarFieldEnum]


  export const PostRelationScalarFieldEnum: {
    id: 'id',
    originalPostId: 'originalPostId',
    relatedPostId: 'relatedPostId',
    relationType: 'relationType',
    createdAt: 'createdAt'
  };

  export type PostRelationScalarFieldEnum = (typeof PostRelationScalarFieldEnum)[keyof typeof PostRelationScalarFieldEnum]


  export const PostVersionScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    version: 'version',
    title: 'title',
    content: 'content',
    excerpt: 'excerpt',
    changeType: 'changeType',
    changeNotes: 'changeNotes',
    authorId: 'authorId',
    createdAt: 'createdAt'
  };

  export type PostVersionScalarFieldEnum = (typeof PostVersionScalarFieldEnum)[keyof typeof PostVersionScalarFieldEnum]


  export const PostSeriesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    metaTitle: 'metaTitle',
    metaDescription: 'metaDescription',
    coverImage: 'coverImage',
    color: 'color',
    totalPosts: 'totalPosts',
    totalViews: 'totalViews',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PostSeriesScalarFieldEnum = (typeof PostSeriesScalarFieldEnum)[keyof typeof PostSeriesScalarFieldEnum]


  export const SeriesPostScalarFieldEnum: {
    seriesId: 'seriesId',
    postId: 'postId',
    order: 'order',
    createdAt: 'createdAt'
  };

  export type SeriesPostScalarFieldEnum = (typeof SeriesPostScalarFieldEnum)[keyof typeof SeriesPostScalarFieldEnum]


  export const PostViewScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    visitorId: 'visitorId',
    sessionId: 'sessionId',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    referer: 'referer',
    country: 'country',
    region: 'region',
    city: 'city',
    readingTime: 'readingTime',
    scrollDepth: 'scrollDepth',
    viewedAt: 'viewedAt'
  };

  export type PostViewScalarFieldEnum = (typeof PostViewScalarFieldEnum)[keyof typeof PostViewScalarFieldEnum]


  export const PostInteractionScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    type: 'type',
    visitorId: 'visitorId',
    sessionId: 'sessionId',
    value: 'value',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type PostInteractionScalarFieldEnum = (typeof PostInteractionScalarFieldEnum)[keyof typeof PostInteractionScalarFieldEnum]


  export const SEOEventScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    type: 'type',
    title: 'title',
    description: 'description',
    severity: 'severity',
    oldValue: 'oldValue',
    newValue: 'newValue',
    recommendations: 'recommendations',
    processed: 'processed',
    processedAt: 'processedAt',
    createdAt: 'createdAt'
  };

  export type SEOEventScalarFieldEnum = (typeof SEOEventScalarFieldEnum)[keyof typeof SEOEventScalarFieldEnum]


  export const SEOKeywordScalarFieldEnum: {
    id: 'id',
    keyword: 'keyword',
    postId: 'postId',
    position: 'position',
    searchVolume: 'searchVolume',
    difficulty: 'difficulty',
    cpc: 'cpc',
    clicks: 'clicks',
    impressions: 'impressions',
    ctr: 'ctr',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastChecked: 'lastChecked'
  };

  export type SEOKeywordScalarFieldEnum = (typeof SEOKeywordScalarFieldEnum)[keyof typeof SEOKeywordScalarFieldEnum]


  export const SitemapEntryScalarFieldEnum: {
    id: 'id',
    url: 'url',
    lastMod: 'lastMod',
    changeFreq: 'changeFreq',
    priority: 'priority',
    postId: 'postId',
    included: 'included',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SitemapEntryScalarFieldEnum = (typeof SitemapEntryScalarFieldEnum)[keyof typeof SitemapEntryScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    title: 'title',
    description: 'description',
    longDescription: 'longDescription',
    content: 'content',
    image: 'image',
    link: 'link',
    github: 'github',
    category: 'category',
    tags: 'tags',
    featured: 'featured',
    client: 'client',
    role: 'role',
    duration: 'duration',
    year: 'year',
    caseStudyUrl: 'caseStudyUrl',
    impact: 'impact',
    results: 'results',
    displayMetrics: 'displayMetrics',
    metrics: 'metrics',
    testimonial: 'testimonial',
    gallery: 'gallery',
    details: 'details',
    charts: 'charts',
    viewCount: 'viewCount',
    clickCount: 'clickCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const ContactSubmissionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    company: 'company',
    phone: 'phone',
    subject: 'subject',
    message: 'message',
    status: 'status',
    responded: 'responded',
    respondedAt: 'respondedAt',
    notes: 'notes',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    referer: 'referer',
    emailSent: 'emailSent',
    emailId: 'emailId',
    emailError: 'emailError',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContactSubmissionScalarFieldEnum = (typeof ContactSubmissionScalarFieldEnum)[keyof typeof ContactSubmissionScalarFieldEnum]


  export const SecurityEventScalarFieldEnum: {
    id: 'id',
    type: 'type',
    severity: 'severity',
    message: 'message',
    details: 'details',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    path: 'path',
    method: 'method',
    clientId: 'clientId',
    sessionId: 'sessionId',
    acknowledged: 'acknowledged',
    acknowledgedAt: 'acknowledgedAt',
    acknowledgedBy: 'acknowledgedBy',
    createdAt: 'createdAt'
  };

  export type SecurityEventScalarFieldEnum = (typeof SecurityEventScalarFieldEnum)[keyof typeof SecurityEventScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const BlogPostOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    excerpt: 'excerpt',
    content: 'content',
    metaTitle: 'metaTitle',
    metaDescription: 'metaDescription',
    keywords: 'keywords',
    canonicalUrl: 'canonicalUrl',
    ogTitle: 'ogTitle',
    ogDescription: 'ogDescription',
    ogImage: 'ogImage',
    twitterTitle: 'twitterTitle',
    twitterDescription: 'twitterDescription',
    twitterImage: 'twitterImage',
    featuredImage: 'featuredImage',
    featuredImageAlt: 'featuredImageAlt',
    authorId: 'authorId',
    categoryId: 'categoryId'
  };

  export type BlogPostOrderByRelevanceFieldEnum = (typeof BlogPostOrderByRelevanceFieldEnum)[keyof typeof BlogPostOrderByRelevanceFieldEnum]


  export const AuthorOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    slug: 'slug',
    bio: 'bio',
    avatar: 'avatar',
    website: 'website',
    twitter: 'twitter',
    linkedin: 'linkedin',
    github: 'github',
    metaDescription: 'metaDescription'
  };

  export type AuthorOrderByRelevanceFieldEnum = (typeof AuthorOrderByRelevanceFieldEnum)[keyof typeof AuthorOrderByRelevanceFieldEnum]


  export const CategoryOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    color: 'color',
    icon: 'icon',
    metaTitle: 'metaTitle',
    metaDescription: 'metaDescription',
    keywords: 'keywords',
    parentId: 'parentId'
  };

  export type CategoryOrderByRelevanceFieldEnum = (typeof CategoryOrderByRelevanceFieldEnum)[keyof typeof CategoryOrderByRelevanceFieldEnum]


  export const TagOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    color: 'color',
    metaDescription: 'metaDescription'
  };

  export type TagOrderByRelevanceFieldEnum = (typeof TagOrderByRelevanceFieldEnum)[keyof typeof TagOrderByRelevanceFieldEnum]


  export const PostTagOrderByRelevanceFieldEnum: {
    postId: 'postId',
    tagId: 'tagId'
  };

  export type PostTagOrderByRelevanceFieldEnum = (typeof PostTagOrderByRelevanceFieldEnum)[keyof typeof PostTagOrderByRelevanceFieldEnum]


  export const PostRelationOrderByRelevanceFieldEnum: {
    id: 'id',
    originalPostId: 'originalPostId',
    relatedPostId: 'relatedPostId'
  };

  export type PostRelationOrderByRelevanceFieldEnum = (typeof PostRelationOrderByRelevanceFieldEnum)[keyof typeof PostRelationOrderByRelevanceFieldEnum]


  export const PostVersionOrderByRelevanceFieldEnum: {
    id: 'id',
    postId: 'postId',
    title: 'title',
    content: 'content',
    excerpt: 'excerpt',
    changeNotes: 'changeNotes',
    authorId: 'authorId'
  };

  export type PostVersionOrderByRelevanceFieldEnum = (typeof PostVersionOrderByRelevanceFieldEnum)[keyof typeof PostVersionOrderByRelevanceFieldEnum]


  export const PostSeriesOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    metaTitle: 'metaTitle',
    metaDescription: 'metaDescription',
    coverImage: 'coverImage',
    color: 'color'
  };

  export type PostSeriesOrderByRelevanceFieldEnum = (typeof PostSeriesOrderByRelevanceFieldEnum)[keyof typeof PostSeriesOrderByRelevanceFieldEnum]


  export const SeriesPostOrderByRelevanceFieldEnum: {
    seriesId: 'seriesId',
    postId: 'postId'
  };

  export type SeriesPostOrderByRelevanceFieldEnum = (typeof SeriesPostOrderByRelevanceFieldEnum)[keyof typeof SeriesPostOrderByRelevanceFieldEnum]


  export const PostViewOrderByRelevanceFieldEnum: {
    id: 'id',
    postId: 'postId',
    visitorId: 'visitorId',
    sessionId: 'sessionId',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    referer: 'referer',
    country: 'country',
    region: 'region',
    city: 'city'
  };

  export type PostViewOrderByRelevanceFieldEnum = (typeof PostViewOrderByRelevanceFieldEnum)[keyof typeof PostViewOrderByRelevanceFieldEnum]


  export const PostInteractionOrderByRelevanceFieldEnum: {
    id: 'id',
    postId: 'postId',
    visitorId: 'visitorId',
    sessionId: 'sessionId',
    value: 'value'
  };

  export type PostInteractionOrderByRelevanceFieldEnum = (typeof PostInteractionOrderByRelevanceFieldEnum)[keyof typeof PostInteractionOrderByRelevanceFieldEnum]


  export const SEOEventOrderByRelevanceFieldEnum: {
    id: 'id',
    postId: 'postId',
    title: 'title',
    description: 'description',
    oldValue: 'oldValue',
    newValue: 'newValue',
    recommendations: 'recommendations'
  };

  export type SEOEventOrderByRelevanceFieldEnum = (typeof SEOEventOrderByRelevanceFieldEnum)[keyof typeof SEOEventOrderByRelevanceFieldEnum]


  export const SEOKeywordOrderByRelevanceFieldEnum: {
    id: 'id',
    keyword: 'keyword',
    postId: 'postId'
  };

  export type SEOKeywordOrderByRelevanceFieldEnum = (typeof SEOKeywordOrderByRelevanceFieldEnum)[keyof typeof SEOKeywordOrderByRelevanceFieldEnum]


  export const SitemapEntryOrderByRelevanceFieldEnum: {
    id: 'id',
    url: 'url',
    postId: 'postId'
  };

  export type SitemapEntryOrderByRelevanceFieldEnum = (typeof SitemapEntryOrderByRelevanceFieldEnum)[keyof typeof SitemapEntryOrderByRelevanceFieldEnum]


  export const ProjectOrderByRelevanceFieldEnum: {
    id: 'id',
    slug: 'slug',
    title: 'title',
    description: 'description',
    longDescription: 'longDescription',
    content: 'content',
    image: 'image',
    link: 'link',
    github: 'github',
    category: 'category',
    tags: 'tags',
    client: 'client',
    role: 'role',
    duration: 'duration',
    caseStudyUrl: 'caseStudyUrl'
  };

  export type ProjectOrderByRelevanceFieldEnum = (typeof ProjectOrderByRelevanceFieldEnum)[keyof typeof ProjectOrderByRelevanceFieldEnum]


  export const ContactSubmissionOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    company: 'company',
    phone: 'phone',
    subject: 'subject',
    message: 'message',
    notes: 'notes',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    referer: 'referer',
    emailId: 'emailId',
    emailError: 'emailError'
  };

  export type ContactSubmissionOrderByRelevanceFieldEnum = (typeof ContactSubmissionOrderByRelevanceFieldEnum)[keyof typeof ContactSubmissionOrderByRelevanceFieldEnum]


  export const SecurityEventOrderByRelevanceFieldEnum: {
    id: 'id',
    message: 'message',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    path: 'path',
    method: 'method',
    clientId: 'clientId',
    sessionId: 'sessionId',
    acknowledgedBy: 'acknowledgedBy'
  };

  export type SecurityEventOrderByRelevanceFieldEnum = (typeof SecurityEventOrderByRelevanceFieldEnum)[keyof typeof SecurityEventOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'ContentType'
   */
  export type EnumContentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContentType'>
    


  /**
   * Reference to a field of type 'ContentType[]'
   */
  export type ListEnumContentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContentType[]'>
    


  /**
   * Reference to a field of type 'PostStatus'
   */
  export type EnumPostStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostStatus'>
    


  /**
   * Reference to a field of type 'PostStatus[]'
   */
  export type ListEnumPostStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'RelationType'
   */
  export type EnumRelationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RelationType'>
    


  /**
   * Reference to a field of type 'RelationType[]'
   */
  export type ListEnumRelationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RelationType[]'>
    


  /**
   * Reference to a field of type 'ChangeType'
   */
  export type EnumChangeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChangeType'>
    


  /**
   * Reference to a field of type 'ChangeType[]'
   */
  export type ListEnumChangeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChangeType[]'>
    


  /**
   * Reference to a field of type 'InteractionType'
   */
  export type EnumInteractionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InteractionType'>
    


  /**
   * Reference to a field of type 'InteractionType[]'
   */
  export type ListEnumInteractionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InteractionType[]'>
    


  /**
   * Reference to a field of type 'SEOEventType'
   */
  export type EnumSEOEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SEOEventType'>
    


  /**
   * Reference to a field of type 'SEOEventType[]'
   */
  export type ListEnumSEOEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SEOEventType[]'>
    


  /**
   * Reference to a field of type 'SEOSeverity'
   */
  export type EnumSEOSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SEOSeverity'>
    


  /**
   * Reference to a field of type 'SEOSeverity[]'
   */
  export type ListEnumSEOSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SEOSeverity[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'ChangeFrequency'
   */
  export type EnumChangeFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChangeFrequency'>
    


  /**
   * Reference to a field of type 'ChangeFrequency[]'
   */
  export type ListEnumChangeFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChangeFrequency[]'>
    


  /**
   * Reference to a field of type 'SubmissionStatus'
   */
  export type EnumSubmissionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubmissionStatus'>
    


  /**
   * Reference to a field of type 'SubmissionStatus[]'
   */
  export type ListEnumSubmissionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubmissionStatus[]'>
    


  /**
   * Reference to a field of type 'SecurityEventType'
   */
  export type EnumSecurityEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SecurityEventType'>
    


  /**
   * Reference to a field of type 'SecurityEventType[]'
   */
  export type ListEnumSecurityEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SecurityEventType[]'>
    


  /**
   * Reference to a field of type 'SecuritySeverity'
   */
  export type EnumSecuritySeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SecuritySeverity'>
    


  /**
   * Reference to a field of type 'SecuritySeverity[]'
   */
  export type ListEnumSecuritySeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SecuritySeverity[]'>
    
  /**
   * Deep Input Types
   */


  export type BlogPostWhereInput = {
    AND?: BlogPostWhereInput | BlogPostWhereInput[]
    OR?: BlogPostWhereInput[]
    NOT?: BlogPostWhereInput | BlogPostWhereInput[]
    id?: StringFilter<"BlogPost"> | string
    title?: StringFilter<"BlogPost"> | string
    slug?: StringFilter<"BlogPost"> | string
    excerpt?: StringNullableFilter<"BlogPost"> | string | null
    content?: StringFilter<"BlogPost"> | string
    contentType?: EnumContentTypeFilter<"BlogPost"> | $Enums.ContentType
    status?: EnumPostStatusFilter<"BlogPost"> | $Enums.PostStatus
    metaTitle?: StringNullableFilter<"BlogPost"> | string | null
    metaDescription?: StringNullableFilter<"BlogPost"> | string | null
    keywords?: StringNullableListFilter<"BlogPost">
    canonicalUrl?: StringNullableFilter<"BlogPost"> | string | null
    ogTitle?: StringNullableFilter<"BlogPost"> | string | null
    ogDescription?: StringNullableFilter<"BlogPost"> | string | null
    ogImage?: StringNullableFilter<"BlogPost"> | string | null
    twitterTitle?: StringNullableFilter<"BlogPost"> | string | null
    twitterDescription?: StringNullableFilter<"BlogPost"> | string | null
    twitterImage?: StringNullableFilter<"BlogPost"> | string | null
    featuredImage?: StringNullableFilter<"BlogPost"> | string | null
    featuredImageAlt?: StringNullableFilter<"BlogPost"> | string | null
    readingTime?: IntNullableFilter<"BlogPost"> | number | null
    wordCount?: IntNullableFilter<"BlogPost"> | number | null
    publishedAt?: DateTimeNullableFilter<"BlogPost"> | Date | string | null
    scheduledAt?: DateTimeNullableFilter<"BlogPost"> | Date | string | null
    archivedAt?: DateTimeNullableFilter<"BlogPost"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"BlogPost"> | Date | string | null
    createdAt?: DateTimeFilter<"BlogPost"> | Date | string
    updatedAt?: DateTimeFilter<"BlogPost"> | Date | string
    authorId?: StringFilter<"BlogPost"> | string
    categoryId?: StringNullableFilter<"BlogPost"> | string | null
    currentVersion?: IntFilter<"BlogPost"> | number
    viewCount?: IntFilter<"BlogPost"> | number
    likeCount?: IntFilter<"BlogPost"> | number
    shareCount?: IntFilter<"BlogPost"> | number
    commentCount?: IntFilter<"BlogPost"> | number
    seoScore?: FloatNullableFilter<"BlogPost"> | number | null
    seoAnalysis?: JsonNullableFilter<"BlogPost">
    lastSeoCheck?: DateTimeNullableFilter<"BlogPost"> | Date | string | null
    author?: XOR<AuthorScalarRelationFilter, AuthorWhereInput>
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    tags?: PostTagListRelationFilter
    seriesPosts?: SeriesPostListRelationFilter
    relatedPosts?: PostRelationListRelationFilter
    relatedToPosts?: PostRelationListRelationFilter
    versions?: PostVersionListRelationFilter
    views?: PostViewListRelationFilter
    interactions?: PostInteractionListRelationFilter
    seoEvents?: SEOEventListRelationFilter
    seoKeywords?: SEOKeywordListRelationFilter
    sitemapEntries?: SitemapEntryListRelationFilter
  }

  export type BlogPostOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    excerpt?: SortOrderInput | SortOrder
    content?: SortOrder
    contentType?: SortOrder
    status?: SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    keywords?: SortOrder
    canonicalUrl?: SortOrderInput | SortOrder
    ogTitle?: SortOrderInput | SortOrder
    ogDescription?: SortOrderInput | SortOrder
    ogImage?: SortOrderInput | SortOrder
    twitterTitle?: SortOrderInput | SortOrder
    twitterDescription?: SortOrderInput | SortOrder
    twitterImage?: SortOrderInput | SortOrder
    featuredImage?: SortOrderInput | SortOrder
    featuredImageAlt?: SortOrderInput | SortOrder
    readingTime?: SortOrderInput | SortOrder
    wordCount?: SortOrderInput | SortOrder
    publishedAt?: SortOrderInput | SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    archivedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    currentVersion?: SortOrder
    viewCount?: SortOrder
    likeCount?: SortOrder
    shareCount?: SortOrder
    commentCount?: SortOrder
    seoScore?: SortOrderInput | SortOrder
    seoAnalysis?: SortOrderInput | SortOrder
    lastSeoCheck?: SortOrderInput | SortOrder
    author?: AuthorOrderByWithRelationInput
    category?: CategoryOrderByWithRelationInput
    tags?: PostTagOrderByRelationAggregateInput
    seriesPosts?: SeriesPostOrderByRelationAggregateInput
    relatedPosts?: PostRelationOrderByRelationAggregateInput
    relatedToPosts?: PostRelationOrderByRelationAggregateInput
    versions?: PostVersionOrderByRelationAggregateInput
    views?: PostViewOrderByRelationAggregateInput
    interactions?: PostInteractionOrderByRelationAggregateInput
    seoEvents?: SEOEventOrderByRelationAggregateInput
    seoKeywords?: SEOKeywordOrderByRelationAggregateInput
    sitemapEntries?: SitemapEntryOrderByRelationAggregateInput
    _relevance?: BlogPostOrderByRelevanceInput
  }

  export type BlogPostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: BlogPostWhereInput | BlogPostWhereInput[]
    OR?: BlogPostWhereInput[]
    NOT?: BlogPostWhereInput | BlogPostWhereInput[]
    title?: StringFilter<"BlogPost"> | string
    excerpt?: StringNullableFilter<"BlogPost"> | string | null
    content?: StringFilter<"BlogPost"> | string
    contentType?: EnumContentTypeFilter<"BlogPost"> | $Enums.ContentType
    status?: EnumPostStatusFilter<"BlogPost"> | $Enums.PostStatus
    metaTitle?: StringNullableFilter<"BlogPost"> | string | null
    metaDescription?: StringNullableFilter<"BlogPost"> | string | null
    keywords?: StringNullableListFilter<"BlogPost">
    canonicalUrl?: StringNullableFilter<"BlogPost"> | string | null
    ogTitle?: StringNullableFilter<"BlogPost"> | string | null
    ogDescription?: StringNullableFilter<"BlogPost"> | string | null
    ogImage?: StringNullableFilter<"BlogPost"> | string | null
    twitterTitle?: StringNullableFilter<"BlogPost"> | string | null
    twitterDescription?: StringNullableFilter<"BlogPost"> | string | null
    twitterImage?: StringNullableFilter<"BlogPost"> | string | null
    featuredImage?: StringNullableFilter<"BlogPost"> | string | null
    featuredImageAlt?: StringNullableFilter<"BlogPost"> | string | null
    readingTime?: IntNullableFilter<"BlogPost"> | number | null
    wordCount?: IntNullableFilter<"BlogPost"> | number | null
    publishedAt?: DateTimeNullableFilter<"BlogPost"> | Date | string | null
    scheduledAt?: DateTimeNullableFilter<"BlogPost"> | Date | string | null
    archivedAt?: DateTimeNullableFilter<"BlogPost"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"BlogPost"> | Date | string | null
    createdAt?: DateTimeFilter<"BlogPost"> | Date | string
    updatedAt?: DateTimeFilter<"BlogPost"> | Date | string
    authorId?: StringFilter<"BlogPost"> | string
    categoryId?: StringNullableFilter<"BlogPost"> | string | null
    currentVersion?: IntFilter<"BlogPost"> | number
    viewCount?: IntFilter<"BlogPost"> | number
    likeCount?: IntFilter<"BlogPost"> | number
    shareCount?: IntFilter<"BlogPost"> | number
    commentCount?: IntFilter<"BlogPost"> | number
    seoScore?: FloatNullableFilter<"BlogPost"> | number | null
    seoAnalysis?: JsonNullableFilter<"BlogPost">
    lastSeoCheck?: DateTimeNullableFilter<"BlogPost"> | Date | string | null
    author?: XOR<AuthorScalarRelationFilter, AuthorWhereInput>
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    tags?: PostTagListRelationFilter
    seriesPosts?: SeriesPostListRelationFilter
    relatedPosts?: PostRelationListRelationFilter
    relatedToPosts?: PostRelationListRelationFilter
    versions?: PostVersionListRelationFilter
    views?: PostViewListRelationFilter
    interactions?: PostInteractionListRelationFilter
    seoEvents?: SEOEventListRelationFilter
    seoKeywords?: SEOKeywordListRelationFilter
    sitemapEntries?: SitemapEntryListRelationFilter
  }, "id" | "slug">

  export type BlogPostOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    excerpt?: SortOrderInput | SortOrder
    content?: SortOrder
    contentType?: SortOrder
    status?: SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    keywords?: SortOrder
    canonicalUrl?: SortOrderInput | SortOrder
    ogTitle?: SortOrderInput | SortOrder
    ogDescription?: SortOrderInput | SortOrder
    ogImage?: SortOrderInput | SortOrder
    twitterTitle?: SortOrderInput | SortOrder
    twitterDescription?: SortOrderInput | SortOrder
    twitterImage?: SortOrderInput | SortOrder
    featuredImage?: SortOrderInput | SortOrder
    featuredImageAlt?: SortOrderInput | SortOrder
    readingTime?: SortOrderInput | SortOrder
    wordCount?: SortOrderInput | SortOrder
    publishedAt?: SortOrderInput | SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    archivedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    currentVersion?: SortOrder
    viewCount?: SortOrder
    likeCount?: SortOrder
    shareCount?: SortOrder
    commentCount?: SortOrder
    seoScore?: SortOrderInput | SortOrder
    seoAnalysis?: SortOrderInput | SortOrder
    lastSeoCheck?: SortOrderInput | SortOrder
    _count?: BlogPostCountOrderByAggregateInput
    _avg?: BlogPostAvgOrderByAggregateInput
    _max?: BlogPostMaxOrderByAggregateInput
    _min?: BlogPostMinOrderByAggregateInput
    _sum?: BlogPostSumOrderByAggregateInput
  }

  export type BlogPostScalarWhereWithAggregatesInput = {
    AND?: BlogPostScalarWhereWithAggregatesInput | BlogPostScalarWhereWithAggregatesInput[]
    OR?: BlogPostScalarWhereWithAggregatesInput[]
    NOT?: BlogPostScalarWhereWithAggregatesInput | BlogPostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BlogPost"> | string
    title?: StringWithAggregatesFilter<"BlogPost"> | string
    slug?: StringWithAggregatesFilter<"BlogPost"> | string
    excerpt?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    content?: StringWithAggregatesFilter<"BlogPost"> | string
    contentType?: EnumContentTypeWithAggregatesFilter<"BlogPost"> | $Enums.ContentType
    status?: EnumPostStatusWithAggregatesFilter<"BlogPost"> | $Enums.PostStatus
    metaTitle?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    metaDescription?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    keywords?: StringNullableListFilter<"BlogPost">
    canonicalUrl?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    ogTitle?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    ogDescription?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    ogImage?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    twitterTitle?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    twitterDescription?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    twitterImage?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    featuredImage?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    featuredImageAlt?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    readingTime?: IntNullableWithAggregatesFilter<"BlogPost"> | number | null
    wordCount?: IntNullableWithAggregatesFilter<"BlogPost"> | number | null
    publishedAt?: DateTimeNullableWithAggregatesFilter<"BlogPost"> | Date | string | null
    scheduledAt?: DateTimeNullableWithAggregatesFilter<"BlogPost"> | Date | string | null
    archivedAt?: DateTimeNullableWithAggregatesFilter<"BlogPost"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"BlogPost"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BlogPost"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BlogPost"> | Date | string
    authorId?: StringWithAggregatesFilter<"BlogPost"> | string
    categoryId?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    currentVersion?: IntWithAggregatesFilter<"BlogPost"> | number
    viewCount?: IntWithAggregatesFilter<"BlogPost"> | number
    likeCount?: IntWithAggregatesFilter<"BlogPost"> | number
    shareCount?: IntWithAggregatesFilter<"BlogPost"> | number
    commentCount?: IntWithAggregatesFilter<"BlogPost"> | number
    seoScore?: FloatNullableWithAggregatesFilter<"BlogPost"> | number | null
    seoAnalysis?: JsonNullableWithAggregatesFilter<"BlogPost">
    lastSeoCheck?: DateTimeNullableWithAggregatesFilter<"BlogPost"> | Date | string | null
  }

  export type AuthorWhereInput = {
    AND?: AuthorWhereInput | AuthorWhereInput[]
    OR?: AuthorWhereInput[]
    NOT?: AuthorWhereInput | AuthorWhereInput[]
    id?: StringFilter<"Author"> | string
    name?: StringFilter<"Author"> | string
    email?: StringFilter<"Author"> | string
    slug?: StringFilter<"Author"> | string
    bio?: StringNullableFilter<"Author"> | string | null
    avatar?: StringNullableFilter<"Author"> | string | null
    website?: StringNullableFilter<"Author"> | string | null
    twitter?: StringNullableFilter<"Author"> | string | null
    linkedin?: StringNullableFilter<"Author"> | string | null
    github?: StringNullableFilter<"Author"> | string | null
    metaDescription?: StringNullableFilter<"Author"> | string | null
    totalViews?: IntFilter<"Author"> | number
    totalPosts?: IntFilter<"Author"> | number
    createdAt?: DateTimeFilter<"Author"> | Date | string
    updatedAt?: DateTimeFilter<"Author"> | Date | string
    posts?: BlogPostListRelationFilter
    postVersions?: PostVersionListRelationFilter
  }

  export type AuthorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    slug?: SortOrder
    bio?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    twitter?: SortOrderInput | SortOrder
    linkedin?: SortOrderInput | SortOrder
    github?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    totalViews?: SortOrder
    totalPosts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    posts?: BlogPostOrderByRelationAggregateInput
    postVersions?: PostVersionOrderByRelationAggregateInput
    _relevance?: AuthorOrderByRelevanceInput
  }

  export type AuthorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    slug?: string
    AND?: AuthorWhereInput | AuthorWhereInput[]
    OR?: AuthorWhereInput[]
    NOT?: AuthorWhereInput | AuthorWhereInput[]
    name?: StringFilter<"Author"> | string
    bio?: StringNullableFilter<"Author"> | string | null
    avatar?: StringNullableFilter<"Author"> | string | null
    website?: StringNullableFilter<"Author"> | string | null
    twitter?: StringNullableFilter<"Author"> | string | null
    linkedin?: StringNullableFilter<"Author"> | string | null
    github?: StringNullableFilter<"Author"> | string | null
    metaDescription?: StringNullableFilter<"Author"> | string | null
    totalViews?: IntFilter<"Author"> | number
    totalPosts?: IntFilter<"Author"> | number
    createdAt?: DateTimeFilter<"Author"> | Date | string
    updatedAt?: DateTimeFilter<"Author"> | Date | string
    posts?: BlogPostListRelationFilter
    postVersions?: PostVersionListRelationFilter
  }, "id" | "email" | "slug">

  export type AuthorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    slug?: SortOrder
    bio?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    twitter?: SortOrderInput | SortOrder
    linkedin?: SortOrderInput | SortOrder
    github?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    totalViews?: SortOrder
    totalPosts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AuthorCountOrderByAggregateInput
    _avg?: AuthorAvgOrderByAggregateInput
    _max?: AuthorMaxOrderByAggregateInput
    _min?: AuthorMinOrderByAggregateInput
    _sum?: AuthorSumOrderByAggregateInput
  }

  export type AuthorScalarWhereWithAggregatesInput = {
    AND?: AuthorScalarWhereWithAggregatesInput | AuthorScalarWhereWithAggregatesInput[]
    OR?: AuthorScalarWhereWithAggregatesInput[]
    NOT?: AuthorScalarWhereWithAggregatesInput | AuthorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Author"> | string
    name?: StringWithAggregatesFilter<"Author"> | string
    email?: StringWithAggregatesFilter<"Author"> | string
    slug?: StringWithAggregatesFilter<"Author"> | string
    bio?: StringNullableWithAggregatesFilter<"Author"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"Author"> | string | null
    website?: StringNullableWithAggregatesFilter<"Author"> | string | null
    twitter?: StringNullableWithAggregatesFilter<"Author"> | string | null
    linkedin?: StringNullableWithAggregatesFilter<"Author"> | string | null
    github?: StringNullableWithAggregatesFilter<"Author"> | string | null
    metaDescription?: StringNullableWithAggregatesFilter<"Author"> | string | null
    totalViews?: IntWithAggregatesFilter<"Author"> | number
    totalPosts?: IntWithAggregatesFilter<"Author"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Author"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Author"> | Date | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    slug?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    color?: StringNullableFilter<"Category"> | string | null
    icon?: StringNullableFilter<"Category"> | string | null
    metaTitle?: StringNullableFilter<"Category"> | string | null
    metaDescription?: StringNullableFilter<"Category"> | string | null
    keywords?: StringNullableListFilter<"Category">
    parentId?: StringNullableFilter<"Category"> | string | null
    postCount?: IntFilter<"Category"> | number
    totalViews?: IntFilter<"Category"> | number
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    parent?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    children?: CategoryListRelationFilter
    posts?: BlogPostListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    keywords?: SortOrder
    parentId?: SortOrderInput | SortOrder
    postCount?: SortOrder
    totalViews?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parent?: CategoryOrderByWithRelationInput
    children?: CategoryOrderByRelationAggregateInput
    posts?: BlogPostOrderByRelationAggregateInput
    _relevance?: CategoryOrderByRelevanceInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    slug?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    description?: StringNullableFilter<"Category"> | string | null
    color?: StringNullableFilter<"Category"> | string | null
    icon?: StringNullableFilter<"Category"> | string | null
    metaTitle?: StringNullableFilter<"Category"> | string | null
    metaDescription?: StringNullableFilter<"Category"> | string | null
    keywords?: StringNullableListFilter<"Category">
    parentId?: StringNullableFilter<"Category"> | string | null
    postCount?: IntFilter<"Category"> | number
    totalViews?: IntFilter<"Category"> | number
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    parent?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    children?: CategoryListRelationFilter
    posts?: BlogPostListRelationFilter
  }, "id" | "name" | "slug">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    keywords?: SortOrder
    parentId?: SortOrderInput | SortOrder
    postCount?: SortOrder
    totalViews?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _avg?: CategoryAvgOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
    _sum?: CategorySumOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    name?: StringWithAggregatesFilter<"Category"> | string
    slug?: StringWithAggregatesFilter<"Category"> | string
    description?: StringNullableWithAggregatesFilter<"Category"> | string | null
    color?: StringNullableWithAggregatesFilter<"Category"> | string | null
    icon?: StringNullableWithAggregatesFilter<"Category"> | string | null
    metaTitle?: StringNullableWithAggregatesFilter<"Category"> | string | null
    metaDescription?: StringNullableWithAggregatesFilter<"Category"> | string | null
    keywords?: StringNullableListFilter<"Category">
    parentId?: StringNullableWithAggregatesFilter<"Category"> | string | null
    postCount?: IntWithAggregatesFilter<"Category"> | number
    totalViews?: IntWithAggregatesFilter<"Category"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    id?: StringFilter<"Tag"> | string
    name?: StringFilter<"Tag"> | string
    slug?: StringFilter<"Tag"> | string
    description?: StringNullableFilter<"Tag"> | string | null
    color?: StringNullableFilter<"Tag"> | string | null
    metaDescription?: StringNullableFilter<"Tag"> | string | null
    postCount?: IntFilter<"Tag"> | number
    totalViews?: IntFilter<"Tag"> | number
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
    posts?: PostTagListRelationFilter
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    postCount?: SortOrder
    totalViews?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    posts?: PostTagOrderByRelationAggregateInput
    _relevance?: TagOrderByRelevanceInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    slug?: string
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    description?: StringNullableFilter<"Tag"> | string | null
    color?: StringNullableFilter<"Tag"> | string | null
    metaDescription?: StringNullableFilter<"Tag"> | string | null
    postCount?: IntFilter<"Tag"> | number
    totalViews?: IntFilter<"Tag"> | number
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
    posts?: PostTagListRelationFilter
  }, "id" | "name" | "slug">

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    postCount?: SortOrder
    totalViews?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _avg?: TagAvgOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
    _sum?: TagSumOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tag"> | string
    name?: StringWithAggregatesFilter<"Tag"> | string
    slug?: StringWithAggregatesFilter<"Tag"> | string
    description?: StringNullableWithAggregatesFilter<"Tag"> | string | null
    color?: StringNullableWithAggregatesFilter<"Tag"> | string | null
    metaDescription?: StringNullableWithAggregatesFilter<"Tag"> | string | null
    postCount?: IntWithAggregatesFilter<"Tag"> | number
    totalViews?: IntWithAggregatesFilter<"Tag"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
  }

  export type PostTagWhereInput = {
    AND?: PostTagWhereInput | PostTagWhereInput[]
    OR?: PostTagWhereInput[]
    NOT?: PostTagWhereInput | PostTagWhereInput[]
    postId?: StringFilter<"PostTag"> | string
    tagId?: StringFilter<"PostTag"> | string
    createdAt?: DateTimeFilter<"PostTag"> | Date | string
    post?: XOR<BlogPostScalarRelationFilter, BlogPostWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }

  export type PostTagOrderByWithRelationInput = {
    postId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
    post?: BlogPostOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
    _relevance?: PostTagOrderByRelevanceInput
  }

  export type PostTagWhereUniqueInput = Prisma.AtLeast<{
    postId_tagId?: PostTagPostIdTagIdCompoundUniqueInput
    AND?: PostTagWhereInput | PostTagWhereInput[]
    OR?: PostTagWhereInput[]
    NOT?: PostTagWhereInput | PostTagWhereInput[]
    postId?: StringFilter<"PostTag"> | string
    tagId?: StringFilter<"PostTag"> | string
    createdAt?: DateTimeFilter<"PostTag"> | Date | string
    post?: XOR<BlogPostScalarRelationFilter, BlogPostWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }, "postId_tagId">

  export type PostTagOrderByWithAggregationInput = {
    postId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
    _count?: PostTagCountOrderByAggregateInput
    _max?: PostTagMaxOrderByAggregateInput
    _min?: PostTagMinOrderByAggregateInput
  }

  export type PostTagScalarWhereWithAggregatesInput = {
    AND?: PostTagScalarWhereWithAggregatesInput | PostTagScalarWhereWithAggregatesInput[]
    OR?: PostTagScalarWhereWithAggregatesInput[]
    NOT?: PostTagScalarWhereWithAggregatesInput | PostTagScalarWhereWithAggregatesInput[]
    postId?: StringWithAggregatesFilter<"PostTag"> | string
    tagId?: StringWithAggregatesFilter<"PostTag"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PostTag"> | Date | string
  }

  export type PostRelationWhereInput = {
    AND?: PostRelationWhereInput | PostRelationWhereInput[]
    OR?: PostRelationWhereInput[]
    NOT?: PostRelationWhereInput | PostRelationWhereInput[]
    id?: StringFilter<"PostRelation"> | string
    originalPostId?: StringFilter<"PostRelation"> | string
    relatedPostId?: StringFilter<"PostRelation"> | string
    relationType?: EnumRelationTypeFilter<"PostRelation"> | $Enums.RelationType
    createdAt?: DateTimeFilter<"PostRelation"> | Date | string
    originalPost?: XOR<BlogPostScalarRelationFilter, BlogPostWhereInput>
    relatedPost?: XOR<BlogPostScalarRelationFilter, BlogPostWhereInput>
  }

  export type PostRelationOrderByWithRelationInput = {
    id?: SortOrder
    originalPostId?: SortOrder
    relatedPostId?: SortOrder
    relationType?: SortOrder
    createdAt?: SortOrder
    originalPost?: BlogPostOrderByWithRelationInput
    relatedPost?: BlogPostOrderByWithRelationInput
    _relevance?: PostRelationOrderByRelevanceInput
  }

  export type PostRelationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    originalPostId_relatedPostId?: PostRelationOriginalPostIdRelatedPostIdCompoundUniqueInput
    AND?: PostRelationWhereInput | PostRelationWhereInput[]
    OR?: PostRelationWhereInput[]
    NOT?: PostRelationWhereInput | PostRelationWhereInput[]
    originalPostId?: StringFilter<"PostRelation"> | string
    relatedPostId?: StringFilter<"PostRelation"> | string
    relationType?: EnumRelationTypeFilter<"PostRelation"> | $Enums.RelationType
    createdAt?: DateTimeFilter<"PostRelation"> | Date | string
    originalPost?: XOR<BlogPostScalarRelationFilter, BlogPostWhereInput>
    relatedPost?: XOR<BlogPostScalarRelationFilter, BlogPostWhereInput>
  }, "id" | "originalPostId_relatedPostId">

  export type PostRelationOrderByWithAggregationInput = {
    id?: SortOrder
    originalPostId?: SortOrder
    relatedPostId?: SortOrder
    relationType?: SortOrder
    createdAt?: SortOrder
    _count?: PostRelationCountOrderByAggregateInput
    _max?: PostRelationMaxOrderByAggregateInput
    _min?: PostRelationMinOrderByAggregateInput
  }

  export type PostRelationScalarWhereWithAggregatesInput = {
    AND?: PostRelationScalarWhereWithAggregatesInput | PostRelationScalarWhereWithAggregatesInput[]
    OR?: PostRelationScalarWhereWithAggregatesInput[]
    NOT?: PostRelationScalarWhereWithAggregatesInput | PostRelationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PostRelation"> | string
    originalPostId?: StringWithAggregatesFilter<"PostRelation"> | string
    relatedPostId?: StringWithAggregatesFilter<"PostRelation"> | string
    relationType?: EnumRelationTypeWithAggregatesFilter<"PostRelation"> | $Enums.RelationType
    createdAt?: DateTimeWithAggregatesFilter<"PostRelation"> | Date | string
  }

  export type PostVersionWhereInput = {
    AND?: PostVersionWhereInput | PostVersionWhereInput[]
    OR?: PostVersionWhereInput[]
    NOT?: PostVersionWhereInput | PostVersionWhereInput[]
    id?: StringFilter<"PostVersion"> | string
    postId?: StringFilter<"PostVersion"> | string
    version?: IntFilter<"PostVersion"> | number
    title?: StringFilter<"PostVersion"> | string
    content?: StringFilter<"PostVersion"> | string
    excerpt?: StringNullableFilter<"PostVersion"> | string | null
    changeType?: EnumChangeTypeFilter<"PostVersion"> | $Enums.ChangeType
    changeNotes?: StringNullableFilter<"PostVersion"> | string | null
    authorId?: StringFilter<"PostVersion"> | string
    createdAt?: DateTimeFilter<"PostVersion"> | Date | string
    author?: XOR<AuthorScalarRelationFilter, AuthorWhereInput>
    post?: XOR<BlogPostScalarRelationFilter, BlogPostWhereInput>
  }

  export type PostVersionOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    version?: SortOrder
    title?: SortOrder
    content?: SortOrder
    excerpt?: SortOrderInput | SortOrder
    changeType?: SortOrder
    changeNotes?: SortOrderInput | SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    author?: AuthorOrderByWithRelationInput
    post?: BlogPostOrderByWithRelationInput
    _relevance?: PostVersionOrderByRelevanceInput
  }

  export type PostVersionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    postId_version?: PostVersionPostIdVersionCompoundUniqueInput
    AND?: PostVersionWhereInput | PostVersionWhereInput[]
    OR?: PostVersionWhereInput[]
    NOT?: PostVersionWhereInput | PostVersionWhereInput[]
    postId?: StringFilter<"PostVersion"> | string
    version?: IntFilter<"PostVersion"> | number
    title?: StringFilter<"PostVersion"> | string
    content?: StringFilter<"PostVersion"> | string
    excerpt?: StringNullableFilter<"PostVersion"> | string | null
    changeType?: EnumChangeTypeFilter<"PostVersion"> | $Enums.ChangeType
    changeNotes?: StringNullableFilter<"PostVersion"> | string | null
    authorId?: StringFilter<"PostVersion"> | string
    createdAt?: DateTimeFilter<"PostVersion"> | Date | string
    author?: XOR<AuthorScalarRelationFilter, AuthorWhereInput>
    post?: XOR<BlogPostScalarRelationFilter, BlogPostWhereInput>
  }, "id" | "postId_version">

  export type PostVersionOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    version?: SortOrder
    title?: SortOrder
    content?: SortOrder
    excerpt?: SortOrderInput | SortOrder
    changeType?: SortOrder
    changeNotes?: SortOrderInput | SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    _count?: PostVersionCountOrderByAggregateInput
    _avg?: PostVersionAvgOrderByAggregateInput
    _max?: PostVersionMaxOrderByAggregateInput
    _min?: PostVersionMinOrderByAggregateInput
    _sum?: PostVersionSumOrderByAggregateInput
  }

  export type PostVersionScalarWhereWithAggregatesInput = {
    AND?: PostVersionScalarWhereWithAggregatesInput | PostVersionScalarWhereWithAggregatesInput[]
    OR?: PostVersionScalarWhereWithAggregatesInput[]
    NOT?: PostVersionScalarWhereWithAggregatesInput | PostVersionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PostVersion"> | string
    postId?: StringWithAggregatesFilter<"PostVersion"> | string
    version?: IntWithAggregatesFilter<"PostVersion"> | number
    title?: StringWithAggregatesFilter<"PostVersion"> | string
    content?: StringWithAggregatesFilter<"PostVersion"> | string
    excerpt?: StringNullableWithAggregatesFilter<"PostVersion"> | string | null
    changeType?: EnumChangeTypeWithAggregatesFilter<"PostVersion"> | $Enums.ChangeType
    changeNotes?: StringNullableWithAggregatesFilter<"PostVersion"> | string | null
    authorId?: StringWithAggregatesFilter<"PostVersion"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PostVersion"> | Date | string
  }

  export type PostSeriesWhereInput = {
    AND?: PostSeriesWhereInput | PostSeriesWhereInput[]
    OR?: PostSeriesWhereInput[]
    NOT?: PostSeriesWhereInput | PostSeriesWhereInput[]
    id?: StringFilter<"PostSeries"> | string
    name?: StringFilter<"PostSeries"> | string
    slug?: StringFilter<"PostSeries"> | string
    description?: StringNullableFilter<"PostSeries"> | string | null
    metaTitle?: StringNullableFilter<"PostSeries"> | string | null
    metaDescription?: StringNullableFilter<"PostSeries"> | string | null
    coverImage?: StringNullableFilter<"PostSeries"> | string | null
    color?: StringNullableFilter<"PostSeries"> | string | null
    totalPosts?: IntFilter<"PostSeries"> | number
    totalViews?: IntFilter<"PostSeries"> | number
    createdAt?: DateTimeFilter<"PostSeries"> | Date | string
    updatedAt?: DateTimeFilter<"PostSeries"> | Date | string
    posts?: SeriesPostListRelationFilter
  }

  export type PostSeriesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    coverImage?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    totalPosts?: SortOrder
    totalViews?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    posts?: SeriesPostOrderByRelationAggregateInput
    _relevance?: PostSeriesOrderByRelevanceInput
  }

  export type PostSeriesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: PostSeriesWhereInput | PostSeriesWhereInput[]
    OR?: PostSeriesWhereInput[]
    NOT?: PostSeriesWhereInput | PostSeriesWhereInput[]
    name?: StringFilter<"PostSeries"> | string
    description?: StringNullableFilter<"PostSeries"> | string | null
    metaTitle?: StringNullableFilter<"PostSeries"> | string | null
    metaDescription?: StringNullableFilter<"PostSeries"> | string | null
    coverImage?: StringNullableFilter<"PostSeries"> | string | null
    color?: StringNullableFilter<"PostSeries"> | string | null
    totalPosts?: IntFilter<"PostSeries"> | number
    totalViews?: IntFilter<"PostSeries"> | number
    createdAt?: DateTimeFilter<"PostSeries"> | Date | string
    updatedAt?: DateTimeFilter<"PostSeries"> | Date | string
    posts?: SeriesPostListRelationFilter
  }, "id" | "slug">

  export type PostSeriesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    coverImage?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    totalPosts?: SortOrder
    totalViews?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PostSeriesCountOrderByAggregateInput
    _avg?: PostSeriesAvgOrderByAggregateInput
    _max?: PostSeriesMaxOrderByAggregateInput
    _min?: PostSeriesMinOrderByAggregateInput
    _sum?: PostSeriesSumOrderByAggregateInput
  }

  export type PostSeriesScalarWhereWithAggregatesInput = {
    AND?: PostSeriesScalarWhereWithAggregatesInput | PostSeriesScalarWhereWithAggregatesInput[]
    OR?: PostSeriesScalarWhereWithAggregatesInput[]
    NOT?: PostSeriesScalarWhereWithAggregatesInput | PostSeriesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PostSeries"> | string
    name?: StringWithAggregatesFilter<"PostSeries"> | string
    slug?: StringWithAggregatesFilter<"PostSeries"> | string
    description?: StringNullableWithAggregatesFilter<"PostSeries"> | string | null
    metaTitle?: StringNullableWithAggregatesFilter<"PostSeries"> | string | null
    metaDescription?: StringNullableWithAggregatesFilter<"PostSeries"> | string | null
    coverImage?: StringNullableWithAggregatesFilter<"PostSeries"> | string | null
    color?: StringNullableWithAggregatesFilter<"PostSeries"> | string | null
    totalPosts?: IntWithAggregatesFilter<"PostSeries"> | number
    totalViews?: IntWithAggregatesFilter<"PostSeries"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PostSeries"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PostSeries"> | Date | string
  }

  export type SeriesPostWhereInput = {
    AND?: SeriesPostWhereInput | SeriesPostWhereInput[]
    OR?: SeriesPostWhereInput[]
    NOT?: SeriesPostWhereInput | SeriesPostWhereInput[]
    seriesId?: StringFilter<"SeriesPost"> | string
    postId?: StringFilter<"SeriesPost"> | string
    order?: IntFilter<"SeriesPost"> | number
    createdAt?: DateTimeFilter<"SeriesPost"> | Date | string
    series?: XOR<PostSeriesScalarRelationFilter, PostSeriesWhereInput>
    post?: XOR<BlogPostScalarRelationFilter, BlogPostWhereInput>
  }

  export type SeriesPostOrderByWithRelationInput = {
    seriesId?: SortOrder
    postId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    series?: PostSeriesOrderByWithRelationInput
    post?: BlogPostOrderByWithRelationInput
    _relevance?: SeriesPostOrderByRelevanceInput
  }

  export type SeriesPostWhereUniqueInput = Prisma.AtLeast<{
    seriesId_order?: SeriesPostSeriesIdOrderCompoundUniqueInput
    seriesId_postId?: SeriesPostSeriesIdPostIdCompoundUniqueInput
    AND?: SeriesPostWhereInput | SeriesPostWhereInput[]
    OR?: SeriesPostWhereInput[]
    NOT?: SeriesPostWhereInput | SeriesPostWhereInput[]
    seriesId?: StringFilter<"SeriesPost"> | string
    postId?: StringFilter<"SeriesPost"> | string
    order?: IntFilter<"SeriesPost"> | number
    createdAt?: DateTimeFilter<"SeriesPost"> | Date | string
    series?: XOR<PostSeriesScalarRelationFilter, PostSeriesWhereInput>
    post?: XOR<BlogPostScalarRelationFilter, BlogPostWhereInput>
  }, "seriesId_postId" | "seriesId_order">

  export type SeriesPostOrderByWithAggregationInput = {
    seriesId?: SortOrder
    postId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    _count?: SeriesPostCountOrderByAggregateInput
    _avg?: SeriesPostAvgOrderByAggregateInput
    _max?: SeriesPostMaxOrderByAggregateInput
    _min?: SeriesPostMinOrderByAggregateInput
    _sum?: SeriesPostSumOrderByAggregateInput
  }

  export type SeriesPostScalarWhereWithAggregatesInput = {
    AND?: SeriesPostScalarWhereWithAggregatesInput | SeriesPostScalarWhereWithAggregatesInput[]
    OR?: SeriesPostScalarWhereWithAggregatesInput[]
    NOT?: SeriesPostScalarWhereWithAggregatesInput | SeriesPostScalarWhereWithAggregatesInput[]
    seriesId?: StringWithAggregatesFilter<"SeriesPost"> | string
    postId?: StringWithAggregatesFilter<"SeriesPost"> | string
    order?: IntWithAggregatesFilter<"SeriesPost"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SeriesPost"> | Date | string
  }

  export type PostViewWhereInput = {
    AND?: PostViewWhereInput | PostViewWhereInput[]
    OR?: PostViewWhereInput[]
    NOT?: PostViewWhereInput | PostViewWhereInput[]
    id?: StringFilter<"PostView"> | string
    postId?: StringFilter<"PostView"> | string
    visitorId?: StringNullableFilter<"PostView"> | string | null
    sessionId?: StringNullableFilter<"PostView"> | string | null
    ipAddress?: StringNullableFilter<"PostView"> | string | null
    userAgent?: StringNullableFilter<"PostView"> | string | null
    referer?: StringNullableFilter<"PostView"> | string | null
    country?: StringNullableFilter<"PostView"> | string | null
    region?: StringNullableFilter<"PostView"> | string | null
    city?: StringNullableFilter<"PostView"> | string | null
    readingTime?: IntNullableFilter<"PostView"> | number | null
    scrollDepth?: FloatNullableFilter<"PostView"> | number | null
    viewedAt?: DateTimeFilter<"PostView"> | Date | string
    post?: XOR<BlogPostScalarRelationFilter, BlogPostWhereInput>
  }

  export type PostViewOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    visitorId?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    referer?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    readingTime?: SortOrderInput | SortOrder
    scrollDepth?: SortOrderInput | SortOrder
    viewedAt?: SortOrder
    post?: BlogPostOrderByWithRelationInput
    _relevance?: PostViewOrderByRelevanceInput
  }

  export type PostViewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PostViewWhereInput | PostViewWhereInput[]
    OR?: PostViewWhereInput[]
    NOT?: PostViewWhereInput | PostViewWhereInput[]
    postId?: StringFilter<"PostView"> | string
    visitorId?: StringNullableFilter<"PostView"> | string | null
    sessionId?: StringNullableFilter<"PostView"> | string | null
    ipAddress?: StringNullableFilter<"PostView"> | string | null
    userAgent?: StringNullableFilter<"PostView"> | string | null
    referer?: StringNullableFilter<"PostView"> | string | null
    country?: StringNullableFilter<"PostView"> | string | null
    region?: StringNullableFilter<"PostView"> | string | null
    city?: StringNullableFilter<"PostView"> | string | null
    readingTime?: IntNullableFilter<"PostView"> | number | null
    scrollDepth?: FloatNullableFilter<"PostView"> | number | null
    viewedAt?: DateTimeFilter<"PostView"> | Date | string
    post?: XOR<BlogPostScalarRelationFilter, BlogPostWhereInput>
  }, "id">

  export type PostViewOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    visitorId?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    referer?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    readingTime?: SortOrderInput | SortOrder
    scrollDepth?: SortOrderInput | SortOrder
    viewedAt?: SortOrder
    _count?: PostViewCountOrderByAggregateInput
    _avg?: PostViewAvgOrderByAggregateInput
    _max?: PostViewMaxOrderByAggregateInput
    _min?: PostViewMinOrderByAggregateInput
    _sum?: PostViewSumOrderByAggregateInput
  }

  export type PostViewScalarWhereWithAggregatesInput = {
    AND?: PostViewScalarWhereWithAggregatesInput | PostViewScalarWhereWithAggregatesInput[]
    OR?: PostViewScalarWhereWithAggregatesInput[]
    NOT?: PostViewScalarWhereWithAggregatesInput | PostViewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PostView"> | string
    postId?: StringWithAggregatesFilter<"PostView"> | string
    visitorId?: StringNullableWithAggregatesFilter<"PostView"> | string | null
    sessionId?: StringNullableWithAggregatesFilter<"PostView"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"PostView"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"PostView"> | string | null
    referer?: StringNullableWithAggregatesFilter<"PostView"> | string | null
    country?: StringNullableWithAggregatesFilter<"PostView"> | string | null
    region?: StringNullableWithAggregatesFilter<"PostView"> | string | null
    city?: StringNullableWithAggregatesFilter<"PostView"> | string | null
    readingTime?: IntNullableWithAggregatesFilter<"PostView"> | number | null
    scrollDepth?: FloatNullableWithAggregatesFilter<"PostView"> | number | null
    viewedAt?: DateTimeWithAggregatesFilter<"PostView"> | Date | string
  }

  export type PostInteractionWhereInput = {
    AND?: PostInteractionWhereInput | PostInteractionWhereInput[]
    OR?: PostInteractionWhereInput[]
    NOT?: PostInteractionWhereInput | PostInteractionWhereInput[]
    id?: StringFilter<"PostInteraction"> | string
    postId?: StringFilter<"PostInteraction"> | string
    type?: EnumInteractionTypeFilter<"PostInteraction"> | $Enums.InteractionType
    visitorId?: StringNullableFilter<"PostInteraction"> | string | null
    sessionId?: StringNullableFilter<"PostInteraction"> | string | null
    value?: StringNullableFilter<"PostInteraction"> | string | null
    metadata?: JsonNullableFilter<"PostInteraction">
    createdAt?: DateTimeFilter<"PostInteraction"> | Date | string
    post?: XOR<BlogPostScalarRelationFilter, BlogPostWhereInput>
  }

  export type PostInteractionOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    type?: SortOrder
    visitorId?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    post?: BlogPostOrderByWithRelationInput
    _relevance?: PostInteractionOrderByRelevanceInput
  }

  export type PostInteractionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PostInteractionWhereInput | PostInteractionWhereInput[]
    OR?: PostInteractionWhereInput[]
    NOT?: PostInteractionWhereInput | PostInteractionWhereInput[]
    postId?: StringFilter<"PostInteraction"> | string
    type?: EnumInteractionTypeFilter<"PostInteraction"> | $Enums.InteractionType
    visitorId?: StringNullableFilter<"PostInteraction"> | string | null
    sessionId?: StringNullableFilter<"PostInteraction"> | string | null
    value?: StringNullableFilter<"PostInteraction"> | string | null
    metadata?: JsonNullableFilter<"PostInteraction">
    createdAt?: DateTimeFilter<"PostInteraction"> | Date | string
    post?: XOR<BlogPostScalarRelationFilter, BlogPostWhereInput>
  }, "id">

  export type PostInteractionOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    type?: SortOrder
    visitorId?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PostInteractionCountOrderByAggregateInput
    _max?: PostInteractionMaxOrderByAggregateInput
    _min?: PostInteractionMinOrderByAggregateInput
  }

  export type PostInteractionScalarWhereWithAggregatesInput = {
    AND?: PostInteractionScalarWhereWithAggregatesInput | PostInteractionScalarWhereWithAggregatesInput[]
    OR?: PostInteractionScalarWhereWithAggregatesInput[]
    NOT?: PostInteractionScalarWhereWithAggregatesInput | PostInteractionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PostInteraction"> | string
    postId?: StringWithAggregatesFilter<"PostInteraction"> | string
    type?: EnumInteractionTypeWithAggregatesFilter<"PostInteraction"> | $Enums.InteractionType
    visitorId?: StringNullableWithAggregatesFilter<"PostInteraction"> | string | null
    sessionId?: StringNullableWithAggregatesFilter<"PostInteraction"> | string | null
    value?: StringNullableWithAggregatesFilter<"PostInteraction"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"PostInteraction">
    createdAt?: DateTimeWithAggregatesFilter<"PostInteraction"> | Date | string
  }

  export type SEOEventWhereInput = {
    AND?: SEOEventWhereInput | SEOEventWhereInput[]
    OR?: SEOEventWhereInput[]
    NOT?: SEOEventWhereInput | SEOEventWhereInput[]
    id?: StringFilter<"SEOEvent"> | string
    postId?: StringNullableFilter<"SEOEvent"> | string | null
    type?: EnumSEOEventTypeFilter<"SEOEvent"> | $Enums.SEOEventType
    title?: StringFilter<"SEOEvent"> | string
    description?: StringNullableFilter<"SEOEvent"> | string | null
    severity?: EnumSEOSeverityFilter<"SEOEvent"> | $Enums.SEOSeverity
    oldValue?: StringNullableFilter<"SEOEvent"> | string | null
    newValue?: StringNullableFilter<"SEOEvent"> | string | null
    recommendations?: StringNullableFilter<"SEOEvent"> | string | null
    processed?: BoolFilter<"SEOEvent"> | boolean
    processedAt?: DateTimeNullableFilter<"SEOEvent"> | Date | string | null
    createdAt?: DateTimeFilter<"SEOEvent"> | Date | string
    post?: XOR<BlogPostNullableScalarRelationFilter, BlogPostWhereInput> | null
  }

  export type SEOEventOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrderInput | SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    severity?: SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    recommendations?: SortOrderInput | SortOrder
    processed?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    post?: BlogPostOrderByWithRelationInput
    _relevance?: SEOEventOrderByRelevanceInput
  }

  export type SEOEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SEOEventWhereInput | SEOEventWhereInput[]
    OR?: SEOEventWhereInput[]
    NOT?: SEOEventWhereInput | SEOEventWhereInput[]
    postId?: StringNullableFilter<"SEOEvent"> | string | null
    type?: EnumSEOEventTypeFilter<"SEOEvent"> | $Enums.SEOEventType
    title?: StringFilter<"SEOEvent"> | string
    description?: StringNullableFilter<"SEOEvent"> | string | null
    severity?: EnumSEOSeverityFilter<"SEOEvent"> | $Enums.SEOSeverity
    oldValue?: StringNullableFilter<"SEOEvent"> | string | null
    newValue?: StringNullableFilter<"SEOEvent"> | string | null
    recommendations?: StringNullableFilter<"SEOEvent"> | string | null
    processed?: BoolFilter<"SEOEvent"> | boolean
    processedAt?: DateTimeNullableFilter<"SEOEvent"> | Date | string | null
    createdAt?: DateTimeFilter<"SEOEvent"> | Date | string
    post?: XOR<BlogPostNullableScalarRelationFilter, BlogPostWhereInput> | null
  }, "id">

  export type SEOEventOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrderInput | SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    severity?: SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    recommendations?: SortOrderInput | SortOrder
    processed?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SEOEventCountOrderByAggregateInput
    _max?: SEOEventMaxOrderByAggregateInput
    _min?: SEOEventMinOrderByAggregateInput
  }

  export type SEOEventScalarWhereWithAggregatesInput = {
    AND?: SEOEventScalarWhereWithAggregatesInput | SEOEventScalarWhereWithAggregatesInput[]
    OR?: SEOEventScalarWhereWithAggregatesInput[]
    NOT?: SEOEventScalarWhereWithAggregatesInput | SEOEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SEOEvent"> | string
    postId?: StringNullableWithAggregatesFilter<"SEOEvent"> | string | null
    type?: EnumSEOEventTypeWithAggregatesFilter<"SEOEvent"> | $Enums.SEOEventType
    title?: StringWithAggregatesFilter<"SEOEvent"> | string
    description?: StringNullableWithAggregatesFilter<"SEOEvent"> | string | null
    severity?: EnumSEOSeverityWithAggregatesFilter<"SEOEvent"> | $Enums.SEOSeverity
    oldValue?: StringNullableWithAggregatesFilter<"SEOEvent"> | string | null
    newValue?: StringNullableWithAggregatesFilter<"SEOEvent"> | string | null
    recommendations?: StringNullableWithAggregatesFilter<"SEOEvent"> | string | null
    processed?: BoolWithAggregatesFilter<"SEOEvent"> | boolean
    processedAt?: DateTimeNullableWithAggregatesFilter<"SEOEvent"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SEOEvent"> | Date | string
  }

  export type SEOKeywordWhereInput = {
    AND?: SEOKeywordWhereInput | SEOKeywordWhereInput[]
    OR?: SEOKeywordWhereInput[]
    NOT?: SEOKeywordWhereInput | SEOKeywordWhereInput[]
    id?: StringFilter<"SEOKeyword"> | string
    keyword?: StringFilter<"SEOKeyword"> | string
    postId?: StringNullableFilter<"SEOKeyword"> | string | null
    position?: IntNullableFilter<"SEOKeyword"> | number | null
    searchVolume?: IntNullableFilter<"SEOKeyword"> | number | null
    difficulty?: FloatNullableFilter<"SEOKeyword"> | number | null
    cpc?: FloatNullableFilter<"SEOKeyword"> | number | null
    clicks?: IntFilter<"SEOKeyword"> | number
    impressions?: IntFilter<"SEOKeyword"> | number
    ctr?: FloatNullableFilter<"SEOKeyword"> | number | null
    createdAt?: DateTimeFilter<"SEOKeyword"> | Date | string
    updatedAt?: DateTimeFilter<"SEOKeyword"> | Date | string
    lastChecked?: DateTimeNullableFilter<"SEOKeyword"> | Date | string | null
    post?: XOR<BlogPostNullableScalarRelationFilter, BlogPostWhereInput> | null
  }

  export type SEOKeywordOrderByWithRelationInput = {
    id?: SortOrder
    keyword?: SortOrder
    postId?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    searchVolume?: SortOrderInput | SortOrder
    difficulty?: SortOrderInput | SortOrder
    cpc?: SortOrderInput | SortOrder
    clicks?: SortOrder
    impressions?: SortOrder
    ctr?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastChecked?: SortOrderInput | SortOrder
    post?: BlogPostOrderByWithRelationInput
    _relevance?: SEOKeywordOrderByRelevanceInput
  }

  export type SEOKeywordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    keyword_postId?: SEOKeywordKeywordPostIdCompoundUniqueInput
    AND?: SEOKeywordWhereInput | SEOKeywordWhereInput[]
    OR?: SEOKeywordWhereInput[]
    NOT?: SEOKeywordWhereInput | SEOKeywordWhereInput[]
    keyword?: StringFilter<"SEOKeyword"> | string
    postId?: StringNullableFilter<"SEOKeyword"> | string | null
    position?: IntNullableFilter<"SEOKeyword"> | number | null
    searchVolume?: IntNullableFilter<"SEOKeyword"> | number | null
    difficulty?: FloatNullableFilter<"SEOKeyword"> | number | null
    cpc?: FloatNullableFilter<"SEOKeyword"> | number | null
    clicks?: IntFilter<"SEOKeyword"> | number
    impressions?: IntFilter<"SEOKeyword"> | number
    ctr?: FloatNullableFilter<"SEOKeyword"> | number | null
    createdAt?: DateTimeFilter<"SEOKeyword"> | Date | string
    updatedAt?: DateTimeFilter<"SEOKeyword"> | Date | string
    lastChecked?: DateTimeNullableFilter<"SEOKeyword"> | Date | string | null
    post?: XOR<BlogPostNullableScalarRelationFilter, BlogPostWhereInput> | null
  }, "id" | "keyword_postId">

  export type SEOKeywordOrderByWithAggregationInput = {
    id?: SortOrder
    keyword?: SortOrder
    postId?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    searchVolume?: SortOrderInput | SortOrder
    difficulty?: SortOrderInput | SortOrder
    cpc?: SortOrderInput | SortOrder
    clicks?: SortOrder
    impressions?: SortOrder
    ctr?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastChecked?: SortOrderInput | SortOrder
    _count?: SEOKeywordCountOrderByAggregateInput
    _avg?: SEOKeywordAvgOrderByAggregateInput
    _max?: SEOKeywordMaxOrderByAggregateInput
    _min?: SEOKeywordMinOrderByAggregateInput
    _sum?: SEOKeywordSumOrderByAggregateInput
  }

  export type SEOKeywordScalarWhereWithAggregatesInput = {
    AND?: SEOKeywordScalarWhereWithAggregatesInput | SEOKeywordScalarWhereWithAggregatesInput[]
    OR?: SEOKeywordScalarWhereWithAggregatesInput[]
    NOT?: SEOKeywordScalarWhereWithAggregatesInput | SEOKeywordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SEOKeyword"> | string
    keyword?: StringWithAggregatesFilter<"SEOKeyword"> | string
    postId?: StringNullableWithAggregatesFilter<"SEOKeyword"> | string | null
    position?: IntNullableWithAggregatesFilter<"SEOKeyword"> | number | null
    searchVolume?: IntNullableWithAggregatesFilter<"SEOKeyword"> | number | null
    difficulty?: FloatNullableWithAggregatesFilter<"SEOKeyword"> | number | null
    cpc?: FloatNullableWithAggregatesFilter<"SEOKeyword"> | number | null
    clicks?: IntWithAggregatesFilter<"SEOKeyword"> | number
    impressions?: IntWithAggregatesFilter<"SEOKeyword"> | number
    ctr?: FloatNullableWithAggregatesFilter<"SEOKeyword"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"SEOKeyword"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SEOKeyword"> | Date | string
    lastChecked?: DateTimeNullableWithAggregatesFilter<"SEOKeyword"> | Date | string | null
  }

  export type SitemapEntryWhereInput = {
    AND?: SitemapEntryWhereInput | SitemapEntryWhereInput[]
    OR?: SitemapEntryWhereInput[]
    NOT?: SitemapEntryWhereInput | SitemapEntryWhereInput[]
    id?: StringFilter<"SitemapEntry"> | string
    url?: StringFilter<"SitemapEntry"> | string
    lastMod?: DateTimeFilter<"SitemapEntry"> | Date | string
    changeFreq?: EnumChangeFrequencyFilter<"SitemapEntry"> | $Enums.ChangeFrequency
    priority?: FloatFilter<"SitemapEntry"> | number
    postId?: StringNullableFilter<"SitemapEntry"> | string | null
    included?: BoolFilter<"SitemapEntry"> | boolean
    createdAt?: DateTimeFilter<"SitemapEntry"> | Date | string
    updatedAt?: DateTimeFilter<"SitemapEntry"> | Date | string
    post?: XOR<BlogPostNullableScalarRelationFilter, BlogPostWhereInput> | null
  }

  export type SitemapEntryOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    lastMod?: SortOrder
    changeFreq?: SortOrder
    priority?: SortOrder
    postId?: SortOrderInput | SortOrder
    included?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    post?: BlogPostOrderByWithRelationInput
    _relevance?: SitemapEntryOrderByRelevanceInput
  }

  export type SitemapEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    url?: string
    AND?: SitemapEntryWhereInput | SitemapEntryWhereInput[]
    OR?: SitemapEntryWhereInput[]
    NOT?: SitemapEntryWhereInput | SitemapEntryWhereInput[]
    lastMod?: DateTimeFilter<"SitemapEntry"> | Date | string
    changeFreq?: EnumChangeFrequencyFilter<"SitemapEntry"> | $Enums.ChangeFrequency
    priority?: FloatFilter<"SitemapEntry"> | number
    postId?: StringNullableFilter<"SitemapEntry"> | string | null
    included?: BoolFilter<"SitemapEntry"> | boolean
    createdAt?: DateTimeFilter<"SitemapEntry"> | Date | string
    updatedAt?: DateTimeFilter<"SitemapEntry"> | Date | string
    post?: XOR<BlogPostNullableScalarRelationFilter, BlogPostWhereInput> | null
  }, "id" | "url">

  export type SitemapEntryOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    lastMod?: SortOrder
    changeFreq?: SortOrder
    priority?: SortOrder
    postId?: SortOrderInput | SortOrder
    included?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SitemapEntryCountOrderByAggregateInput
    _avg?: SitemapEntryAvgOrderByAggregateInput
    _max?: SitemapEntryMaxOrderByAggregateInput
    _min?: SitemapEntryMinOrderByAggregateInput
    _sum?: SitemapEntrySumOrderByAggregateInput
  }

  export type SitemapEntryScalarWhereWithAggregatesInput = {
    AND?: SitemapEntryScalarWhereWithAggregatesInput | SitemapEntryScalarWhereWithAggregatesInput[]
    OR?: SitemapEntryScalarWhereWithAggregatesInput[]
    NOT?: SitemapEntryScalarWhereWithAggregatesInput | SitemapEntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SitemapEntry"> | string
    url?: StringWithAggregatesFilter<"SitemapEntry"> | string
    lastMod?: DateTimeWithAggregatesFilter<"SitemapEntry"> | Date | string
    changeFreq?: EnumChangeFrequencyWithAggregatesFilter<"SitemapEntry"> | $Enums.ChangeFrequency
    priority?: FloatWithAggregatesFilter<"SitemapEntry"> | number
    postId?: StringNullableWithAggregatesFilter<"SitemapEntry"> | string | null
    included?: BoolWithAggregatesFilter<"SitemapEntry"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SitemapEntry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SitemapEntry"> | Date | string
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: StringFilter<"Project"> | string
    slug?: StringFilter<"Project"> | string
    title?: StringFilter<"Project"> | string
    description?: StringFilter<"Project"> | string
    longDescription?: StringNullableFilter<"Project"> | string | null
    content?: StringNullableFilter<"Project"> | string | null
    image?: StringFilter<"Project"> | string
    link?: StringNullableFilter<"Project"> | string | null
    github?: StringNullableFilter<"Project"> | string | null
    category?: StringFilter<"Project"> | string
    tags?: StringNullableListFilter<"Project">
    featured?: BoolFilter<"Project"> | boolean
    client?: StringNullableFilter<"Project"> | string | null
    role?: StringNullableFilter<"Project"> | string | null
    duration?: StringNullableFilter<"Project"> | string | null
    year?: IntNullableFilter<"Project"> | number | null
    caseStudyUrl?: StringNullableFilter<"Project"> | string | null
    impact?: JsonNullableFilter<"Project">
    results?: JsonNullableFilter<"Project">
    displayMetrics?: JsonNullableFilter<"Project">
    metrics?: JsonNullableFilter<"Project">
    testimonial?: JsonNullableFilter<"Project">
    gallery?: JsonNullableFilter<"Project">
    details?: JsonNullableFilter<"Project">
    charts?: JsonNullableFilter<"Project">
    viewCount?: IntFilter<"Project"> | number
    clickCount?: IntFilter<"Project"> | number
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    description?: SortOrder
    longDescription?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    image?: SortOrder
    link?: SortOrderInput | SortOrder
    github?: SortOrderInput | SortOrder
    category?: SortOrder
    tags?: SortOrder
    featured?: SortOrder
    client?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    year?: SortOrderInput | SortOrder
    caseStudyUrl?: SortOrderInput | SortOrder
    impact?: SortOrderInput | SortOrder
    results?: SortOrderInput | SortOrder
    displayMetrics?: SortOrderInput | SortOrder
    metrics?: SortOrderInput | SortOrder
    testimonial?: SortOrderInput | SortOrder
    gallery?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    charts?: SortOrderInput | SortOrder
    viewCount?: SortOrder
    clickCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: ProjectOrderByRelevanceInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    title?: StringFilter<"Project"> | string
    description?: StringFilter<"Project"> | string
    longDescription?: StringNullableFilter<"Project"> | string | null
    content?: StringNullableFilter<"Project"> | string | null
    image?: StringFilter<"Project"> | string
    link?: StringNullableFilter<"Project"> | string | null
    github?: StringNullableFilter<"Project"> | string | null
    category?: StringFilter<"Project"> | string
    tags?: StringNullableListFilter<"Project">
    featured?: BoolFilter<"Project"> | boolean
    client?: StringNullableFilter<"Project"> | string | null
    role?: StringNullableFilter<"Project"> | string | null
    duration?: StringNullableFilter<"Project"> | string | null
    year?: IntNullableFilter<"Project"> | number | null
    caseStudyUrl?: StringNullableFilter<"Project"> | string | null
    impact?: JsonNullableFilter<"Project">
    results?: JsonNullableFilter<"Project">
    displayMetrics?: JsonNullableFilter<"Project">
    metrics?: JsonNullableFilter<"Project">
    testimonial?: JsonNullableFilter<"Project">
    gallery?: JsonNullableFilter<"Project">
    details?: JsonNullableFilter<"Project">
    charts?: JsonNullableFilter<"Project">
    viewCount?: IntFilter<"Project"> | number
    clickCount?: IntFilter<"Project"> | number
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
  }, "id" | "slug">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    description?: SortOrder
    longDescription?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    image?: SortOrder
    link?: SortOrderInput | SortOrder
    github?: SortOrderInput | SortOrder
    category?: SortOrder
    tags?: SortOrder
    featured?: SortOrder
    client?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    year?: SortOrderInput | SortOrder
    caseStudyUrl?: SortOrderInput | SortOrder
    impact?: SortOrderInput | SortOrder
    results?: SortOrderInput | SortOrder
    displayMetrics?: SortOrderInput | SortOrder
    metrics?: SortOrderInput | SortOrder
    testimonial?: SortOrderInput | SortOrder
    gallery?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    charts?: SortOrderInput | SortOrder
    viewCount?: SortOrder
    clickCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _avg?: ProjectAvgOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
    _sum?: ProjectSumOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Project"> | string
    slug?: StringWithAggregatesFilter<"Project"> | string
    title?: StringWithAggregatesFilter<"Project"> | string
    description?: StringWithAggregatesFilter<"Project"> | string
    longDescription?: StringNullableWithAggregatesFilter<"Project"> | string | null
    content?: StringNullableWithAggregatesFilter<"Project"> | string | null
    image?: StringWithAggregatesFilter<"Project"> | string
    link?: StringNullableWithAggregatesFilter<"Project"> | string | null
    github?: StringNullableWithAggregatesFilter<"Project"> | string | null
    category?: StringWithAggregatesFilter<"Project"> | string
    tags?: StringNullableListFilter<"Project">
    featured?: BoolWithAggregatesFilter<"Project"> | boolean
    client?: StringNullableWithAggregatesFilter<"Project"> | string | null
    role?: StringNullableWithAggregatesFilter<"Project"> | string | null
    duration?: StringNullableWithAggregatesFilter<"Project"> | string | null
    year?: IntNullableWithAggregatesFilter<"Project"> | number | null
    caseStudyUrl?: StringNullableWithAggregatesFilter<"Project"> | string | null
    impact?: JsonNullableWithAggregatesFilter<"Project">
    results?: JsonNullableWithAggregatesFilter<"Project">
    displayMetrics?: JsonNullableWithAggregatesFilter<"Project">
    metrics?: JsonNullableWithAggregatesFilter<"Project">
    testimonial?: JsonNullableWithAggregatesFilter<"Project">
    gallery?: JsonNullableWithAggregatesFilter<"Project">
    details?: JsonNullableWithAggregatesFilter<"Project">
    charts?: JsonNullableWithAggregatesFilter<"Project">
    viewCount?: IntWithAggregatesFilter<"Project"> | number
    clickCount?: IntWithAggregatesFilter<"Project"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
  }

  export type ContactSubmissionWhereInput = {
    AND?: ContactSubmissionWhereInput | ContactSubmissionWhereInput[]
    OR?: ContactSubmissionWhereInput[]
    NOT?: ContactSubmissionWhereInput | ContactSubmissionWhereInput[]
    id?: StringFilter<"ContactSubmission"> | string
    name?: StringFilter<"ContactSubmission"> | string
    email?: StringFilter<"ContactSubmission"> | string
    company?: StringNullableFilter<"ContactSubmission"> | string | null
    phone?: StringNullableFilter<"ContactSubmission"> | string | null
    subject?: StringNullableFilter<"ContactSubmission"> | string | null
    message?: StringFilter<"ContactSubmission"> | string
    status?: EnumSubmissionStatusFilter<"ContactSubmission"> | $Enums.SubmissionStatus
    responded?: BoolFilter<"ContactSubmission"> | boolean
    respondedAt?: DateTimeNullableFilter<"ContactSubmission"> | Date | string | null
    notes?: StringNullableFilter<"ContactSubmission"> | string | null
    ipAddress?: StringNullableFilter<"ContactSubmission"> | string | null
    userAgent?: StringNullableFilter<"ContactSubmission"> | string | null
    referer?: StringNullableFilter<"ContactSubmission"> | string | null
    emailSent?: BoolFilter<"ContactSubmission"> | boolean
    emailId?: StringNullableFilter<"ContactSubmission"> | string | null
    emailError?: StringNullableFilter<"ContactSubmission"> | string | null
    createdAt?: DateTimeFilter<"ContactSubmission"> | Date | string
    updatedAt?: DateTimeFilter<"ContactSubmission"> | Date | string
  }

  export type ContactSubmissionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    company?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    subject?: SortOrderInput | SortOrder
    message?: SortOrder
    status?: SortOrder
    responded?: SortOrder
    respondedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    referer?: SortOrderInput | SortOrder
    emailSent?: SortOrder
    emailId?: SortOrderInput | SortOrder
    emailError?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: ContactSubmissionOrderByRelevanceInput
  }

  export type ContactSubmissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContactSubmissionWhereInput | ContactSubmissionWhereInput[]
    OR?: ContactSubmissionWhereInput[]
    NOT?: ContactSubmissionWhereInput | ContactSubmissionWhereInput[]
    name?: StringFilter<"ContactSubmission"> | string
    email?: StringFilter<"ContactSubmission"> | string
    company?: StringNullableFilter<"ContactSubmission"> | string | null
    phone?: StringNullableFilter<"ContactSubmission"> | string | null
    subject?: StringNullableFilter<"ContactSubmission"> | string | null
    message?: StringFilter<"ContactSubmission"> | string
    status?: EnumSubmissionStatusFilter<"ContactSubmission"> | $Enums.SubmissionStatus
    responded?: BoolFilter<"ContactSubmission"> | boolean
    respondedAt?: DateTimeNullableFilter<"ContactSubmission"> | Date | string | null
    notes?: StringNullableFilter<"ContactSubmission"> | string | null
    ipAddress?: StringNullableFilter<"ContactSubmission"> | string | null
    userAgent?: StringNullableFilter<"ContactSubmission"> | string | null
    referer?: StringNullableFilter<"ContactSubmission"> | string | null
    emailSent?: BoolFilter<"ContactSubmission"> | boolean
    emailId?: StringNullableFilter<"ContactSubmission"> | string | null
    emailError?: StringNullableFilter<"ContactSubmission"> | string | null
    createdAt?: DateTimeFilter<"ContactSubmission"> | Date | string
    updatedAt?: DateTimeFilter<"ContactSubmission"> | Date | string
  }, "id">

  export type ContactSubmissionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    company?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    subject?: SortOrderInput | SortOrder
    message?: SortOrder
    status?: SortOrder
    responded?: SortOrder
    respondedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    referer?: SortOrderInput | SortOrder
    emailSent?: SortOrder
    emailId?: SortOrderInput | SortOrder
    emailError?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContactSubmissionCountOrderByAggregateInput
    _max?: ContactSubmissionMaxOrderByAggregateInput
    _min?: ContactSubmissionMinOrderByAggregateInput
  }

  export type ContactSubmissionScalarWhereWithAggregatesInput = {
    AND?: ContactSubmissionScalarWhereWithAggregatesInput | ContactSubmissionScalarWhereWithAggregatesInput[]
    OR?: ContactSubmissionScalarWhereWithAggregatesInput[]
    NOT?: ContactSubmissionScalarWhereWithAggregatesInput | ContactSubmissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContactSubmission"> | string
    name?: StringWithAggregatesFilter<"ContactSubmission"> | string
    email?: StringWithAggregatesFilter<"ContactSubmission"> | string
    company?: StringNullableWithAggregatesFilter<"ContactSubmission"> | string | null
    phone?: StringNullableWithAggregatesFilter<"ContactSubmission"> | string | null
    subject?: StringNullableWithAggregatesFilter<"ContactSubmission"> | string | null
    message?: StringWithAggregatesFilter<"ContactSubmission"> | string
    status?: EnumSubmissionStatusWithAggregatesFilter<"ContactSubmission"> | $Enums.SubmissionStatus
    responded?: BoolWithAggregatesFilter<"ContactSubmission"> | boolean
    respondedAt?: DateTimeNullableWithAggregatesFilter<"ContactSubmission"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"ContactSubmission"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"ContactSubmission"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"ContactSubmission"> | string | null
    referer?: StringNullableWithAggregatesFilter<"ContactSubmission"> | string | null
    emailSent?: BoolWithAggregatesFilter<"ContactSubmission"> | boolean
    emailId?: StringNullableWithAggregatesFilter<"ContactSubmission"> | string | null
    emailError?: StringNullableWithAggregatesFilter<"ContactSubmission"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ContactSubmission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContactSubmission"> | Date | string
  }

  export type SecurityEventWhereInput = {
    AND?: SecurityEventWhereInput | SecurityEventWhereInput[]
    OR?: SecurityEventWhereInput[]
    NOT?: SecurityEventWhereInput | SecurityEventWhereInput[]
    id?: StringFilter<"SecurityEvent"> | string
    type?: EnumSecurityEventTypeFilter<"SecurityEvent"> | $Enums.SecurityEventType
    severity?: EnumSecuritySeverityFilter<"SecurityEvent"> | $Enums.SecuritySeverity
    message?: StringFilter<"SecurityEvent"> | string
    details?: JsonNullableFilter<"SecurityEvent">
    ipAddress?: StringNullableFilter<"SecurityEvent"> | string | null
    userAgent?: StringNullableFilter<"SecurityEvent"> | string | null
    path?: StringNullableFilter<"SecurityEvent"> | string | null
    method?: StringNullableFilter<"SecurityEvent"> | string | null
    clientId?: StringNullableFilter<"SecurityEvent"> | string | null
    sessionId?: StringNullableFilter<"SecurityEvent"> | string | null
    acknowledged?: BoolFilter<"SecurityEvent"> | boolean
    acknowledgedAt?: DateTimeNullableFilter<"SecurityEvent"> | Date | string | null
    acknowledgedBy?: StringNullableFilter<"SecurityEvent"> | string | null
    createdAt?: DateTimeFilter<"SecurityEvent"> | Date | string
  }

  export type SecurityEventOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    severity?: SortOrder
    message?: SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    path?: SortOrderInput | SortOrder
    method?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    acknowledged?: SortOrder
    acknowledgedAt?: SortOrderInput | SortOrder
    acknowledgedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _relevance?: SecurityEventOrderByRelevanceInput
  }

  export type SecurityEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SecurityEventWhereInput | SecurityEventWhereInput[]
    OR?: SecurityEventWhereInput[]
    NOT?: SecurityEventWhereInput | SecurityEventWhereInput[]
    type?: EnumSecurityEventTypeFilter<"SecurityEvent"> | $Enums.SecurityEventType
    severity?: EnumSecuritySeverityFilter<"SecurityEvent"> | $Enums.SecuritySeverity
    message?: StringFilter<"SecurityEvent"> | string
    details?: JsonNullableFilter<"SecurityEvent">
    ipAddress?: StringNullableFilter<"SecurityEvent"> | string | null
    userAgent?: StringNullableFilter<"SecurityEvent"> | string | null
    path?: StringNullableFilter<"SecurityEvent"> | string | null
    method?: StringNullableFilter<"SecurityEvent"> | string | null
    clientId?: StringNullableFilter<"SecurityEvent"> | string | null
    sessionId?: StringNullableFilter<"SecurityEvent"> | string | null
    acknowledged?: BoolFilter<"SecurityEvent"> | boolean
    acknowledgedAt?: DateTimeNullableFilter<"SecurityEvent"> | Date | string | null
    acknowledgedBy?: StringNullableFilter<"SecurityEvent"> | string | null
    createdAt?: DateTimeFilter<"SecurityEvent"> | Date | string
  }, "id">

  export type SecurityEventOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    severity?: SortOrder
    message?: SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    path?: SortOrderInput | SortOrder
    method?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    acknowledged?: SortOrder
    acknowledgedAt?: SortOrderInput | SortOrder
    acknowledgedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SecurityEventCountOrderByAggregateInput
    _max?: SecurityEventMaxOrderByAggregateInput
    _min?: SecurityEventMinOrderByAggregateInput
  }

  export type SecurityEventScalarWhereWithAggregatesInput = {
    AND?: SecurityEventScalarWhereWithAggregatesInput | SecurityEventScalarWhereWithAggregatesInput[]
    OR?: SecurityEventScalarWhereWithAggregatesInput[]
    NOT?: SecurityEventScalarWhereWithAggregatesInput | SecurityEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SecurityEvent"> | string
    type?: EnumSecurityEventTypeWithAggregatesFilter<"SecurityEvent"> | $Enums.SecurityEventType
    severity?: EnumSecuritySeverityWithAggregatesFilter<"SecurityEvent"> | $Enums.SecuritySeverity
    message?: StringWithAggregatesFilter<"SecurityEvent"> | string
    details?: JsonNullableWithAggregatesFilter<"SecurityEvent">
    ipAddress?: StringNullableWithAggregatesFilter<"SecurityEvent"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"SecurityEvent"> | string | null
    path?: StringNullableWithAggregatesFilter<"SecurityEvent"> | string | null
    method?: StringNullableWithAggregatesFilter<"SecurityEvent"> | string | null
    clientId?: StringNullableWithAggregatesFilter<"SecurityEvent"> | string | null
    sessionId?: StringNullableWithAggregatesFilter<"SecurityEvent"> | string | null
    acknowledged?: BoolWithAggregatesFilter<"SecurityEvent"> | boolean
    acknowledgedAt?: DateTimeNullableWithAggregatesFilter<"SecurityEvent"> | Date | string | null
    acknowledgedBy?: StringNullableWithAggregatesFilter<"SecurityEvent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SecurityEvent"> | Date | string
  }

  export type BlogPostCreateInput = {
    id?: string
    title: string
    slug: string
    excerpt?: string | null
    content: string
    contentType?: $Enums.ContentType
    status?: $Enums.PostStatus
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: BlogPostCreatekeywordsInput | string[]
    canonicalUrl?: string | null
    ogTitle?: string | null
    ogDescription?: string | null
    ogImage?: string | null
    twitterTitle?: string | null
    twitterDescription?: string | null
    twitterImage?: string | null
    featuredImage?: string | null
    featuredImageAlt?: string | null
    readingTime?: number | null
    wordCount?: number | null
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    archivedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currentVersion?: number
    viewCount?: number
    likeCount?: number
    shareCount?: number
    commentCount?: number
    seoScore?: number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: Date | string | null
    author: AuthorCreateNestedOneWithoutPostsInput
    category?: CategoryCreateNestedOneWithoutPostsInput
    tags?: PostTagCreateNestedManyWithoutPostInput
    seriesPosts?: SeriesPostCreateNestedManyWithoutPostInput
    relatedPosts?: PostRelationCreateNestedManyWithoutOriginalPostInput
    relatedToPosts?: PostRelationCreateNestedManyWithoutRelatedPostInput
    versions?: PostVersionCreateNestedManyWithoutPostInput
    views?: PostViewCreateNestedManyWithoutPostInput
    interactions?: PostInteractionCreateNestedManyWithoutPostInput
    seoEvents?: SEOEventCreateNestedManyWithoutPostInput
    seoKeywords?: SEOKeywordCreateNestedManyWithoutPostInput
    sitemapEntries?: SitemapEntryCreateNestedManyWithoutPostInput
  }

  export type BlogPostUncheckedCreateInput = {
    id?: string
    title: string
    slug: string
    excerpt?: string | null
    content: string
    contentType?: $Enums.ContentType
    status?: $Enums.PostStatus
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: BlogPostCreatekeywordsInput | string[]
    canonicalUrl?: string | null
    ogTitle?: string | null
    ogDescription?: string | null
    ogImage?: string | null
    twitterTitle?: string | null
    twitterDescription?: string | null
    twitterImage?: string | null
    featuredImage?: string | null
    featuredImageAlt?: string | null
    readingTime?: number | null
    wordCount?: number | null
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    archivedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
    categoryId?: string | null
    currentVersion?: number
    viewCount?: number
    likeCount?: number
    shareCount?: number
    commentCount?: number
    seoScore?: number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: Date | string | null
    tags?: PostTagUncheckedCreateNestedManyWithoutPostInput
    seriesPosts?: SeriesPostUncheckedCreateNestedManyWithoutPostInput
    relatedPosts?: PostRelationUncheckedCreateNestedManyWithoutOriginalPostInput
    relatedToPosts?: PostRelationUncheckedCreateNestedManyWithoutRelatedPostInput
    versions?: PostVersionUncheckedCreateNestedManyWithoutPostInput
    views?: PostViewUncheckedCreateNestedManyWithoutPostInput
    interactions?: PostInteractionUncheckedCreateNestedManyWithoutPostInput
    seoEvents?: SEOEventUncheckedCreateNestedManyWithoutPostInput
    seoKeywords?: SEOKeywordUncheckedCreateNestedManyWithoutPostInput
    sitemapEntries?: SitemapEntryUncheckedCreateNestedManyWithoutPostInput
  }

  export type BlogPostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: BlogPostUpdatekeywordsInput | string[]
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    twitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentVersion?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    seoScore?: NullableFloatFieldUpdateOperationsInput | number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: AuthorUpdateOneRequiredWithoutPostsNestedInput
    category?: CategoryUpdateOneWithoutPostsNestedInput
    tags?: PostTagUpdateManyWithoutPostNestedInput
    seriesPosts?: SeriesPostUpdateManyWithoutPostNestedInput
    relatedPosts?: PostRelationUpdateManyWithoutOriginalPostNestedInput
    relatedToPosts?: PostRelationUpdateManyWithoutRelatedPostNestedInput
    versions?: PostVersionUpdateManyWithoutPostNestedInput
    views?: PostViewUpdateManyWithoutPostNestedInput
    interactions?: PostInteractionUpdateManyWithoutPostNestedInput
    seoEvents?: SEOEventUpdateManyWithoutPostNestedInput
    seoKeywords?: SEOKeywordUpdateManyWithoutPostNestedInput
    sitemapEntries?: SitemapEntryUpdateManyWithoutPostNestedInput
  }

  export type BlogPostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: BlogPostUpdatekeywordsInput | string[]
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    twitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    currentVersion?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    seoScore?: NullableFloatFieldUpdateOperationsInput | number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: PostTagUncheckedUpdateManyWithoutPostNestedInput
    seriesPosts?: SeriesPostUncheckedUpdateManyWithoutPostNestedInput
    relatedPosts?: PostRelationUncheckedUpdateManyWithoutOriginalPostNestedInput
    relatedToPosts?: PostRelationUncheckedUpdateManyWithoutRelatedPostNestedInput
    versions?: PostVersionUncheckedUpdateManyWithoutPostNestedInput
    views?: PostViewUncheckedUpdateManyWithoutPostNestedInput
    interactions?: PostInteractionUncheckedUpdateManyWithoutPostNestedInput
    seoEvents?: SEOEventUncheckedUpdateManyWithoutPostNestedInput
    seoKeywords?: SEOKeywordUncheckedUpdateManyWithoutPostNestedInput
    sitemapEntries?: SitemapEntryUncheckedUpdateManyWithoutPostNestedInput
  }

  export type BlogPostCreateManyInput = {
    id?: string
    title: string
    slug: string
    excerpt?: string | null
    content: string
    contentType?: $Enums.ContentType
    status?: $Enums.PostStatus
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: BlogPostCreatekeywordsInput | string[]
    canonicalUrl?: string | null
    ogTitle?: string | null
    ogDescription?: string | null
    ogImage?: string | null
    twitterTitle?: string | null
    twitterDescription?: string | null
    twitterImage?: string | null
    featuredImage?: string | null
    featuredImageAlt?: string | null
    readingTime?: number | null
    wordCount?: number | null
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    archivedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
    categoryId?: string | null
    currentVersion?: number
    viewCount?: number
    likeCount?: number
    shareCount?: number
    commentCount?: number
    seoScore?: number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: Date | string | null
  }

  export type BlogPostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: BlogPostUpdatekeywordsInput | string[]
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    twitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentVersion?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    seoScore?: NullableFloatFieldUpdateOperationsInput | number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BlogPostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: BlogPostUpdatekeywordsInput | string[]
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    twitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    currentVersion?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    seoScore?: NullableFloatFieldUpdateOperationsInput | number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuthorCreateInput = {
    id?: string
    name: string
    email: string
    slug: string
    bio?: string | null
    avatar?: string | null
    website?: string | null
    twitter?: string | null
    linkedin?: string | null
    github?: string | null
    metaDescription?: string | null
    totalViews?: number
    totalPosts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: BlogPostCreateNestedManyWithoutAuthorInput
    postVersions?: PostVersionCreateNestedManyWithoutAuthorInput
  }

  export type AuthorUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    slug: string
    bio?: string | null
    avatar?: string | null
    website?: string | null
    twitter?: string | null
    linkedin?: string | null
    github?: string | null
    metaDescription?: string | null
    totalViews?: number
    totalPosts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    postVersions?: PostVersionUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type AuthorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    totalViews?: IntFieldUpdateOperationsInput | number
    totalPosts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: BlogPostUpdateManyWithoutAuthorNestedInput
    postVersions?: PostVersionUpdateManyWithoutAuthorNestedInput
  }

  export type AuthorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    totalViews?: IntFieldUpdateOperationsInput | number
    totalPosts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    postVersions?: PostVersionUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type AuthorCreateManyInput = {
    id?: string
    name: string
    email: string
    slug: string
    bio?: string | null
    avatar?: string | null
    website?: string | null
    twitter?: string | null
    linkedin?: string | null
    github?: string | null
    metaDescription?: string | null
    totalViews?: number
    totalPosts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuthorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    totalViews?: IntFieldUpdateOperationsInput | number
    totalPosts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    totalViews?: IntFieldUpdateOperationsInput | number
    totalPosts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    color?: string | null
    icon?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: CategoryCreatekeywordsInput | string[]
    postCount?: number
    totalViews?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    children?: CategoryCreateNestedManyWithoutParentInput
    posts?: BlogPostCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    color?: string | null
    icon?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: CategoryCreatekeywordsInput | string[]
    parentId?: string | null
    postCount?: number
    totalViews?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    posts?: BlogPostUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: CategoryUpdatekeywordsInput | string[]
    postCount?: IntFieldUpdateOperationsInput | number
    totalViews?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
    posts?: BlogPostUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: CategoryUpdatekeywordsInput | string[]
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    totalViews?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    posts?: BlogPostUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    color?: string | null
    icon?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: CategoryCreatekeywordsInput | string[]
    parentId?: string | null
    postCount?: number
    totalViews?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: CategoryUpdatekeywordsInput | string[]
    postCount?: IntFieldUpdateOperationsInput | number
    totalViews?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: CategoryUpdatekeywordsInput | string[]
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    totalViews?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    color?: string | null
    metaDescription?: string | null
    postCount?: number
    totalViews?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    color?: string | null
    metaDescription?: string | null
    postCount?: number
    totalViews?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    totalViews?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    totalViews?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    color?: string | null
    metaDescription?: string | null
    postCount?: number
    totalViews?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    totalViews?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    totalViews?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostTagCreateInput = {
    createdAt?: Date | string
    post: BlogPostCreateNestedOneWithoutTagsInput
    tag: TagCreateNestedOneWithoutPostsInput
  }

  export type PostTagUncheckedCreateInput = {
    postId: string
    tagId: string
    createdAt?: Date | string
  }

  export type PostTagUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: BlogPostUpdateOneRequiredWithoutTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutPostsNestedInput
  }

  export type PostTagUncheckedUpdateInput = {
    postId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostTagCreateManyInput = {
    postId: string
    tagId: string
    createdAt?: Date | string
  }

  export type PostTagUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostTagUncheckedUpdateManyInput = {
    postId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostRelationCreateInput = {
    id?: string
    relationType?: $Enums.RelationType
    createdAt?: Date | string
    originalPost: BlogPostCreateNestedOneWithoutRelatedPostsInput
    relatedPost: BlogPostCreateNestedOneWithoutRelatedToPostsInput
  }

  export type PostRelationUncheckedCreateInput = {
    id?: string
    originalPostId: string
    relatedPostId: string
    relationType?: $Enums.RelationType
    createdAt?: Date | string
  }

  export type PostRelationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationType?: EnumRelationTypeFieldUpdateOperationsInput | $Enums.RelationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originalPost?: BlogPostUpdateOneRequiredWithoutRelatedPostsNestedInput
    relatedPost?: BlogPostUpdateOneRequiredWithoutRelatedToPostsNestedInput
  }

  export type PostRelationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalPostId?: StringFieldUpdateOperationsInput | string
    relatedPostId?: StringFieldUpdateOperationsInput | string
    relationType?: EnumRelationTypeFieldUpdateOperationsInput | $Enums.RelationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostRelationCreateManyInput = {
    id?: string
    originalPostId: string
    relatedPostId: string
    relationType?: $Enums.RelationType
    createdAt?: Date | string
  }

  export type PostRelationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationType?: EnumRelationTypeFieldUpdateOperationsInput | $Enums.RelationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostRelationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalPostId?: StringFieldUpdateOperationsInput | string
    relatedPostId?: StringFieldUpdateOperationsInput | string
    relationType?: EnumRelationTypeFieldUpdateOperationsInput | $Enums.RelationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostVersionCreateInput = {
    id?: string
    version: number
    title: string
    content: string
    excerpt?: string | null
    changeType?: $Enums.ChangeType
    changeNotes?: string | null
    createdAt?: Date | string
    author: AuthorCreateNestedOneWithoutPostVersionsInput
    post: BlogPostCreateNestedOneWithoutVersionsInput
  }

  export type PostVersionUncheckedCreateInput = {
    id?: string
    postId: string
    version: number
    title: string
    content: string
    excerpt?: string | null
    changeType?: $Enums.ChangeType
    changeNotes?: string | null
    authorId: string
    createdAt?: Date | string
  }

  export type PostVersionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    changeType?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    changeNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: AuthorUpdateOneRequiredWithoutPostVersionsNestedInput
    post?: BlogPostUpdateOneRequiredWithoutVersionsNestedInput
  }

  export type PostVersionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    changeType?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    changeNotes?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostVersionCreateManyInput = {
    id?: string
    postId: string
    version: number
    title: string
    content: string
    excerpt?: string | null
    changeType?: $Enums.ChangeType
    changeNotes?: string | null
    authorId: string
    createdAt?: Date | string
  }

  export type PostVersionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    changeType?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    changeNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostVersionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    changeType?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    changeNotes?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostSeriesCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    coverImage?: string | null
    color?: string | null
    totalPosts?: number
    totalViews?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: SeriesPostCreateNestedManyWithoutSeriesInput
  }

  export type PostSeriesUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    coverImage?: string | null
    color?: string | null
    totalPosts?: number
    totalViews?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: SeriesPostUncheckedCreateNestedManyWithoutSeriesInput
  }

  export type PostSeriesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    totalPosts?: IntFieldUpdateOperationsInput | number
    totalViews?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: SeriesPostUpdateManyWithoutSeriesNestedInput
  }

  export type PostSeriesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    totalPosts?: IntFieldUpdateOperationsInput | number
    totalViews?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: SeriesPostUncheckedUpdateManyWithoutSeriesNestedInput
  }

  export type PostSeriesCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    coverImage?: string | null
    color?: string | null
    totalPosts?: number
    totalViews?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostSeriesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    totalPosts?: IntFieldUpdateOperationsInput | number
    totalViews?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostSeriesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    totalPosts?: IntFieldUpdateOperationsInput | number
    totalViews?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeriesPostCreateInput = {
    order: number
    createdAt?: Date | string
    series: PostSeriesCreateNestedOneWithoutPostsInput
    post: BlogPostCreateNestedOneWithoutSeriesPostsInput
  }

  export type SeriesPostUncheckedCreateInput = {
    seriesId: string
    postId: string
    order: number
    createdAt?: Date | string
  }

  export type SeriesPostUpdateInput = {
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    series?: PostSeriesUpdateOneRequiredWithoutPostsNestedInput
    post?: BlogPostUpdateOneRequiredWithoutSeriesPostsNestedInput
  }

  export type SeriesPostUncheckedUpdateInput = {
    seriesId?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeriesPostCreateManyInput = {
    seriesId: string
    postId: string
    order: number
    createdAt?: Date | string
  }

  export type SeriesPostUpdateManyMutationInput = {
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeriesPostUncheckedUpdateManyInput = {
    seriesId?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostViewCreateInput = {
    id?: string
    visitorId?: string | null
    sessionId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    referer?: string | null
    country?: string | null
    region?: string | null
    city?: string | null
    readingTime?: number | null
    scrollDepth?: number | null
    viewedAt?: Date | string
    post: BlogPostCreateNestedOneWithoutViewsInput
  }

  export type PostViewUncheckedCreateInput = {
    id?: string
    postId: string
    visitorId?: string | null
    sessionId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    referer?: string | null
    country?: string | null
    region?: string | null
    city?: string | null
    readingTime?: number | null
    scrollDepth?: number | null
    viewedAt?: Date | string
  }

  export type PostViewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitorId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    referer?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    scrollDepth?: NullableFloatFieldUpdateOperationsInput | number | null
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: BlogPostUpdateOneRequiredWithoutViewsNestedInput
  }

  export type PostViewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    visitorId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    referer?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    scrollDepth?: NullableFloatFieldUpdateOperationsInput | number | null
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostViewCreateManyInput = {
    id?: string
    postId: string
    visitorId?: string | null
    sessionId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    referer?: string | null
    country?: string | null
    region?: string | null
    city?: string | null
    readingTime?: number | null
    scrollDepth?: number | null
    viewedAt?: Date | string
  }

  export type PostViewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitorId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    referer?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    scrollDepth?: NullableFloatFieldUpdateOperationsInput | number | null
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostViewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    visitorId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    referer?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    scrollDepth?: NullableFloatFieldUpdateOperationsInput | number | null
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostInteractionCreateInput = {
    id?: string
    type: $Enums.InteractionType
    visitorId?: string | null
    sessionId?: string | null
    value?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    post: BlogPostCreateNestedOneWithoutInteractionsInput
  }

  export type PostInteractionUncheckedCreateInput = {
    id?: string
    postId: string
    type: $Enums.InteractionType
    visitorId?: string | null
    sessionId?: string | null
    value?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PostInteractionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    visitorId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: BlogPostUpdateOneRequiredWithoutInteractionsNestedInput
  }

  export type PostInteractionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    type?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    visitorId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostInteractionCreateManyInput = {
    id?: string
    postId: string
    type: $Enums.InteractionType
    visitorId?: string | null
    sessionId?: string | null
    value?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PostInteractionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    visitorId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostInteractionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    type?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    visitorId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SEOEventCreateInput = {
    id?: string
    type: $Enums.SEOEventType
    title: string
    description?: string | null
    severity?: $Enums.SEOSeverity
    oldValue?: string | null
    newValue?: string | null
    recommendations?: string | null
    processed?: boolean
    processedAt?: Date | string | null
    createdAt?: Date | string
    post?: BlogPostCreateNestedOneWithoutSeoEventsInput
  }

  export type SEOEventUncheckedCreateInput = {
    id?: string
    postId?: string | null
    type: $Enums.SEOEventType
    title: string
    description?: string | null
    severity?: $Enums.SEOSeverity
    oldValue?: string | null
    newValue?: string | null
    recommendations?: string | null
    processed?: boolean
    processedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SEOEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSEOEventTypeFieldUpdateOperationsInput | $Enums.SEOEventType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: EnumSEOSeverityFieldUpdateOperationsInput | $Enums.SEOSeverity
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: BlogPostUpdateOneWithoutSeoEventsNestedInput
  }

  export type SEOEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSEOEventTypeFieldUpdateOperationsInput | $Enums.SEOEventType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: EnumSEOSeverityFieldUpdateOperationsInput | $Enums.SEOSeverity
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SEOEventCreateManyInput = {
    id?: string
    postId?: string | null
    type: $Enums.SEOEventType
    title: string
    description?: string | null
    severity?: $Enums.SEOSeverity
    oldValue?: string | null
    newValue?: string | null
    recommendations?: string | null
    processed?: boolean
    processedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SEOEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSEOEventTypeFieldUpdateOperationsInput | $Enums.SEOEventType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: EnumSEOSeverityFieldUpdateOperationsInput | $Enums.SEOSeverity
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SEOEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSEOEventTypeFieldUpdateOperationsInput | $Enums.SEOEventType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: EnumSEOSeverityFieldUpdateOperationsInput | $Enums.SEOSeverity
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SEOKeywordCreateInput = {
    id?: string
    keyword: string
    position?: number | null
    searchVolume?: number | null
    difficulty?: number | null
    cpc?: number | null
    clicks?: number
    impressions?: number
    ctr?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastChecked?: Date | string | null
    post?: BlogPostCreateNestedOneWithoutSeoKeywordsInput
  }

  export type SEOKeywordUncheckedCreateInput = {
    id?: string
    keyword: string
    postId?: string | null
    position?: number | null
    searchVolume?: number | null
    difficulty?: number | null
    cpc?: number | null
    clicks?: number
    impressions?: number
    ctr?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastChecked?: Date | string | null
  }

  export type SEOKeywordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    position?: NullableIntFieldUpdateOperationsInput | number | null
    searchVolume?: NullableIntFieldUpdateOperationsInput | number | null
    difficulty?: NullableFloatFieldUpdateOperationsInput | number | null
    cpc?: NullableFloatFieldUpdateOperationsInput | number | null
    clicks?: IntFieldUpdateOperationsInput | number
    impressions?: IntFieldUpdateOperationsInput | number
    ctr?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChecked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    post?: BlogPostUpdateOneWithoutSeoKeywordsNestedInput
  }

  export type SEOKeywordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    searchVolume?: NullableIntFieldUpdateOperationsInput | number | null
    difficulty?: NullableFloatFieldUpdateOperationsInput | number | null
    cpc?: NullableFloatFieldUpdateOperationsInput | number | null
    clicks?: IntFieldUpdateOperationsInput | number
    impressions?: IntFieldUpdateOperationsInput | number
    ctr?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChecked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SEOKeywordCreateManyInput = {
    id?: string
    keyword: string
    postId?: string | null
    position?: number | null
    searchVolume?: number | null
    difficulty?: number | null
    cpc?: number | null
    clicks?: number
    impressions?: number
    ctr?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastChecked?: Date | string | null
  }

  export type SEOKeywordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    position?: NullableIntFieldUpdateOperationsInput | number | null
    searchVolume?: NullableIntFieldUpdateOperationsInput | number | null
    difficulty?: NullableFloatFieldUpdateOperationsInput | number | null
    cpc?: NullableFloatFieldUpdateOperationsInput | number | null
    clicks?: IntFieldUpdateOperationsInput | number
    impressions?: IntFieldUpdateOperationsInput | number
    ctr?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChecked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SEOKeywordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    searchVolume?: NullableIntFieldUpdateOperationsInput | number | null
    difficulty?: NullableFloatFieldUpdateOperationsInput | number | null
    cpc?: NullableFloatFieldUpdateOperationsInput | number | null
    clicks?: IntFieldUpdateOperationsInput | number
    impressions?: IntFieldUpdateOperationsInput | number
    ctr?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChecked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SitemapEntryCreateInput = {
    id?: string
    url: string
    lastMod: Date | string
    changeFreq?: $Enums.ChangeFrequency
    priority?: number
    included?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    post?: BlogPostCreateNestedOneWithoutSitemapEntriesInput
  }

  export type SitemapEntryUncheckedCreateInput = {
    id?: string
    url: string
    lastMod: Date | string
    changeFreq?: $Enums.ChangeFrequency
    priority?: number
    postId?: string | null
    included?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SitemapEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    lastMod?: DateTimeFieldUpdateOperationsInput | Date | string
    changeFreq?: EnumChangeFrequencyFieldUpdateOperationsInput | $Enums.ChangeFrequency
    priority?: FloatFieldUpdateOperationsInput | number
    included?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: BlogPostUpdateOneWithoutSitemapEntriesNestedInput
  }

  export type SitemapEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    lastMod?: DateTimeFieldUpdateOperationsInput | Date | string
    changeFreq?: EnumChangeFrequencyFieldUpdateOperationsInput | $Enums.ChangeFrequency
    priority?: FloatFieldUpdateOperationsInput | number
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    included?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SitemapEntryCreateManyInput = {
    id?: string
    url: string
    lastMod: Date | string
    changeFreq?: $Enums.ChangeFrequency
    priority?: number
    postId?: string | null
    included?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SitemapEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    lastMod?: DateTimeFieldUpdateOperationsInput | Date | string
    changeFreq?: EnumChangeFrequencyFieldUpdateOperationsInput | $Enums.ChangeFrequency
    priority?: FloatFieldUpdateOperationsInput | number
    included?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SitemapEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    lastMod?: DateTimeFieldUpdateOperationsInput | Date | string
    changeFreq?: EnumChangeFrequencyFieldUpdateOperationsInput | $Enums.ChangeFrequency
    priority?: FloatFieldUpdateOperationsInput | number
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    included?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateInput = {
    id?: string
    slug: string
    title: string
    description: string
    longDescription?: string | null
    content?: string | null
    image: string
    link?: string | null
    github?: string | null
    category: string
    tags?: ProjectCreatetagsInput | string[]
    featured?: boolean
    client?: string | null
    role?: string | null
    duration?: string | null
    year?: number | null
    caseStudyUrl?: string | null
    impact?: NullableJsonNullValueInput | InputJsonValue
    results?: NullableJsonNullValueInput | InputJsonValue
    displayMetrics?: NullableJsonNullValueInput | InputJsonValue
    metrics?: NullableJsonNullValueInput | InputJsonValue
    testimonial?: NullableJsonNullValueInput | InputJsonValue
    gallery?: NullableJsonNullValueInput | InputJsonValue
    details?: NullableJsonNullValueInput | InputJsonValue
    charts?: NullableJsonNullValueInput | InputJsonValue
    viewCount?: number
    clickCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUncheckedCreateInput = {
    id?: string
    slug: string
    title: string
    description: string
    longDescription?: string | null
    content?: string | null
    image: string
    link?: string | null
    github?: string | null
    category: string
    tags?: ProjectCreatetagsInput | string[]
    featured?: boolean
    client?: string | null
    role?: string | null
    duration?: string | null
    year?: number | null
    caseStudyUrl?: string | null
    impact?: NullableJsonNullValueInput | InputJsonValue
    results?: NullableJsonNullValueInput | InputJsonValue
    displayMetrics?: NullableJsonNullValueInput | InputJsonValue
    metrics?: NullableJsonNullValueInput | InputJsonValue
    testimonial?: NullableJsonNullValueInput | InputJsonValue
    gallery?: NullableJsonNullValueInput | InputJsonValue
    details?: NullableJsonNullValueInput | InputJsonValue
    charts?: NullableJsonNullValueInput | InputJsonValue
    viewCount?: number
    clickCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    image?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    tags?: ProjectUpdatetagsInput | string[]
    featured?: BoolFieldUpdateOperationsInput | boolean
    client?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    caseStudyUrl?: NullableStringFieldUpdateOperationsInput | string | null
    impact?: NullableJsonNullValueInput | InputJsonValue
    results?: NullableJsonNullValueInput | InputJsonValue
    displayMetrics?: NullableJsonNullValueInput | InputJsonValue
    metrics?: NullableJsonNullValueInput | InputJsonValue
    testimonial?: NullableJsonNullValueInput | InputJsonValue
    gallery?: NullableJsonNullValueInput | InputJsonValue
    details?: NullableJsonNullValueInput | InputJsonValue
    charts?: NullableJsonNullValueInput | InputJsonValue
    viewCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    image?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    tags?: ProjectUpdatetagsInput | string[]
    featured?: BoolFieldUpdateOperationsInput | boolean
    client?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    caseStudyUrl?: NullableStringFieldUpdateOperationsInput | string | null
    impact?: NullableJsonNullValueInput | InputJsonValue
    results?: NullableJsonNullValueInput | InputJsonValue
    displayMetrics?: NullableJsonNullValueInput | InputJsonValue
    metrics?: NullableJsonNullValueInput | InputJsonValue
    testimonial?: NullableJsonNullValueInput | InputJsonValue
    gallery?: NullableJsonNullValueInput | InputJsonValue
    details?: NullableJsonNullValueInput | InputJsonValue
    charts?: NullableJsonNullValueInput | InputJsonValue
    viewCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateManyInput = {
    id?: string
    slug: string
    title: string
    description: string
    longDescription?: string | null
    content?: string | null
    image: string
    link?: string | null
    github?: string | null
    category: string
    tags?: ProjectCreatetagsInput | string[]
    featured?: boolean
    client?: string | null
    role?: string | null
    duration?: string | null
    year?: number | null
    caseStudyUrl?: string | null
    impact?: NullableJsonNullValueInput | InputJsonValue
    results?: NullableJsonNullValueInput | InputJsonValue
    displayMetrics?: NullableJsonNullValueInput | InputJsonValue
    metrics?: NullableJsonNullValueInput | InputJsonValue
    testimonial?: NullableJsonNullValueInput | InputJsonValue
    gallery?: NullableJsonNullValueInput | InputJsonValue
    details?: NullableJsonNullValueInput | InputJsonValue
    charts?: NullableJsonNullValueInput | InputJsonValue
    viewCount?: number
    clickCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    image?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    tags?: ProjectUpdatetagsInput | string[]
    featured?: BoolFieldUpdateOperationsInput | boolean
    client?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    caseStudyUrl?: NullableStringFieldUpdateOperationsInput | string | null
    impact?: NullableJsonNullValueInput | InputJsonValue
    results?: NullableJsonNullValueInput | InputJsonValue
    displayMetrics?: NullableJsonNullValueInput | InputJsonValue
    metrics?: NullableJsonNullValueInput | InputJsonValue
    testimonial?: NullableJsonNullValueInput | InputJsonValue
    gallery?: NullableJsonNullValueInput | InputJsonValue
    details?: NullableJsonNullValueInput | InputJsonValue
    charts?: NullableJsonNullValueInput | InputJsonValue
    viewCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    image?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    tags?: ProjectUpdatetagsInput | string[]
    featured?: BoolFieldUpdateOperationsInput | boolean
    client?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    caseStudyUrl?: NullableStringFieldUpdateOperationsInput | string | null
    impact?: NullableJsonNullValueInput | InputJsonValue
    results?: NullableJsonNullValueInput | InputJsonValue
    displayMetrics?: NullableJsonNullValueInput | InputJsonValue
    metrics?: NullableJsonNullValueInput | InputJsonValue
    testimonial?: NullableJsonNullValueInput | InputJsonValue
    gallery?: NullableJsonNullValueInput | InputJsonValue
    details?: NullableJsonNullValueInput | InputJsonValue
    charts?: NullableJsonNullValueInput | InputJsonValue
    viewCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactSubmissionCreateInput = {
    id?: string
    name: string
    email: string
    company?: string | null
    phone?: string | null
    subject?: string | null
    message: string
    status?: $Enums.SubmissionStatus
    responded?: boolean
    respondedAt?: Date | string | null
    notes?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    referer?: string | null
    emailSent?: boolean
    emailId?: string | null
    emailError?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactSubmissionUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    company?: string | null
    phone?: string | null
    subject?: string | null
    message: string
    status?: $Enums.SubmissionStatus
    responded?: boolean
    respondedAt?: Date | string | null
    notes?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    referer?: string | null
    emailSent?: boolean
    emailId?: string | null
    emailError?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactSubmissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus
    responded?: BoolFieldUpdateOperationsInput | boolean
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    referer?: NullableStringFieldUpdateOperationsInput | string | null
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    emailId?: NullableStringFieldUpdateOperationsInput | string | null
    emailError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactSubmissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus
    responded?: BoolFieldUpdateOperationsInput | boolean
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    referer?: NullableStringFieldUpdateOperationsInput | string | null
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    emailId?: NullableStringFieldUpdateOperationsInput | string | null
    emailError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactSubmissionCreateManyInput = {
    id?: string
    name: string
    email: string
    company?: string | null
    phone?: string | null
    subject?: string | null
    message: string
    status?: $Enums.SubmissionStatus
    responded?: boolean
    respondedAt?: Date | string | null
    notes?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    referer?: string | null
    emailSent?: boolean
    emailId?: string | null
    emailError?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactSubmissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus
    responded?: BoolFieldUpdateOperationsInput | boolean
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    referer?: NullableStringFieldUpdateOperationsInput | string | null
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    emailId?: NullableStringFieldUpdateOperationsInput | string | null
    emailError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactSubmissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus
    responded?: BoolFieldUpdateOperationsInput | boolean
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    referer?: NullableStringFieldUpdateOperationsInput | string | null
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    emailId?: NullableStringFieldUpdateOperationsInput | string | null
    emailError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityEventCreateInput = {
    id?: string
    type: $Enums.SecurityEventType
    severity?: $Enums.SecuritySeverity
    message: string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    path?: string | null
    method?: string | null
    clientId?: string | null
    sessionId?: string | null
    acknowledged?: boolean
    acknowledgedAt?: Date | string | null
    acknowledgedBy?: string | null
    createdAt?: Date | string
  }

  export type SecurityEventUncheckedCreateInput = {
    id?: string
    type: $Enums.SecurityEventType
    severity?: $Enums.SecuritySeverity
    message: string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    path?: string | null
    method?: string | null
    clientId?: string | null
    sessionId?: string | null
    acknowledged?: boolean
    acknowledgedAt?: Date | string | null
    acknowledgedBy?: string | null
    createdAt?: Date | string
  }

  export type SecurityEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSecurityEventTypeFieldUpdateOperationsInput | $Enums.SecurityEventType
    severity?: EnumSecuritySeverityFieldUpdateOperationsInput | $Enums.SecuritySeverity
    message?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    path?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSecurityEventTypeFieldUpdateOperationsInput | $Enums.SecurityEventType
    severity?: EnumSecuritySeverityFieldUpdateOperationsInput | $Enums.SecuritySeverity
    message?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    path?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityEventCreateManyInput = {
    id?: string
    type: $Enums.SecurityEventType
    severity?: $Enums.SecuritySeverity
    message: string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    path?: string | null
    method?: string | null
    clientId?: string | null
    sessionId?: string | null
    acknowledged?: boolean
    acknowledgedAt?: Date | string | null
    acknowledgedBy?: string | null
    createdAt?: Date | string
  }

  export type SecurityEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSecurityEventTypeFieldUpdateOperationsInput | $Enums.SecurityEventType
    severity?: EnumSecuritySeverityFieldUpdateOperationsInput | $Enums.SecuritySeverity
    message?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    path?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSecurityEventTypeFieldUpdateOperationsInput | $Enums.SecurityEventType
    severity?: EnumSecuritySeverityFieldUpdateOperationsInput | $Enums.SecuritySeverity
    message?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    path?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumContentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentType | EnumContentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContentTypeFilter<$PrismaModel> | $Enums.ContentType
  }

  export type EnumPostStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PostStatus | EnumPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPostStatusFilter<$PrismaModel> | $Enums.PostStatus
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AuthorScalarRelationFilter = {
    is?: AuthorWhereInput
    isNot?: AuthorWhereInput
  }

  export type CategoryNullableScalarRelationFilter = {
    is?: CategoryWhereInput | null
    isNot?: CategoryWhereInput | null
  }

  export type PostTagListRelationFilter = {
    every?: PostTagWhereInput
    some?: PostTagWhereInput
    none?: PostTagWhereInput
  }

  export type SeriesPostListRelationFilter = {
    every?: SeriesPostWhereInput
    some?: SeriesPostWhereInput
    none?: SeriesPostWhereInput
  }

  export type PostRelationListRelationFilter = {
    every?: PostRelationWhereInput
    some?: PostRelationWhereInput
    none?: PostRelationWhereInput
  }

  export type PostVersionListRelationFilter = {
    every?: PostVersionWhereInput
    some?: PostVersionWhereInput
    none?: PostVersionWhereInput
  }

  export type PostViewListRelationFilter = {
    every?: PostViewWhereInput
    some?: PostViewWhereInput
    none?: PostViewWhereInput
  }

  export type PostInteractionListRelationFilter = {
    every?: PostInteractionWhereInput
    some?: PostInteractionWhereInput
    none?: PostInteractionWhereInput
  }

  export type SEOEventListRelationFilter = {
    every?: SEOEventWhereInput
    some?: SEOEventWhereInput
    none?: SEOEventWhereInput
  }

  export type SEOKeywordListRelationFilter = {
    every?: SEOKeywordWhereInput
    some?: SEOKeywordWhereInput
    none?: SEOKeywordWhereInput
  }

  export type SitemapEntryListRelationFilter = {
    every?: SitemapEntryWhereInput
    some?: SitemapEntryWhereInput
    none?: SitemapEntryWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PostTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SeriesPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostRelationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostVersionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostViewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostInteractionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SEOEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SEOKeywordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SitemapEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlogPostOrderByRelevanceInput = {
    fields: BlogPostOrderByRelevanceFieldEnum | BlogPostOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BlogPostCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    contentType?: SortOrder
    status?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    keywords?: SortOrder
    canonicalUrl?: SortOrder
    ogTitle?: SortOrder
    ogDescription?: SortOrder
    ogImage?: SortOrder
    twitterTitle?: SortOrder
    twitterDescription?: SortOrder
    twitterImage?: SortOrder
    featuredImage?: SortOrder
    featuredImageAlt?: SortOrder
    readingTime?: SortOrder
    wordCount?: SortOrder
    publishedAt?: SortOrder
    scheduledAt?: SortOrder
    archivedAt?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
    categoryId?: SortOrder
    currentVersion?: SortOrder
    viewCount?: SortOrder
    likeCount?: SortOrder
    shareCount?: SortOrder
    commentCount?: SortOrder
    seoScore?: SortOrder
    seoAnalysis?: SortOrder
    lastSeoCheck?: SortOrder
  }

  export type BlogPostAvgOrderByAggregateInput = {
    readingTime?: SortOrder
    wordCount?: SortOrder
    currentVersion?: SortOrder
    viewCount?: SortOrder
    likeCount?: SortOrder
    shareCount?: SortOrder
    commentCount?: SortOrder
    seoScore?: SortOrder
  }

  export type BlogPostMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    contentType?: SortOrder
    status?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    canonicalUrl?: SortOrder
    ogTitle?: SortOrder
    ogDescription?: SortOrder
    ogImage?: SortOrder
    twitterTitle?: SortOrder
    twitterDescription?: SortOrder
    twitterImage?: SortOrder
    featuredImage?: SortOrder
    featuredImageAlt?: SortOrder
    readingTime?: SortOrder
    wordCount?: SortOrder
    publishedAt?: SortOrder
    scheduledAt?: SortOrder
    archivedAt?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
    categoryId?: SortOrder
    currentVersion?: SortOrder
    viewCount?: SortOrder
    likeCount?: SortOrder
    shareCount?: SortOrder
    commentCount?: SortOrder
    seoScore?: SortOrder
    lastSeoCheck?: SortOrder
  }

  export type BlogPostMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    contentType?: SortOrder
    status?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    canonicalUrl?: SortOrder
    ogTitle?: SortOrder
    ogDescription?: SortOrder
    ogImage?: SortOrder
    twitterTitle?: SortOrder
    twitterDescription?: SortOrder
    twitterImage?: SortOrder
    featuredImage?: SortOrder
    featuredImageAlt?: SortOrder
    readingTime?: SortOrder
    wordCount?: SortOrder
    publishedAt?: SortOrder
    scheduledAt?: SortOrder
    archivedAt?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
    categoryId?: SortOrder
    currentVersion?: SortOrder
    viewCount?: SortOrder
    likeCount?: SortOrder
    shareCount?: SortOrder
    commentCount?: SortOrder
    seoScore?: SortOrder
    lastSeoCheck?: SortOrder
  }

  export type BlogPostSumOrderByAggregateInput = {
    readingTime?: SortOrder
    wordCount?: SortOrder
    currentVersion?: SortOrder
    viewCount?: SortOrder
    likeCount?: SortOrder
    shareCount?: SortOrder
    commentCount?: SortOrder
    seoScore?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumContentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentType | EnumContentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContentTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContentTypeFilter<$PrismaModel>
    _max?: NestedEnumContentTypeFilter<$PrismaModel>
  }

  export type EnumPostStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostStatus | EnumPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPostStatusWithAggregatesFilter<$PrismaModel> | $Enums.PostStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostStatusFilter<$PrismaModel>
    _max?: NestedEnumPostStatusFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type BlogPostListRelationFilter = {
    every?: BlogPostWhereInput
    some?: BlogPostWhereInput
    none?: BlogPostWhereInput
  }

  export type BlogPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuthorOrderByRelevanceInput = {
    fields: AuthorOrderByRelevanceFieldEnum | AuthorOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AuthorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    slug?: SortOrder
    bio?: SortOrder
    avatar?: SortOrder
    website?: SortOrder
    twitter?: SortOrder
    linkedin?: SortOrder
    github?: SortOrder
    metaDescription?: SortOrder
    totalViews?: SortOrder
    totalPosts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuthorAvgOrderByAggregateInput = {
    totalViews?: SortOrder
    totalPosts?: SortOrder
  }

  export type AuthorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    slug?: SortOrder
    bio?: SortOrder
    avatar?: SortOrder
    website?: SortOrder
    twitter?: SortOrder
    linkedin?: SortOrder
    github?: SortOrder
    metaDescription?: SortOrder
    totalViews?: SortOrder
    totalPosts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuthorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    slug?: SortOrder
    bio?: SortOrder
    avatar?: SortOrder
    website?: SortOrder
    twitter?: SortOrder
    linkedin?: SortOrder
    github?: SortOrder
    metaDescription?: SortOrder
    totalViews?: SortOrder
    totalPosts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuthorSumOrderByAggregateInput = {
    totalViews?: SortOrder
    totalPosts?: SortOrder
  }

  export type CategoryListRelationFilter = {
    every?: CategoryWhereInput
    some?: CategoryWhereInput
    none?: CategoryWhereInput
  }

  export type CategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryOrderByRelevanceInput = {
    fields: CategoryOrderByRelevanceFieldEnum | CategoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    keywords?: SortOrder
    parentId?: SortOrder
    postCount?: SortOrder
    totalViews?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryAvgOrderByAggregateInput = {
    postCount?: SortOrder
    totalViews?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    parentId?: SortOrder
    postCount?: SortOrder
    totalViews?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    parentId?: SortOrder
    postCount?: SortOrder
    totalViews?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategorySumOrderByAggregateInput = {
    postCount?: SortOrder
    totalViews?: SortOrder
  }

  export type TagOrderByRelevanceInput = {
    fields: TagOrderByRelevanceFieldEnum | TagOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    color?: SortOrder
    metaDescription?: SortOrder
    postCount?: SortOrder
    totalViews?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagAvgOrderByAggregateInput = {
    postCount?: SortOrder
    totalViews?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    color?: SortOrder
    metaDescription?: SortOrder
    postCount?: SortOrder
    totalViews?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    color?: SortOrder
    metaDescription?: SortOrder
    postCount?: SortOrder
    totalViews?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagSumOrderByAggregateInput = {
    postCount?: SortOrder
    totalViews?: SortOrder
  }

  export type BlogPostScalarRelationFilter = {
    is?: BlogPostWhereInput
    isNot?: BlogPostWhereInput
  }

  export type TagScalarRelationFilter = {
    is?: TagWhereInput
    isNot?: TagWhereInput
  }

  export type PostTagOrderByRelevanceInput = {
    fields: PostTagOrderByRelevanceFieldEnum | PostTagOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PostTagPostIdTagIdCompoundUniqueInput = {
    postId: string
    tagId: string
  }

  export type PostTagCountOrderByAggregateInput = {
    postId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
  }

  export type PostTagMaxOrderByAggregateInput = {
    postId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
  }

  export type PostTagMinOrderByAggregateInput = {
    postId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumRelationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RelationType | EnumRelationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RelationType[] | ListEnumRelationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RelationType[] | ListEnumRelationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRelationTypeFilter<$PrismaModel> | $Enums.RelationType
  }

  export type PostRelationOrderByRelevanceInput = {
    fields: PostRelationOrderByRelevanceFieldEnum | PostRelationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PostRelationOriginalPostIdRelatedPostIdCompoundUniqueInput = {
    originalPostId: string
    relatedPostId: string
  }

  export type PostRelationCountOrderByAggregateInput = {
    id?: SortOrder
    originalPostId?: SortOrder
    relatedPostId?: SortOrder
    relationType?: SortOrder
    createdAt?: SortOrder
  }

  export type PostRelationMaxOrderByAggregateInput = {
    id?: SortOrder
    originalPostId?: SortOrder
    relatedPostId?: SortOrder
    relationType?: SortOrder
    createdAt?: SortOrder
  }

  export type PostRelationMinOrderByAggregateInput = {
    id?: SortOrder
    originalPostId?: SortOrder
    relatedPostId?: SortOrder
    relationType?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumRelationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RelationType | EnumRelationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RelationType[] | ListEnumRelationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RelationType[] | ListEnumRelationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRelationTypeWithAggregatesFilter<$PrismaModel> | $Enums.RelationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRelationTypeFilter<$PrismaModel>
    _max?: NestedEnumRelationTypeFilter<$PrismaModel>
  }

  export type EnumChangeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ChangeType | EnumChangeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChangeType[] | ListEnumChangeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChangeType[] | ListEnumChangeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChangeTypeFilter<$PrismaModel> | $Enums.ChangeType
  }

  export type PostVersionOrderByRelevanceInput = {
    fields: PostVersionOrderByRelevanceFieldEnum | PostVersionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PostVersionPostIdVersionCompoundUniqueInput = {
    postId: string
    version: number
  }

  export type PostVersionCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    version?: SortOrder
    title?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
    changeType?: SortOrder
    changeNotes?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
  }

  export type PostVersionAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type PostVersionMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    version?: SortOrder
    title?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
    changeType?: SortOrder
    changeNotes?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
  }

  export type PostVersionMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    version?: SortOrder
    title?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
    changeType?: SortOrder
    changeNotes?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
  }

  export type PostVersionSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type EnumChangeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChangeType | EnumChangeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChangeType[] | ListEnumChangeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChangeType[] | ListEnumChangeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChangeTypeWithAggregatesFilter<$PrismaModel> | $Enums.ChangeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChangeTypeFilter<$PrismaModel>
    _max?: NestedEnumChangeTypeFilter<$PrismaModel>
  }

  export type PostSeriesOrderByRelevanceInput = {
    fields: PostSeriesOrderByRelevanceFieldEnum | PostSeriesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PostSeriesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    coverImage?: SortOrder
    color?: SortOrder
    totalPosts?: SortOrder
    totalViews?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostSeriesAvgOrderByAggregateInput = {
    totalPosts?: SortOrder
    totalViews?: SortOrder
  }

  export type PostSeriesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    coverImage?: SortOrder
    color?: SortOrder
    totalPosts?: SortOrder
    totalViews?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostSeriesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    coverImage?: SortOrder
    color?: SortOrder
    totalPosts?: SortOrder
    totalViews?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostSeriesSumOrderByAggregateInput = {
    totalPosts?: SortOrder
    totalViews?: SortOrder
  }

  export type PostSeriesScalarRelationFilter = {
    is?: PostSeriesWhereInput
    isNot?: PostSeriesWhereInput
  }

  export type SeriesPostOrderByRelevanceInput = {
    fields: SeriesPostOrderByRelevanceFieldEnum | SeriesPostOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SeriesPostSeriesIdOrderCompoundUniqueInput = {
    seriesId: string
    order: number
  }

  export type SeriesPostSeriesIdPostIdCompoundUniqueInput = {
    seriesId: string
    postId: string
  }

  export type SeriesPostCountOrderByAggregateInput = {
    seriesId?: SortOrder
    postId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type SeriesPostAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type SeriesPostMaxOrderByAggregateInput = {
    seriesId?: SortOrder
    postId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type SeriesPostMinOrderByAggregateInput = {
    seriesId?: SortOrder
    postId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type SeriesPostSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type PostViewOrderByRelevanceInput = {
    fields: PostViewOrderByRelevanceFieldEnum | PostViewOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PostViewCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    visitorId?: SortOrder
    sessionId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    referer?: SortOrder
    country?: SortOrder
    region?: SortOrder
    city?: SortOrder
    readingTime?: SortOrder
    scrollDepth?: SortOrder
    viewedAt?: SortOrder
  }

  export type PostViewAvgOrderByAggregateInput = {
    readingTime?: SortOrder
    scrollDepth?: SortOrder
  }

  export type PostViewMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    visitorId?: SortOrder
    sessionId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    referer?: SortOrder
    country?: SortOrder
    region?: SortOrder
    city?: SortOrder
    readingTime?: SortOrder
    scrollDepth?: SortOrder
    viewedAt?: SortOrder
  }

  export type PostViewMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    visitorId?: SortOrder
    sessionId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    referer?: SortOrder
    country?: SortOrder
    region?: SortOrder
    city?: SortOrder
    readingTime?: SortOrder
    scrollDepth?: SortOrder
    viewedAt?: SortOrder
  }

  export type PostViewSumOrderByAggregateInput = {
    readingTime?: SortOrder
    scrollDepth?: SortOrder
  }

  export type EnumInteractionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InteractionType | EnumInteractionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InteractionType[] | ListEnumInteractionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InteractionType[] | ListEnumInteractionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInteractionTypeFilter<$PrismaModel> | $Enums.InteractionType
  }

  export type PostInteractionOrderByRelevanceInput = {
    fields: PostInteractionOrderByRelevanceFieldEnum | PostInteractionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PostInteractionCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    type?: SortOrder
    visitorId?: SortOrder
    sessionId?: SortOrder
    value?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type PostInteractionMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    type?: SortOrder
    visitorId?: SortOrder
    sessionId?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
  }

  export type PostInteractionMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    type?: SortOrder
    visitorId?: SortOrder
    sessionId?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumInteractionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InteractionType | EnumInteractionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InteractionType[] | ListEnumInteractionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InteractionType[] | ListEnumInteractionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInteractionTypeWithAggregatesFilter<$PrismaModel> | $Enums.InteractionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInteractionTypeFilter<$PrismaModel>
    _max?: NestedEnumInteractionTypeFilter<$PrismaModel>
  }

  export type EnumSEOEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SEOEventType | EnumSEOEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SEOEventType[] | ListEnumSEOEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SEOEventType[] | ListEnumSEOEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSEOEventTypeFilter<$PrismaModel> | $Enums.SEOEventType
  }

  export type EnumSEOSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.SEOSeverity | EnumSEOSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.SEOSeverity[] | ListEnumSEOSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.SEOSeverity[] | ListEnumSEOSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumSEOSeverityFilter<$PrismaModel> | $Enums.SEOSeverity
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type BlogPostNullableScalarRelationFilter = {
    is?: BlogPostWhereInput | null
    isNot?: BlogPostWhereInput | null
  }

  export type SEOEventOrderByRelevanceInput = {
    fields: SEOEventOrderByRelevanceFieldEnum | SEOEventOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SEOEventCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    severity?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    recommendations?: SortOrder
    processed?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SEOEventMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    severity?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    recommendations?: SortOrder
    processed?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SEOEventMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    severity?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    recommendations?: SortOrder
    processed?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumSEOEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SEOEventType | EnumSEOEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SEOEventType[] | ListEnumSEOEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SEOEventType[] | ListEnumSEOEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSEOEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.SEOEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSEOEventTypeFilter<$PrismaModel>
    _max?: NestedEnumSEOEventTypeFilter<$PrismaModel>
  }

  export type EnumSEOSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SEOSeverity | EnumSEOSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.SEOSeverity[] | ListEnumSEOSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.SEOSeverity[] | ListEnumSEOSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumSEOSeverityWithAggregatesFilter<$PrismaModel> | $Enums.SEOSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSEOSeverityFilter<$PrismaModel>
    _max?: NestedEnumSEOSeverityFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type SEOKeywordOrderByRelevanceInput = {
    fields: SEOKeywordOrderByRelevanceFieldEnum | SEOKeywordOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SEOKeywordKeywordPostIdCompoundUniqueInput = {
    keyword: string
    postId: string
  }

  export type SEOKeywordCountOrderByAggregateInput = {
    id?: SortOrder
    keyword?: SortOrder
    postId?: SortOrder
    position?: SortOrder
    searchVolume?: SortOrder
    difficulty?: SortOrder
    cpc?: SortOrder
    clicks?: SortOrder
    impressions?: SortOrder
    ctr?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastChecked?: SortOrder
  }

  export type SEOKeywordAvgOrderByAggregateInput = {
    position?: SortOrder
    searchVolume?: SortOrder
    difficulty?: SortOrder
    cpc?: SortOrder
    clicks?: SortOrder
    impressions?: SortOrder
    ctr?: SortOrder
  }

  export type SEOKeywordMaxOrderByAggregateInput = {
    id?: SortOrder
    keyword?: SortOrder
    postId?: SortOrder
    position?: SortOrder
    searchVolume?: SortOrder
    difficulty?: SortOrder
    cpc?: SortOrder
    clicks?: SortOrder
    impressions?: SortOrder
    ctr?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastChecked?: SortOrder
  }

  export type SEOKeywordMinOrderByAggregateInput = {
    id?: SortOrder
    keyword?: SortOrder
    postId?: SortOrder
    position?: SortOrder
    searchVolume?: SortOrder
    difficulty?: SortOrder
    cpc?: SortOrder
    clicks?: SortOrder
    impressions?: SortOrder
    ctr?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastChecked?: SortOrder
  }

  export type SEOKeywordSumOrderByAggregateInput = {
    position?: SortOrder
    searchVolume?: SortOrder
    difficulty?: SortOrder
    cpc?: SortOrder
    clicks?: SortOrder
    impressions?: SortOrder
    ctr?: SortOrder
  }

  export type EnumChangeFrequencyFilter<$PrismaModel = never> = {
    equals?: $Enums.ChangeFrequency | EnumChangeFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.ChangeFrequency[] | ListEnumChangeFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChangeFrequency[] | ListEnumChangeFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumChangeFrequencyFilter<$PrismaModel> | $Enums.ChangeFrequency
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type SitemapEntryOrderByRelevanceInput = {
    fields: SitemapEntryOrderByRelevanceFieldEnum | SitemapEntryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SitemapEntryCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    lastMod?: SortOrder
    changeFreq?: SortOrder
    priority?: SortOrder
    postId?: SortOrder
    included?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SitemapEntryAvgOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type SitemapEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    lastMod?: SortOrder
    changeFreq?: SortOrder
    priority?: SortOrder
    postId?: SortOrder
    included?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SitemapEntryMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    lastMod?: SortOrder
    changeFreq?: SortOrder
    priority?: SortOrder
    postId?: SortOrder
    included?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SitemapEntrySumOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type EnumChangeFrequencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChangeFrequency | EnumChangeFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.ChangeFrequency[] | ListEnumChangeFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChangeFrequency[] | ListEnumChangeFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumChangeFrequencyWithAggregatesFilter<$PrismaModel> | $Enums.ChangeFrequency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChangeFrequencyFilter<$PrismaModel>
    _max?: NestedEnumChangeFrequencyFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type ProjectOrderByRelevanceInput = {
    fields: ProjectOrderByRelevanceFieldEnum | ProjectOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    description?: SortOrder
    longDescription?: SortOrder
    content?: SortOrder
    image?: SortOrder
    link?: SortOrder
    github?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    featured?: SortOrder
    client?: SortOrder
    role?: SortOrder
    duration?: SortOrder
    year?: SortOrder
    caseStudyUrl?: SortOrder
    impact?: SortOrder
    results?: SortOrder
    displayMetrics?: SortOrder
    metrics?: SortOrder
    testimonial?: SortOrder
    gallery?: SortOrder
    details?: SortOrder
    charts?: SortOrder
    viewCount?: SortOrder
    clickCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectAvgOrderByAggregateInput = {
    year?: SortOrder
    viewCount?: SortOrder
    clickCount?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    description?: SortOrder
    longDescription?: SortOrder
    content?: SortOrder
    image?: SortOrder
    link?: SortOrder
    github?: SortOrder
    category?: SortOrder
    featured?: SortOrder
    client?: SortOrder
    role?: SortOrder
    duration?: SortOrder
    year?: SortOrder
    caseStudyUrl?: SortOrder
    viewCount?: SortOrder
    clickCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    description?: SortOrder
    longDescription?: SortOrder
    content?: SortOrder
    image?: SortOrder
    link?: SortOrder
    github?: SortOrder
    category?: SortOrder
    featured?: SortOrder
    client?: SortOrder
    role?: SortOrder
    duration?: SortOrder
    year?: SortOrder
    caseStudyUrl?: SortOrder
    viewCount?: SortOrder
    clickCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectSumOrderByAggregateInput = {
    year?: SortOrder
    viewCount?: SortOrder
    clickCount?: SortOrder
  }

  export type EnumSubmissionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubmissionStatus | EnumSubmissionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubmissionStatus[] | ListEnumSubmissionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubmissionStatus[] | ListEnumSubmissionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubmissionStatusFilter<$PrismaModel> | $Enums.SubmissionStatus
  }

  export type ContactSubmissionOrderByRelevanceInput = {
    fields: ContactSubmissionOrderByRelevanceFieldEnum | ContactSubmissionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ContactSubmissionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    company?: SortOrder
    phone?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    status?: SortOrder
    responded?: SortOrder
    respondedAt?: SortOrder
    notes?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    referer?: SortOrder
    emailSent?: SortOrder
    emailId?: SortOrder
    emailError?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactSubmissionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    company?: SortOrder
    phone?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    status?: SortOrder
    responded?: SortOrder
    respondedAt?: SortOrder
    notes?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    referer?: SortOrder
    emailSent?: SortOrder
    emailId?: SortOrder
    emailError?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactSubmissionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    company?: SortOrder
    phone?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    status?: SortOrder
    responded?: SortOrder
    respondedAt?: SortOrder
    notes?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    referer?: SortOrder
    emailSent?: SortOrder
    emailId?: SortOrder
    emailError?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSubmissionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubmissionStatus | EnumSubmissionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubmissionStatus[] | ListEnumSubmissionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubmissionStatus[] | ListEnumSubmissionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubmissionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubmissionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubmissionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubmissionStatusFilter<$PrismaModel>
  }

  export type EnumSecurityEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SecurityEventType | EnumSecurityEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SecurityEventType[] | ListEnumSecurityEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SecurityEventType[] | ListEnumSecurityEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSecurityEventTypeFilter<$PrismaModel> | $Enums.SecurityEventType
  }

  export type EnumSecuritySeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.SecuritySeverity | EnumSecuritySeverityFieldRefInput<$PrismaModel>
    in?: $Enums.SecuritySeverity[] | ListEnumSecuritySeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.SecuritySeverity[] | ListEnumSecuritySeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumSecuritySeverityFilter<$PrismaModel> | $Enums.SecuritySeverity
  }

  export type SecurityEventOrderByRelevanceInput = {
    fields: SecurityEventOrderByRelevanceFieldEnum | SecurityEventOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SecurityEventCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    severity?: SortOrder
    message?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    path?: SortOrder
    method?: SortOrder
    clientId?: SortOrder
    sessionId?: SortOrder
    acknowledged?: SortOrder
    acknowledgedAt?: SortOrder
    acknowledgedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type SecurityEventMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    severity?: SortOrder
    message?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    path?: SortOrder
    method?: SortOrder
    clientId?: SortOrder
    sessionId?: SortOrder
    acknowledged?: SortOrder
    acknowledgedAt?: SortOrder
    acknowledgedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type SecurityEventMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    severity?: SortOrder
    message?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    path?: SortOrder
    method?: SortOrder
    clientId?: SortOrder
    sessionId?: SortOrder
    acknowledged?: SortOrder
    acknowledgedAt?: SortOrder
    acknowledgedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumSecurityEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SecurityEventType | EnumSecurityEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SecurityEventType[] | ListEnumSecurityEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SecurityEventType[] | ListEnumSecurityEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSecurityEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.SecurityEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSecurityEventTypeFilter<$PrismaModel>
    _max?: NestedEnumSecurityEventTypeFilter<$PrismaModel>
  }

  export type EnumSecuritySeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SecuritySeverity | EnumSecuritySeverityFieldRefInput<$PrismaModel>
    in?: $Enums.SecuritySeverity[] | ListEnumSecuritySeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.SecuritySeverity[] | ListEnumSecuritySeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumSecuritySeverityWithAggregatesFilter<$PrismaModel> | $Enums.SecuritySeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSecuritySeverityFilter<$PrismaModel>
    _max?: NestedEnumSecuritySeverityFilter<$PrismaModel>
  }

  export type BlogPostCreatekeywordsInput = {
    set: string[]
  }

  export type AuthorCreateNestedOneWithoutPostsInput = {
    create?: XOR<AuthorCreateWithoutPostsInput, AuthorUncheckedCreateWithoutPostsInput>
    connectOrCreate?: AuthorCreateOrConnectWithoutPostsInput
    connect?: AuthorWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutPostsInput = {
    create?: XOR<CategoryCreateWithoutPostsInput, CategoryUncheckedCreateWithoutPostsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutPostsInput
    connect?: CategoryWhereUniqueInput
  }

  export type PostTagCreateNestedManyWithoutPostInput = {
    create?: XOR<PostTagCreateWithoutPostInput, PostTagUncheckedCreateWithoutPostInput> | PostTagCreateWithoutPostInput[] | PostTagUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostTagCreateOrConnectWithoutPostInput | PostTagCreateOrConnectWithoutPostInput[]
    createMany?: PostTagCreateManyPostInputEnvelope
    connect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
  }

  export type SeriesPostCreateNestedManyWithoutPostInput = {
    create?: XOR<SeriesPostCreateWithoutPostInput, SeriesPostUncheckedCreateWithoutPostInput> | SeriesPostCreateWithoutPostInput[] | SeriesPostUncheckedCreateWithoutPostInput[]
    connectOrCreate?: SeriesPostCreateOrConnectWithoutPostInput | SeriesPostCreateOrConnectWithoutPostInput[]
    createMany?: SeriesPostCreateManyPostInputEnvelope
    connect?: SeriesPostWhereUniqueInput | SeriesPostWhereUniqueInput[]
  }

  export type PostRelationCreateNestedManyWithoutOriginalPostInput = {
    create?: XOR<PostRelationCreateWithoutOriginalPostInput, PostRelationUncheckedCreateWithoutOriginalPostInput> | PostRelationCreateWithoutOriginalPostInput[] | PostRelationUncheckedCreateWithoutOriginalPostInput[]
    connectOrCreate?: PostRelationCreateOrConnectWithoutOriginalPostInput | PostRelationCreateOrConnectWithoutOriginalPostInput[]
    createMany?: PostRelationCreateManyOriginalPostInputEnvelope
    connect?: PostRelationWhereUniqueInput | PostRelationWhereUniqueInput[]
  }

  export type PostRelationCreateNestedManyWithoutRelatedPostInput = {
    create?: XOR<PostRelationCreateWithoutRelatedPostInput, PostRelationUncheckedCreateWithoutRelatedPostInput> | PostRelationCreateWithoutRelatedPostInput[] | PostRelationUncheckedCreateWithoutRelatedPostInput[]
    connectOrCreate?: PostRelationCreateOrConnectWithoutRelatedPostInput | PostRelationCreateOrConnectWithoutRelatedPostInput[]
    createMany?: PostRelationCreateManyRelatedPostInputEnvelope
    connect?: PostRelationWhereUniqueInput | PostRelationWhereUniqueInput[]
  }

  export type PostVersionCreateNestedManyWithoutPostInput = {
    create?: XOR<PostVersionCreateWithoutPostInput, PostVersionUncheckedCreateWithoutPostInput> | PostVersionCreateWithoutPostInput[] | PostVersionUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostVersionCreateOrConnectWithoutPostInput | PostVersionCreateOrConnectWithoutPostInput[]
    createMany?: PostVersionCreateManyPostInputEnvelope
    connect?: PostVersionWhereUniqueInput | PostVersionWhereUniqueInput[]
  }

  export type PostViewCreateNestedManyWithoutPostInput = {
    create?: XOR<PostViewCreateWithoutPostInput, PostViewUncheckedCreateWithoutPostInput> | PostViewCreateWithoutPostInput[] | PostViewUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostViewCreateOrConnectWithoutPostInput | PostViewCreateOrConnectWithoutPostInput[]
    createMany?: PostViewCreateManyPostInputEnvelope
    connect?: PostViewWhereUniqueInput | PostViewWhereUniqueInput[]
  }

  export type PostInteractionCreateNestedManyWithoutPostInput = {
    create?: XOR<PostInteractionCreateWithoutPostInput, PostInteractionUncheckedCreateWithoutPostInput> | PostInteractionCreateWithoutPostInput[] | PostInteractionUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostInteractionCreateOrConnectWithoutPostInput | PostInteractionCreateOrConnectWithoutPostInput[]
    createMany?: PostInteractionCreateManyPostInputEnvelope
    connect?: PostInteractionWhereUniqueInput | PostInteractionWhereUniqueInput[]
  }

  export type SEOEventCreateNestedManyWithoutPostInput = {
    create?: XOR<SEOEventCreateWithoutPostInput, SEOEventUncheckedCreateWithoutPostInput> | SEOEventCreateWithoutPostInput[] | SEOEventUncheckedCreateWithoutPostInput[]
    connectOrCreate?: SEOEventCreateOrConnectWithoutPostInput | SEOEventCreateOrConnectWithoutPostInput[]
    createMany?: SEOEventCreateManyPostInputEnvelope
    connect?: SEOEventWhereUniqueInput | SEOEventWhereUniqueInput[]
  }

  export type SEOKeywordCreateNestedManyWithoutPostInput = {
    create?: XOR<SEOKeywordCreateWithoutPostInput, SEOKeywordUncheckedCreateWithoutPostInput> | SEOKeywordCreateWithoutPostInput[] | SEOKeywordUncheckedCreateWithoutPostInput[]
    connectOrCreate?: SEOKeywordCreateOrConnectWithoutPostInput | SEOKeywordCreateOrConnectWithoutPostInput[]
    createMany?: SEOKeywordCreateManyPostInputEnvelope
    connect?: SEOKeywordWhereUniqueInput | SEOKeywordWhereUniqueInput[]
  }

  export type SitemapEntryCreateNestedManyWithoutPostInput = {
    create?: XOR<SitemapEntryCreateWithoutPostInput, SitemapEntryUncheckedCreateWithoutPostInput> | SitemapEntryCreateWithoutPostInput[] | SitemapEntryUncheckedCreateWithoutPostInput[]
    connectOrCreate?: SitemapEntryCreateOrConnectWithoutPostInput | SitemapEntryCreateOrConnectWithoutPostInput[]
    createMany?: SitemapEntryCreateManyPostInputEnvelope
    connect?: SitemapEntryWhereUniqueInput | SitemapEntryWhereUniqueInput[]
  }

  export type PostTagUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<PostTagCreateWithoutPostInput, PostTagUncheckedCreateWithoutPostInput> | PostTagCreateWithoutPostInput[] | PostTagUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostTagCreateOrConnectWithoutPostInput | PostTagCreateOrConnectWithoutPostInput[]
    createMany?: PostTagCreateManyPostInputEnvelope
    connect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
  }

  export type SeriesPostUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<SeriesPostCreateWithoutPostInput, SeriesPostUncheckedCreateWithoutPostInput> | SeriesPostCreateWithoutPostInput[] | SeriesPostUncheckedCreateWithoutPostInput[]
    connectOrCreate?: SeriesPostCreateOrConnectWithoutPostInput | SeriesPostCreateOrConnectWithoutPostInput[]
    createMany?: SeriesPostCreateManyPostInputEnvelope
    connect?: SeriesPostWhereUniqueInput | SeriesPostWhereUniqueInput[]
  }

  export type PostRelationUncheckedCreateNestedManyWithoutOriginalPostInput = {
    create?: XOR<PostRelationCreateWithoutOriginalPostInput, PostRelationUncheckedCreateWithoutOriginalPostInput> | PostRelationCreateWithoutOriginalPostInput[] | PostRelationUncheckedCreateWithoutOriginalPostInput[]
    connectOrCreate?: PostRelationCreateOrConnectWithoutOriginalPostInput | PostRelationCreateOrConnectWithoutOriginalPostInput[]
    createMany?: PostRelationCreateManyOriginalPostInputEnvelope
    connect?: PostRelationWhereUniqueInput | PostRelationWhereUniqueInput[]
  }

  export type PostRelationUncheckedCreateNestedManyWithoutRelatedPostInput = {
    create?: XOR<PostRelationCreateWithoutRelatedPostInput, PostRelationUncheckedCreateWithoutRelatedPostInput> | PostRelationCreateWithoutRelatedPostInput[] | PostRelationUncheckedCreateWithoutRelatedPostInput[]
    connectOrCreate?: PostRelationCreateOrConnectWithoutRelatedPostInput | PostRelationCreateOrConnectWithoutRelatedPostInput[]
    createMany?: PostRelationCreateManyRelatedPostInputEnvelope
    connect?: PostRelationWhereUniqueInput | PostRelationWhereUniqueInput[]
  }

  export type PostVersionUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<PostVersionCreateWithoutPostInput, PostVersionUncheckedCreateWithoutPostInput> | PostVersionCreateWithoutPostInput[] | PostVersionUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostVersionCreateOrConnectWithoutPostInput | PostVersionCreateOrConnectWithoutPostInput[]
    createMany?: PostVersionCreateManyPostInputEnvelope
    connect?: PostVersionWhereUniqueInput | PostVersionWhereUniqueInput[]
  }

  export type PostViewUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<PostViewCreateWithoutPostInput, PostViewUncheckedCreateWithoutPostInput> | PostViewCreateWithoutPostInput[] | PostViewUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostViewCreateOrConnectWithoutPostInput | PostViewCreateOrConnectWithoutPostInput[]
    createMany?: PostViewCreateManyPostInputEnvelope
    connect?: PostViewWhereUniqueInput | PostViewWhereUniqueInput[]
  }

  export type PostInteractionUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<PostInteractionCreateWithoutPostInput, PostInteractionUncheckedCreateWithoutPostInput> | PostInteractionCreateWithoutPostInput[] | PostInteractionUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostInteractionCreateOrConnectWithoutPostInput | PostInteractionCreateOrConnectWithoutPostInput[]
    createMany?: PostInteractionCreateManyPostInputEnvelope
    connect?: PostInteractionWhereUniqueInput | PostInteractionWhereUniqueInput[]
  }

  export type SEOEventUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<SEOEventCreateWithoutPostInput, SEOEventUncheckedCreateWithoutPostInput> | SEOEventCreateWithoutPostInput[] | SEOEventUncheckedCreateWithoutPostInput[]
    connectOrCreate?: SEOEventCreateOrConnectWithoutPostInput | SEOEventCreateOrConnectWithoutPostInput[]
    createMany?: SEOEventCreateManyPostInputEnvelope
    connect?: SEOEventWhereUniqueInput | SEOEventWhereUniqueInput[]
  }

  export type SEOKeywordUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<SEOKeywordCreateWithoutPostInput, SEOKeywordUncheckedCreateWithoutPostInput> | SEOKeywordCreateWithoutPostInput[] | SEOKeywordUncheckedCreateWithoutPostInput[]
    connectOrCreate?: SEOKeywordCreateOrConnectWithoutPostInput | SEOKeywordCreateOrConnectWithoutPostInput[]
    createMany?: SEOKeywordCreateManyPostInputEnvelope
    connect?: SEOKeywordWhereUniqueInput | SEOKeywordWhereUniqueInput[]
  }

  export type SitemapEntryUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<SitemapEntryCreateWithoutPostInput, SitemapEntryUncheckedCreateWithoutPostInput> | SitemapEntryCreateWithoutPostInput[] | SitemapEntryUncheckedCreateWithoutPostInput[]
    connectOrCreate?: SitemapEntryCreateOrConnectWithoutPostInput | SitemapEntryCreateOrConnectWithoutPostInput[]
    createMany?: SitemapEntryCreateManyPostInputEnvelope
    connect?: SitemapEntryWhereUniqueInput | SitemapEntryWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumContentTypeFieldUpdateOperationsInput = {
    set?: $Enums.ContentType
  }

  export type EnumPostStatusFieldUpdateOperationsInput = {
    set?: $Enums.PostStatus
  }

  export type BlogPostUpdatekeywordsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AuthorUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<AuthorCreateWithoutPostsInput, AuthorUncheckedCreateWithoutPostsInput>
    connectOrCreate?: AuthorCreateOrConnectWithoutPostsInput
    upsert?: AuthorUpsertWithoutPostsInput
    connect?: AuthorWhereUniqueInput
    update?: XOR<XOR<AuthorUpdateToOneWithWhereWithoutPostsInput, AuthorUpdateWithoutPostsInput>, AuthorUncheckedUpdateWithoutPostsInput>
  }

  export type CategoryUpdateOneWithoutPostsNestedInput = {
    create?: XOR<CategoryCreateWithoutPostsInput, CategoryUncheckedCreateWithoutPostsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutPostsInput
    upsert?: CategoryUpsertWithoutPostsInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutPostsInput, CategoryUpdateWithoutPostsInput>, CategoryUncheckedUpdateWithoutPostsInput>
  }

  export type PostTagUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostTagCreateWithoutPostInput, PostTagUncheckedCreateWithoutPostInput> | PostTagCreateWithoutPostInput[] | PostTagUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostTagCreateOrConnectWithoutPostInput | PostTagCreateOrConnectWithoutPostInput[]
    upsert?: PostTagUpsertWithWhereUniqueWithoutPostInput | PostTagUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostTagCreateManyPostInputEnvelope
    set?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    disconnect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    delete?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    connect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    update?: PostTagUpdateWithWhereUniqueWithoutPostInput | PostTagUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostTagUpdateManyWithWhereWithoutPostInput | PostTagUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostTagScalarWhereInput | PostTagScalarWhereInput[]
  }

  export type SeriesPostUpdateManyWithoutPostNestedInput = {
    create?: XOR<SeriesPostCreateWithoutPostInput, SeriesPostUncheckedCreateWithoutPostInput> | SeriesPostCreateWithoutPostInput[] | SeriesPostUncheckedCreateWithoutPostInput[]
    connectOrCreate?: SeriesPostCreateOrConnectWithoutPostInput | SeriesPostCreateOrConnectWithoutPostInput[]
    upsert?: SeriesPostUpsertWithWhereUniqueWithoutPostInput | SeriesPostUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: SeriesPostCreateManyPostInputEnvelope
    set?: SeriesPostWhereUniqueInput | SeriesPostWhereUniqueInput[]
    disconnect?: SeriesPostWhereUniqueInput | SeriesPostWhereUniqueInput[]
    delete?: SeriesPostWhereUniqueInput | SeriesPostWhereUniqueInput[]
    connect?: SeriesPostWhereUniqueInput | SeriesPostWhereUniqueInput[]
    update?: SeriesPostUpdateWithWhereUniqueWithoutPostInput | SeriesPostUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: SeriesPostUpdateManyWithWhereWithoutPostInput | SeriesPostUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: SeriesPostScalarWhereInput | SeriesPostScalarWhereInput[]
  }

  export type PostRelationUpdateManyWithoutOriginalPostNestedInput = {
    create?: XOR<PostRelationCreateWithoutOriginalPostInput, PostRelationUncheckedCreateWithoutOriginalPostInput> | PostRelationCreateWithoutOriginalPostInput[] | PostRelationUncheckedCreateWithoutOriginalPostInput[]
    connectOrCreate?: PostRelationCreateOrConnectWithoutOriginalPostInput | PostRelationCreateOrConnectWithoutOriginalPostInput[]
    upsert?: PostRelationUpsertWithWhereUniqueWithoutOriginalPostInput | PostRelationUpsertWithWhereUniqueWithoutOriginalPostInput[]
    createMany?: PostRelationCreateManyOriginalPostInputEnvelope
    set?: PostRelationWhereUniqueInput | PostRelationWhereUniqueInput[]
    disconnect?: PostRelationWhereUniqueInput | PostRelationWhereUniqueInput[]
    delete?: PostRelationWhereUniqueInput | PostRelationWhereUniqueInput[]
    connect?: PostRelationWhereUniqueInput | PostRelationWhereUniqueInput[]
    update?: PostRelationUpdateWithWhereUniqueWithoutOriginalPostInput | PostRelationUpdateWithWhereUniqueWithoutOriginalPostInput[]
    updateMany?: PostRelationUpdateManyWithWhereWithoutOriginalPostInput | PostRelationUpdateManyWithWhereWithoutOriginalPostInput[]
    deleteMany?: PostRelationScalarWhereInput | PostRelationScalarWhereInput[]
  }

  export type PostRelationUpdateManyWithoutRelatedPostNestedInput = {
    create?: XOR<PostRelationCreateWithoutRelatedPostInput, PostRelationUncheckedCreateWithoutRelatedPostInput> | PostRelationCreateWithoutRelatedPostInput[] | PostRelationUncheckedCreateWithoutRelatedPostInput[]
    connectOrCreate?: PostRelationCreateOrConnectWithoutRelatedPostInput | PostRelationCreateOrConnectWithoutRelatedPostInput[]
    upsert?: PostRelationUpsertWithWhereUniqueWithoutRelatedPostInput | PostRelationUpsertWithWhereUniqueWithoutRelatedPostInput[]
    createMany?: PostRelationCreateManyRelatedPostInputEnvelope
    set?: PostRelationWhereUniqueInput | PostRelationWhereUniqueInput[]
    disconnect?: PostRelationWhereUniqueInput | PostRelationWhereUniqueInput[]
    delete?: PostRelationWhereUniqueInput | PostRelationWhereUniqueInput[]
    connect?: PostRelationWhereUniqueInput | PostRelationWhereUniqueInput[]
    update?: PostRelationUpdateWithWhereUniqueWithoutRelatedPostInput | PostRelationUpdateWithWhereUniqueWithoutRelatedPostInput[]
    updateMany?: PostRelationUpdateManyWithWhereWithoutRelatedPostInput | PostRelationUpdateManyWithWhereWithoutRelatedPostInput[]
    deleteMany?: PostRelationScalarWhereInput | PostRelationScalarWhereInput[]
  }

  export type PostVersionUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostVersionCreateWithoutPostInput, PostVersionUncheckedCreateWithoutPostInput> | PostVersionCreateWithoutPostInput[] | PostVersionUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostVersionCreateOrConnectWithoutPostInput | PostVersionCreateOrConnectWithoutPostInput[]
    upsert?: PostVersionUpsertWithWhereUniqueWithoutPostInput | PostVersionUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostVersionCreateManyPostInputEnvelope
    set?: PostVersionWhereUniqueInput | PostVersionWhereUniqueInput[]
    disconnect?: PostVersionWhereUniqueInput | PostVersionWhereUniqueInput[]
    delete?: PostVersionWhereUniqueInput | PostVersionWhereUniqueInput[]
    connect?: PostVersionWhereUniqueInput | PostVersionWhereUniqueInput[]
    update?: PostVersionUpdateWithWhereUniqueWithoutPostInput | PostVersionUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostVersionUpdateManyWithWhereWithoutPostInput | PostVersionUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostVersionScalarWhereInput | PostVersionScalarWhereInput[]
  }

  export type PostViewUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostViewCreateWithoutPostInput, PostViewUncheckedCreateWithoutPostInput> | PostViewCreateWithoutPostInput[] | PostViewUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostViewCreateOrConnectWithoutPostInput | PostViewCreateOrConnectWithoutPostInput[]
    upsert?: PostViewUpsertWithWhereUniqueWithoutPostInput | PostViewUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostViewCreateManyPostInputEnvelope
    set?: PostViewWhereUniqueInput | PostViewWhereUniqueInput[]
    disconnect?: PostViewWhereUniqueInput | PostViewWhereUniqueInput[]
    delete?: PostViewWhereUniqueInput | PostViewWhereUniqueInput[]
    connect?: PostViewWhereUniqueInput | PostViewWhereUniqueInput[]
    update?: PostViewUpdateWithWhereUniqueWithoutPostInput | PostViewUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostViewUpdateManyWithWhereWithoutPostInput | PostViewUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostViewScalarWhereInput | PostViewScalarWhereInput[]
  }

  export type PostInteractionUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostInteractionCreateWithoutPostInput, PostInteractionUncheckedCreateWithoutPostInput> | PostInteractionCreateWithoutPostInput[] | PostInteractionUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostInteractionCreateOrConnectWithoutPostInput | PostInteractionCreateOrConnectWithoutPostInput[]
    upsert?: PostInteractionUpsertWithWhereUniqueWithoutPostInput | PostInteractionUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostInteractionCreateManyPostInputEnvelope
    set?: PostInteractionWhereUniqueInput | PostInteractionWhereUniqueInput[]
    disconnect?: PostInteractionWhereUniqueInput | PostInteractionWhereUniqueInput[]
    delete?: PostInteractionWhereUniqueInput | PostInteractionWhereUniqueInput[]
    connect?: PostInteractionWhereUniqueInput | PostInteractionWhereUniqueInput[]
    update?: PostInteractionUpdateWithWhereUniqueWithoutPostInput | PostInteractionUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostInteractionUpdateManyWithWhereWithoutPostInput | PostInteractionUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostInteractionScalarWhereInput | PostInteractionScalarWhereInput[]
  }

  export type SEOEventUpdateManyWithoutPostNestedInput = {
    create?: XOR<SEOEventCreateWithoutPostInput, SEOEventUncheckedCreateWithoutPostInput> | SEOEventCreateWithoutPostInput[] | SEOEventUncheckedCreateWithoutPostInput[]
    connectOrCreate?: SEOEventCreateOrConnectWithoutPostInput | SEOEventCreateOrConnectWithoutPostInput[]
    upsert?: SEOEventUpsertWithWhereUniqueWithoutPostInput | SEOEventUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: SEOEventCreateManyPostInputEnvelope
    set?: SEOEventWhereUniqueInput | SEOEventWhereUniqueInput[]
    disconnect?: SEOEventWhereUniqueInput | SEOEventWhereUniqueInput[]
    delete?: SEOEventWhereUniqueInput | SEOEventWhereUniqueInput[]
    connect?: SEOEventWhereUniqueInput | SEOEventWhereUniqueInput[]
    update?: SEOEventUpdateWithWhereUniqueWithoutPostInput | SEOEventUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: SEOEventUpdateManyWithWhereWithoutPostInput | SEOEventUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: SEOEventScalarWhereInput | SEOEventScalarWhereInput[]
  }

  export type SEOKeywordUpdateManyWithoutPostNestedInput = {
    create?: XOR<SEOKeywordCreateWithoutPostInput, SEOKeywordUncheckedCreateWithoutPostInput> | SEOKeywordCreateWithoutPostInput[] | SEOKeywordUncheckedCreateWithoutPostInput[]
    connectOrCreate?: SEOKeywordCreateOrConnectWithoutPostInput | SEOKeywordCreateOrConnectWithoutPostInput[]
    upsert?: SEOKeywordUpsertWithWhereUniqueWithoutPostInput | SEOKeywordUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: SEOKeywordCreateManyPostInputEnvelope
    set?: SEOKeywordWhereUniqueInput | SEOKeywordWhereUniqueInput[]
    disconnect?: SEOKeywordWhereUniqueInput | SEOKeywordWhereUniqueInput[]
    delete?: SEOKeywordWhereUniqueInput | SEOKeywordWhereUniqueInput[]
    connect?: SEOKeywordWhereUniqueInput | SEOKeywordWhereUniqueInput[]
    update?: SEOKeywordUpdateWithWhereUniqueWithoutPostInput | SEOKeywordUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: SEOKeywordUpdateManyWithWhereWithoutPostInput | SEOKeywordUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: SEOKeywordScalarWhereInput | SEOKeywordScalarWhereInput[]
  }

  export type SitemapEntryUpdateManyWithoutPostNestedInput = {
    create?: XOR<SitemapEntryCreateWithoutPostInput, SitemapEntryUncheckedCreateWithoutPostInput> | SitemapEntryCreateWithoutPostInput[] | SitemapEntryUncheckedCreateWithoutPostInput[]
    connectOrCreate?: SitemapEntryCreateOrConnectWithoutPostInput | SitemapEntryCreateOrConnectWithoutPostInput[]
    upsert?: SitemapEntryUpsertWithWhereUniqueWithoutPostInput | SitemapEntryUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: SitemapEntryCreateManyPostInputEnvelope
    set?: SitemapEntryWhereUniqueInput | SitemapEntryWhereUniqueInput[]
    disconnect?: SitemapEntryWhereUniqueInput | SitemapEntryWhereUniqueInput[]
    delete?: SitemapEntryWhereUniqueInput | SitemapEntryWhereUniqueInput[]
    connect?: SitemapEntryWhereUniqueInput | SitemapEntryWhereUniqueInput[]
    update?: SitemapEntryUpdateWithWhereUniqueWithoutPostInput | SitemapEntryUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: SitemapEntryUpdateManyWithWhereWithoutPostInput | SitemapEntryUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: SitemapEntryScalarWhereInput | SitemapEntryScalarWhereInput[]
  }

  export type PostTagUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostTagCreateWithoutPostInput, PostTagUncheckedCreateWithoutPostInput> | PostTagCreateWithoutPostInput[] | PostTagUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostTagCreateOrConnectWithoutPostInput | PostTagCreateOrConnectWithoutPostInput[]
    upsert?: PostTagUpsertWithWhereUniqueWithoutPostInput | PostTagUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostTagCreateManyPostInputEnvelope
    set?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    disconnect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    delete?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    connect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    update?: PostTagUpdateWithWhereUniqueWithoutPostInput | PostTagUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostTagUpdateManyWithWhereWithoutPostInput | PostTagUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostTagScalarWhereInput | PostTagScalarWhereInput[]
  }

  export type SeriesPostUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<SeriesPostCreateWithoutPostInput, SeriesPostUncheckedCreateWithoutPostInput> | SeriesPostCreateWithoutPostInput[] | SeriesPostUncheckedCreateWithoutPostInput[]
    connectOrCreate?: SeriesPostCreateOrConnectWithoutPostInput | SeriesPostCreateOrConnectWithoutPostInput[]
    upsert?: SeriesPostUpsertWithWhereUniqueWithoutPostInput | SeriesPostUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: SeriesPostCreateManyPostInputEnvelope
    set?: SeriesPostWhereUniqueInput | SeriesPostWhereUniqueInput[]
    disconnect?: SeriesPostWhereUniqueInput | SeriesPostWhereUniqueInput[]
    delete?: SeriesPostWhereUniqueInput | SeriesPostWhereUniqueInput[]
    connect?: SeriesPostWhereUniqueInput | SeriesPostWhereUniqueInput[]
    update?: SeriesPostUpdateWithWhereUniqueWithoutPostInput | SeriesPostUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: SeriesPostUpdateManyWithWhereWithoutPostInput | SeriesPostUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: SeriesPostScalarWhereInput | SeriesPostScalarWhereInput[]
  }

  export type PostRelationUncheckedUpdateManyWithoutOriginalPostNestedInput = {
    create?: XOR<PostRelationCreateWithoutOriginalPostInput, PostRelationUncheckedCreateWithoutOriginalPostInput> | PostRelationCreateWithoutOriginalPostInput[] | PostRelationUncheckedCreateWithoutOriginalPostInput[]
    connectOrCreate?: PostRelationCreateOrConnectWithoutOriginalPostInput | PostRelationCreateOrConnectWithoutOriginalPostInput[]
    upsert?: PostRelationUpsertWithWhereUniqueWithoutOriginalPostInput | PostRelationUpsertWithWhereUniqueWithoutOriginalPostInput[]
    createMany?: PostRelationCreateManyOriginalPostInputEnvelope
    set?: PostRelationWhereUniqueInput | PostRelationWhereUniqueInput[]
    disconnect?: PostRelationWhereUniqueInput | PostRelationWhereUniqueInput[]
    delete?: PostRelationWhereUniqueInput | PostRelationWhereUniqueInput[]
    connect?: PostRelationWhereUniqueInput | PostRelationWhereUniqueInput[]
    update?: PostRelationUpdateWithWhereUniqueWithoutOriginalPostInput | PostRelationUpdateWithWhereUniqueWithoutOriginalPostInput[]
    updateMany?: PostRelationUpdateManyWithWhereWithoutOriginalPostInput | PostRelationUpdateManyWithWhereWithoutOriginalPostInput[]
    deleteMany?: PostRelationScalarWhereInput | PostRelationScalarWhereInput[]
  }

  export type PostRelationUncheckedUpdateManyWithoutRelatedPostNestedInput = {
    create?: XOR<PostRelationCreateWithoutRelatedPostInput, PostRelationUncheckedCreateWithoutRelatedPostInput> | PostRelationCreateWithoutRelatedPostInput[] | PostRelationUncheckedCreateWithoutRelatedPostInput[]
    connectOrCreate?: PostRelationCreateOrConnectWithoutRelatedPostInput | PostRelationCreateOrConnectWithoutRelatedPostInput[]
    upsert?: PostRelationUpsertWithWhereUniqueWithoutRelatedPostInput | PostRelationUpsertWithWhereUniqueWithoutRelatedPostInput[]
    createMany?: PostRelationCreateManyRelatedPostInputEnvelope
    set?: PostRelationWhereUniqueInput | PostRelationWhereUniqueInput[]
    disconnect?: PostRelationWhereUniqueInput | PostRelationWhereUniqueInput[]
    delete?: PostRelationWhereUniqueInput | PostRelationWhereUniqueInput[]
    connect?: PostRelationWhereUniqueInput | PostRelationWhereUniqueInput[]
    update?: PostRelationUpdateWithWhereUniqueWithoutRelatedPostInput | PostRelationUpdateWithWhereUniqueWithoutRelatedPostInput[]
    updateMany?: PostRelationUpdateManyWithWhereWithoutRelatedPostInput | PostRelationUpdateManyWithWhereWithoutRelatedPostInput[]
    deleteMany?: PostRelationScalarWhereInput | PostRelationScalarWhereInput[]
  }

  export type PostVersionUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostVersionCreateWithoutPostInput, PostVersionUncheckedCreateWithoutPostInput> | PostVersionCreateWithoutPostInput[] | PostVersionUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostVersionCreateOrConnectWithoutPostInput | PostVersionCreateOrConnectWithoutPostInput[]
    upsert?: PostVersionUpsertWithWhereUniqueWithoutPostInput | PostVersionUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostVersionCreateManyPostInputEnvelope
    set?: PostVersionWhereUniqueInput | PostVersionWhereUniqueInput[]
    disconnect?: PostVersionWhereUniqueInput | PostVersionWhereUniqueInput[]
    delete?: PostVersionWhereUniqueInput | PostVersionWhereUniqueInput[]
    connect?: PostVersionWhereUniqueInput | PostVersionWhereUniqueInput[]
    update?: PostVersionUpdateWithWhereUniqueWithoutPostInput | PostVersionUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostVersionUpdateManyWithWhereWithoutPostInput | PostVersionUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostVersionScalarWhereInput | PostVersionScalarWhereInput[]
  }

  export type PostViewUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostViewCreateWithoutPostInput, PostViewUncheckedCreateWithoutPostInput> | PostViewCreateWithoutPostInput[] | PostViewUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostViewCreateOrConnectWithoutPostInput | PostViewCreateOrConnectWithoutPostInput[]
    upsert?: PostViewUpsertWithWhereUniqueWithoutPostInput | PostViewUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostViewCreateManyPostInputEnvelope
    set?: PostViewWhereUniqueInput | PostViewWhereUniqueInput[]
    disconnect?: PostViewWhereUniqueInput | PostViewWhereUniqueInput[]
    delete?: PostViewWhereUniqueInput | PostViewWhereUniqueInput[]
    connect?: PostViewWhereUniqueInput | PostViewWhereUniqueInput[]
    update?: PostViewUpdateWithWhereUniqueWithoutPostInput | PostViewUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostViewUpdateManyWithWhereWithoutPostInput | PostViewUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostViewScalarWhereInput | PostViewScalarWhereInput[]
  }

  export type PostInteractionUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostInteractionCreateWithoutPostInput, PostInteractionUncheckedCreateWithoutPostInput> | PostInteractionCreateWithoutPostInput[] | PostInteractionUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostInteractionCreateOrConnectWithoutPostInput | PostInteractionCreateOrConnectWithoutPostInput[]
    upsert?: PostInteractionUpsertWithWhereUniqueWithoutPostInput | PostInteractionUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostInteractionCreateManyPostInputEnvelope
    set?: PostInteractionWhereUniqueInput | PostInteractionWhereUniqueInput[]
    disconnect?: PostInteractionWhereUniqueInput | PostInteractionWhereUniqueInput[]
    delete?: PostInteractionWhereUniqueInput | PostInteractionWhereUniqueInput[]
    connect?: PostInteractionWhereUniqueInput | PostInteractionWhereUniqueInput[]
    update?: PostInteractionUpdateWithWhereUniqueWithoutPostInput | PostInteractionUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostInteractionUpdateManyWithWhereWithoutPostInput | PostInteractionUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostInteractionScalarWhereInput | PostInteractionScalarWhereInput[]
  }

  export type SEOEventUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<SEOEventCreateWithoutPostInput, SEOEventUncheckedCreateWithoutPostInput> | SEOEventCreateWithoutPostInput[] | SEOEventUncheckedCreateWithoutPostInput[]
    connectOrCreate?: SEOEventCreateOrConnectWithoutPostInput | SEOEventCreateOrConnectWithoutPostInput[]
    upsert?: SEOEventUpsertWithWhereUniqueWithoutPostInput | SEOEventUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: SEOEventCreateManyPostInputEnvelope
    set?: SEOEventWhereUniqueInput | SEOEventWhereUniqueInput[]
    disconnect?: SEOEventWhereUniqueInput | SEOEventWhereUniqueInput[]
    delete?: SEOEventWhereUniqueInput | SEOEventWhereUniqueInput[]
    connect?: SEOEventWhereUniqueInput | SEOEventWhereUniqueInput[]
    update?: SEOEventUpdateWithWhereUniqueWithoutPostInput | SEOEventUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: SEOEventUpdateManyWithWhereWithoutPostInput | SEOEventUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: SEOEventScalarWhereInput | SEOEventScalarWhereInput[]
  }

  export type SEOKeywordUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<SEOKeywordCreateWithoutPostInput, SEOKeywordUncheckedCreateWithoutPostInput> | SEOKeywordCreateWithoutPostInput[] | SEOKeywordUncheckedCreateWithoutPostInput[]
    connectOrCreate?: SEOKeywordCreateOrConnectWithoutPostInput | SEOKeywordCreateOrConnectWithoutPostInput[]
    upsert?: SEOKeywordUpsertWithWhereUniqueWithoutPostInput | SEOKeywordUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: SEOKeywordCreateManyPostInputEnvelope
    set?: SEOKeywordWhereUniqueInput | SEOKeywordWhereUniqueInput[]
    disconnect?: SEOKeywordWhereUniqueInput | SEOKeywordWhereUniqueInput[]
    delete?: SEOKeywordWhereUniqueInput | SEOKeywordWhereUniqueInput[]
    connect?: SEOKeywordWhereUniqueInput | SEOKeywordWhereUniqueInput[]
    update?: SEOKeywordUpdateWithWhereUniqueWithoutPostInput | SEOKeywordUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: SEOKeywordUpdateManyWithWhereWithoutPostInput | SEOKeywordUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: SEOKeywordScalarWhereInput | SEOKeywordScalarWhereInput[]
  }

  export type SitemapEntryUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<SitemapEntryCreateWithoutPostInput, SitemapEntryUncheckedCreateWithoutPostInput> | SitemapEntryCreateWithoutPostInput[] | SitemapEntryUncheckedCreateWithoutPostInput[]
    connectOrCreate?: SitemapEntryCreateOrConnectWithoutPostInput | SitemapEntryCreateOrConnectWithoutPostInput[]
    upsert?: SitemapEntryUpsertWithWhereUniqueWithoutPostInput | SitemapEntryUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: SitemapEntryCreateManyPostInputEnvelope
    set?: SitemapEntryWhereUniqueInput | SitemapEntryWhereUniqueInput[]
    disconnect?: SitemapEntryWhereUniqueInput | SitemapEntryWhereUniqueInput[]
    delete?: SitemapEntryWhereUniqueInput | SitemapEntryWhereUniqueInput[]
    connect?: SitemapEntryWhereUniqueInput | SitemapEntryWhereUniqueInput[]
    update?: SitemapEntryUpdateWithWhereUniqueWithoutPostInput | SitemapEntryUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: SitemapEntryUpdateManyWithWhereWithoutPostInput | SitemapEntryUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: SitemapEntryScalarWhereInput | SitemapEntryScalarWhereInput[]
  }

  export type BlogPostCreateNestedManyWithoutAuthorInput = {
    create?: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput> | BlogPostCreateWithoutAuthorInput[] | BlogPostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutAuthorInput | BlogPostCreateOrConnectWithoutAuthorInput[]
    createMany?: BlogPostCreateManyAuthorInputEnvelope
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
  }

  export type PostVersionCreateNestedManyWithoutAuthorInput = {
    create?: XOR<PostVersionCreateWithoutAuthorInput, PostVersionUncheckedCreateWithoutAuthorInput> | PostVersionCreateWithoutAuthorInput[] | PostVersionUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostVersionCreateOrConnectWithoutAuthorInput | PostVersionCreateOrConnectWithoutAuthorInput[]
    createMany?: PostVersionCreateManyAuthorInputEnvelope
    connect?: PostVersionWhereUniqueInput | PostVersionWhereUniqueInput[]
  }

  export type BlogPostUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput> | BlogPostCreateWithoutAuthorInput[] | BlogPostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutAuthorInput | BlogPostCreateOrConnectWithoutAuthorInput[]
    createMany?: BlogPostCreateManyAuthorInputEnvelope
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
  }

  export type PostVersionUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<PostVersionCreateWithoutAuthorInput, PostVersionUncheckedCreateWithoutAuthorInput> | PostVersionCreateWithoutAuthorInput[] | PostVersionUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostVersionCreateOrConnectWithoutAuthorInput | PostVersionCreateOrConnectWithoutAuthorInput[]
    createMany?: PostVersionCreateManyAuthorInputEnvelope
    connect?: PostVersionWhereUniqueInput | PostVersionWhereUniqueInput[]
  }

  export type BlogPostUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput> | BlogPostCreateWithoutAuthorInput[] | BlogPostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutAuthorInput | BlogPostCreateOrConnectWithoutAuthorInput[]
    upsert?: BlogPostUpsertWithWhereUniqueWithoutAuthorInput | BlogPostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: BlogPostCreateManyAuthorInputEnvelope
    set?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    disconnect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    delete?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    update?: BlogPostUpdateWithWhereUniqueWithoutAuthorInput | BlogPostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: BlogPostUpdateManyWithWhereWithoutAuthorInput | BlogPostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
  }

  export type PostVersionUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<PostVersionCreateWithoutAuthorInput, PostVersionUncheckedCreateWithoutAuthorInput> | PostVersionCreateWithoutAuthorInput[] | PostVersionUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostVersionCreateOrConnectWithoutAuthorInput | PostVersionCreateOrConnectWithoutAuthorInput[]
    upsert?: PostVersionUpsertWithWhereUniqueWithoutAuthorInput | PostVersionUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: PostVersionCreateManyAuthorInputEnvelope
    set?: PostVersionWhereUniqueInput | PostVersionWhereUniqueInput[]
    disconnect?: PostVersionWhereUniqueInput | PostVersionWhereUniqueInput[]
    delete?: PostVersionWhereUniqueInput | PostVersionWhereUniqueInput[]
    connect?: PostVersionWhereUniqueInput | PostVersionWhereUniqueInput[]
    update?: PostVersionUpdateWithWhereUniqueWithoutAuthorInput | PostVersionUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: PostVersionUpdateManyWithWhereWithoutAuthorInput | PostVersionUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: PostVersionScalarWhereInput | PostVersionScalarWhereInput[]
  }

  export type BlogPostUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput> | BlogPostCreateWithoutAuthorInput[] | BlogPostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutAuthorInput | BlogPostCreateOrConnectWithoutAuthorInput[]
    upsert?: BlogPostUpsertWithWhereUniqueWithoutAuthorInput | BlogPostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: BlogPostCreateManyAuthorInputEnvelope
    set?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    disconnect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    delete?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    update?: BlogPostUpdateWithWhereUniqueWithoutAuthorInput | BlogPostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: BlogPostUpdateManyWithWhereWithoutAuthorInput | BlogPostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
  }

  export type PostVersionUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<PostVersionCreateWithoutAuthorInput, PostVersionUncheckedCreateWithoutAuthorInput> | PostVersionCreateWithoutAuthorInput[] | PostVersionUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostVersionCreateOrConnectWithoutAuthorInput | PostVersionCreateOrConnectWithoutAuthorInput[]
    upsert?: PostVersionUpsertWithWhereUniqueWithoutAuthorInput | PostVersionUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: PostVersionCreateManyAuthorInputEnvelope
    set?: PostVersionWhereUniqueInput | PostVersionWhereUniqueInput[]
    disconnect?: PostVersionWhereUniqueInput | PostVersionWhereUniqueInput[]
    delete?: PostVersionWhereUniqueInput | PostVersionWhereUniqueInput[]
    connect?: PostVersionWhereUniqueInput | PostVersionWhereUniqueInput[]
    update?: PostVersionUpdateWithWhereUniqueWithoutAuthorInput | PostVersionUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: PostVersionUpdateManyWithWhereWithoutAuthorInput | PostVersionUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: PostVersionScalarWhereInput | PostVersionScalarWhereInput[]
  }

  export type CategoryCreatekeywordsInput = {
    set: string[]
  }

  export type CategoryCreateNestedOneWithoutChildrenInput = {
    create?: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutChildrenInput
    connect?: CategoryWhereUniqueInput
  }

  export type CategoryCreateNestedManyWithoutParentInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type BlogPostCreateNestedManyWithoutCategoryInput = {
    create?: XOR<BlogPostCreateWithoutCategoryInput, BlogPostUncheckedCreateWithoutCategoryInput> | BlogPostCreateWithoutCategoryInput[] | BlogPostUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutCategoryInput | BlogPostCreateOrConnectWithoutCategoryInput[]
    createMany?: BlogPostCreateManyCategoryInputEnvelope
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
  }

  export type CategoryUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type BlogPostUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<BlogPostCreateWithoutCategoryInput, BlogPostUncheckedCreateWithoutCategoryInput> | BlogPostCreateWithoutCategoryInput[] | BlogPostUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutCategoryInput | BlogPostCreateOrConnectWithoutCategoryInput[]
    createMany?: BlogPostCreateManyCategoryInputEnvelope
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
  }

  export type CategoryUpdatekeywordsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CategoryUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutChildrenInput
    upsert?: CategoryUpsertWithoutChildrenInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutChildrenInput, CategoryUpdateWithoutChildrenInput>, CategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type CategoryUpdateManyWithoutParentNestedInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutParentInput | CategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutParentInput | CategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutParentInput | CategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type BlogPostUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<BlogPostCreateWithoutCategoryInput, BlogPostUncheckedCreateWithoutCategoryInput> | BlogPostCreateWithoutCategoryInput[] | BlogPostUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutCategoryInput | BlogPostCreateOrConnectWithoutCategoryInput[]
    upsert?: BlogPostUpsertWithWhereUniqueWithoutCategoryInput | BlogPostUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: BlogPostCreateManyCategoryInputEnvelope
    set?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    disconnect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    delete?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    update?: BlogPostUpdateWithWhereUniqueWithoutCategoryInput | BlogPostUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: BlogPostUpdateManyWithWhereWithoutCategoryInput | BlogPostUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
  }

  export type CategoryUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutParentInput | CategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutParentInput | CategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutParentInput | CategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type BlogPostUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<BlogPostCreateWithoutCategoryInput, BlogPostUncheckedCreateWithoutCategoryInput> | BlogPostCreateWithoutCategoryInput[] | BlogPostUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutCategoryInput | BlogPostCreateOrConnectWithoutCategoryInput[]
    upsert?: BlogPostUpsertWithWhereUniqueWithoutCategoryInput | BlogPostUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: BlogPostCreateManyCategoryInputEnvelope
    set?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    disconnect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    delete?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    update?: BlogPostUpdateWithWhereUniqueWithoutCategoryInput | BlogPostUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: BlogPostUpdateManyWithWhereWithoutCategoryInput | BlogPostUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
  }

  export type PostTagCreateNestedManyWithoutTagInput = {
    create?: XOR<PostTagCreateWithoutTagInput, PostTagUncheckedCreateWithoutTagInput> | PostTagCreateWithoutTagInput[] | PostTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: PostTagCreateOrConnectWithoutTagInput | PostTagCreateOrConnectWithoutTagInput[]
    createMany?: PostTagCreateManyTagInputEnvelope
    connect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
  }

  export type PostTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<PostTagCreateWithoutTagInput, PostTagUncheckedCreateWithoutTagInput> | PostTagCreateWithoutTagInput[] | PostTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: PostTagCreateOrConnectWithoutTagInput | PostTagCreateOrConnectWithoutTagInput[]
    createMany?: PostTagCreateManyTagInputEnvelope
    connect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
  }

  export type PostTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<PostTagCreateWithoutTagInput, PostTagUncheckedCreateWithoutTagInput> | PostTagCreateWithoutTagInput[] | PostTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: PostTagCreateOrConnectWithoutTagInput | PostTagCreateOrConnectWithoutTagInput[]
    upsert?: PostTagUpsertWithWhereUniqueWithoutTagInput | PostTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: PostTagCreateManyTagInputEnvelope
    set?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    disconnect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    delete?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    connect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    update?: PostTagUpdateWithWhereUniqueWithoutTagInput | PostTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: PostTagUpdateManyWithWhereWithoutTagInput | PostTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: PostTagScalarWhereInput | PostTagScalarWhereInput[]
  }

  export type PostTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<PostTagCreateWithoutTagInput, PostTagUncheckedCreateWithoutTagInput> | PostTagCreateWithoutTagInput[] | PostTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: PostTagCreateOrConnectWithoutTagInput | PostTagCreateOrConnectWithoutTagInput[]
    upsert?: PostTagUpsertWithWhereUniqueWithoutTagInput | PostTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: PostTagCreateManyTagInputEnvelope
    set?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    disconnect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    delete?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    connect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    update?: PostTagUpdateWithWhereUniqueWithoutTagInput | PostTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: PostTagUpdateManyWithWhereWithoutTagInput | PostTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: PostTagScalarWhereInput | PostTagScalarWhereInput[]
  }

  export type BlogPostCreateNestedOneWithoutTagsInput = {
    create?: XOR<BlogPostCreateWithoutTagsInput, BlogPostUncheckedCreateWithoutTagsInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutTagsInput
    connect?: BlogPostWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutPostsInput = {
    create?: XOR<TagCreateWithoutPostsInput, TagUncheckedCreateWithoutPostsInput>
    connectOrCreate?: TagCreateOrConnectWithoutPostsInput
    connect?: TagWhereUniqueInput
  }

  export type BlogPostUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<BlogPostCreateWithoutTagsInput, BlogPostUncheckedCreateWithoutTagsInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutTagsInput
    upsert?: BlogPostUpsertWithoutTagsInput
    connect?: BlogPostWhereUniqueInput
    update?: XOR<XOR<BlogPostUpdateToOneWithWhereWithoutTagsInput, BlogPostUpdateWithoutTagsInput>, BlogPostUncheckedUpdateWithoutTagsInput>
  }

  export type TagUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<TagCreateWithoutPostsInput, TagUncheckedCreateWithoutPostsInput>
    connectOrCreate?: TagCreateOrConnectWithoutPostsInput
    upsert?: TagUpsertWithoutPostsInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutPostsInput, TagUpdateWithoutPostsInput>, TagUncheckedUpdateWithoutPostsInput>
  }

  export type BlogPostCreateNestedOneWithoutRelatedPostsInput = {
    create?: XOR<BlogPostCreateWithoutRelatedPostsInput, BlogPostUncheckedCreateWithoutRelatedPostsInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutRelatedPostsInput
    connect?: BlogPostWhereUniqueInput
  }

  export type BlogPostCreateNestedOneWithoutRelatedToPostsInput = {
    create?: XOR<BlogPostCreateWithoutRelatedToPostsInput, BlogPostUncheckedCreateWithoutRelatedToPostsInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutRelatedToPostsInput
    connect?: BlogPostWhereUniqueInput
  }

  export type EnumRelationTypeFieldUpdateOperationsInput = {
    set?: $Enums.RelationType
  }

  export type BlogPostUpdateOneRequiredWithoutRelatedPostsNestedInput = {
    create?: XOR<BlogPostCreateWithoutRelatedPostsInput, BlogPostUncheckedCreateWithoutRelatedPostsInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutRelatedPostsInput
    upsert?: BlogPostUpsertWithoutRelatedPostsInput
    connect?: BlogPostWhereUniqueInput
    update?: XOR<XOR<BlogPostUpdateToOneWithWhereWithoutRelatedPostsInput, BlogPostUpdateWithoutRelatedPostsInput>, BlogPostUncheckedUpdateWithoutRelatedPostsInput>
  }

  export type BlogPostUpdateOneRequiredWithoutRelatedToPostsNestedInput = {
    create?: XOR<BlogPostCreateWithoutRelatedToPostsInput, BlogPostUncheckedCreateWithoutRelatedToPostsInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutRelatedToPostsInput
    upsert?: BlogPostUpsertWithoutRelatedToPostsInput
    connect?: BlogPostWhereUniqueInput
    update?: XOR<XOR<BlogPostUpdateToOneWithWhereWithoutRelatedToPostsInput, BlogPostUpdateWithoutRelatedToPostsInput>, BlogPostUncheckedUpdateWithoutRelatedToPostsInput>
  }

  export type AuthorCreateNestedOneWithoutPostVersionsInput = {
    create?: XOR<AuthorCreateWithoutPostVersionsInput, AuthorUncheckedCreateWithoutPostVersionsInput>
    connectOrCreate?: AuthorCreateOrConnectWithoutPostVersionsInput
    connect?: AuthorWhereUniqueInput
  }

  export type BlogPostCreateNestedOneWithoutVersionsInput = {
    create?: XOR<BlogPostCreateWithoutVersionsInput, BlogPostUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutVersionsInput
    connect?: BlogPostWhereUniqueInput
  }

  export type EnumChangeTypeFieldUpdateOperationsInput = {
    set?: $Enums.ChangeType
  }

  export type AuthorUpdateOneRequiredWithoutPostVersionsNestedInput = {
    create?: XOR<AuthorCreateWithoutPostVersionsInput, AuthorUncheckedCreateWithoutPostVersionsInput>
    connectOrCreate?: AuthorCreateOrConnectWithoutPostVersionsInput
    upsert?: AuthorUpsertWithoutPostVersionsInput
    connect?: AuthorWhereUniqueInput
    update?: XOR<XOR<AuthorUpdateToOneWithWhereWithoutPostVersionsInput, AuthorUpdateWithoutPostVersionsInput>, AuthorUncheckedUpdateWithoutPostVersionsInput>
  }

  export type BlogPostUpdateOneRequiredWithoutVersionsNestedInput = {
    create?: XOR<BlogPostCreateWithoutVersionsInput, BlogPostUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutVersionsInput
    upsert?: BlogPostUpsertWithoutVersionsInput
    connect?: BlogPostWhereUniqueInput
    update?: XOR<XOR<BlogPostUpdateToOneWithWhereWithoutVersionsInput, BlogPostUpdateWithoutVersionsInput>, BlogPostUncheckedUpdateWithoutVersionsInput>
  }

  export type SeriesPostCreateNestedManyWithoutSeriesInput = {
    create?: XOR<SeriesPostCreateWithoutSeriesInput, SeriesPostUncheckedCreateWithoutSeriesInput> | SeriesPostCreateWithoutSeriesInput[] | SeriesPostUncheckedCreateWithoutSeriesInput[]
    connectOrCreate?: SeriesPostCreateOrConnectWithoutSeriesInput | SeriesPostCreateOrConnectWithoutSeriesInput[]
    createMany?: SeriesPostCreateManySeriesInputEnvelope
    connect?: SeriesPostWhereUniqueInput | SeriesPostWhereUniqueInput[]
  }

  export type SeriesPostUncheckedCreateNestedManyWithoutSeriesInput = {
    create?: XOR<SeriesPostCreateWithoutSeriesInput, SeriesPostUncheckedCreateWithoutSeriesInput> | SeriesPostCreateWithoutSeriesInput[] | SeriesPostUncheckedCreateWithoutSeriesInput[]
    connectOrCreate?: SeriesPostCreateOrConnectWithoutSeriesInput | SeriesPostCreateOrConnectWithoutSeriesInput[]
    createMany?: SeriesPostCreateManySeriesInputEnvelope
    connect?: SeriesPostWhereUniqueInput | SeriesPostWhereUniqueInput[]
  }

  export type SeriesPostUpdateManyWithoutSeriesNestedInput = {
    create?: XOR<SeriesPostCreateWithoutSeriesInput, SeriesPostUncheckedCreateWithoutSeriesInput> | SeriesPostCreateWithoutSeriesInput[] | SeriesPostUncheckedCreateWithoutSeriesInput[]
    connectOrCreate?: SeriesPostCreateOrConnectWithoutSeriesInput | SeriesPostCreateOrConnectWithoutSeriesInput[]
    upsert?: SeriesPostUpsertWithWhereUniqueWithoutSeriesInput | SeriesPostUpsertWithWhereUniqueWithoutSeriesInput[]
    createMany?: SeriesPostCreateManySeriesInputEnvelope
    set?: SeriesPostWhereUniqueInput | SeriesPostWhereUniqueInput[]
    disconnect?: SeriesPostWhereUniqueInput | SeriesPostWhereUniqueInput[]
    delete?: SeriesPostWhereUniqueInput | SeriesPostWhereUniqueInput[]
    connect?: SeriesPostWhereUniqueInput | SeriesPostWhereUniqueInput[]
    update?: SeriesPostUpdateWithWhereUniqueWithoutSeriesInput | SeriesPostUpdateWithWhereUniqueWithoutSeriesInput[]
    updateMany?: SeriesPostUpdateManyWithWhereWithoutSeriesInput | SeriesPostUpdateManyWithWhereWithoutSeriesInput[]
    deleteMany?: SeriesPostScalarWhereInput | SeriesPostScalarWhereInput[]
  }

  export type SeriesPostUncheckedUpdateManyWithoutSeriesNestedInput = {
    create?: XOR<SeriesPostCreateWithoutSeriesInput, SeriesPostUncheckedCreateWithoutSeriesInput> | SeriesPostCreateWithoutSeriesInput[] | SeriesPostUncheckedCreateWithoutSeriesInput[]
    connectOrCreate?: SeriesPostCreateOrConnectWithoutSeriesInput | SeriesPostCreateOrConnectWithoutSeriesInput[]
    upsert?: SeriesPostUpsertWithWhereUniqueWithoutSeriesInput | SeriesPostUpsertWithWhereUniqueWithoutSeriesInput[]
    createMany?: SeriesPostCreateManySeriesInputEnvelope
    set?: SeriesPostWhereUniqueInput | SeriesPostWhereUniqueInput[]
    disconnect?: SeriesPostWhereUniqueInput | SeriesPostWhereUniqueInput[]
    delete?: SeriesPostWhereUniqueInput | SeriesPostWhereUniqueInput[]
    connect?: SeriesPostWhereUniqueInput | SeriesPostWhereUniqueInput[]
    update?: SeriesPostUpdateWithWhereUniqueWithoutSeriesInput | SeriesPostUpdateWithWhereUniqueWithoutSeriesInput[]
    updateMany?: SeriesPostUpdateManyWithWhereWithoutSeriesInput | SeriesPostUpdateManyWithWhereWithoutSeriesInput[]
    deleteMany?: SeriesPostScalarWhereInput | SeriesPostScalarWhereInput[]
  }

  export type PostSeriesCreateNestedOneWithoutPostsInput = {
    create?: XOR<PostSeriesCreateWithoutPostsInput, PostSeriesUncheckedCreateWithoutPostsInput>
    connectOrCreate?: PostSeriesCreateOrConnectWithoutPostsInput
    connect?: PostSeriesWhereUniqueInput
  }

  export type BlogPostCreateNestedOneWithoutSeriesPostsInput = {
    create?: XOR<BlogPostCreateWithoutSeriesPostsInput, BlogPostUncheckedCreateWithoutSeriesPostsInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutSeriesPostsInput
    connect?: BlogPostWhereUniqueInput
  }

  export type PostSeriesUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<PostSeriesCreateWithoutPostsInput, PostSeriesUncheckedCreateWithoutPostsInput>
    connectOrCreate?: PostSeriesCreateOrConnectWithoutPostsInput
    upsert?: PostSeriesUpsertWithoutPostsInput
    connect?: PostSeriesWhereUniqueInput
    update?: XOR<XOR<PostSeriesUpdateToOneWithWhereWithoutPostsInput, PostSeriesUpdateWithoutPostsInput>, PostSeriesUncheckedUpdateWithoutPostsInput>
  }

  export type BlogPostUpdateOneRequiredWithoutSeriesPostsNestedInput = {
    create?: XOR<BlogPostCreateWithoutSeriesPostsInput, BlogPostUncheckedCreateWithoutSeriesPostsInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutSeriesPostsInput
    upsert?: BlogPostUpsertWithoutSeriesPostsInput
    connect?: BlogPostWhereUniqueInput
    update?: XOR<XOR<BlogPostUpdateToOneWithWhereWithoutSeriesPostsInput, BlogPostUpdateWithoutSeriesPostsInput>, BlogPostUncheckedUpdateWithoutSeriesPostsInput>
  }

  export type BlogPostCreateNestedOneWithoutViewsInput = {
    create?: XOR<BlogPostCreateWithoutViewsInput, BlogPostUncheckedCreateWithoutViewsInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutViewsInput
    connect?: BlogPostWhereUniqueInput
  }

  export type BlogPostUpdateOneRequiredWithoutViewsNestedInput = {
    create?: XOR<BlogPostCreateWithoutViewsInput, BlogPostUncheckedCreateWithoutViewsInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutViewsInput
    upsert?: BlogPostUpsertWithoutViewsInput
    connect?: BlogPostWhereUniqueInput
    update?: XOR<XOR<BlogPostUpdateToOneWithWhereWithoutViewsInput, BlogPostUpdateWithoutViewsInput>, BlogPostUncheckedUpdateWithoutViewsInput>
  }

  export type BlogPostCreateNestedOneWithoutInteractionsInput = {
    create?: XOR<BlogPostCreateWithoutInteractionsInput, BlogPostUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutInteractionsInput
    connect?: BlogPostWhereUniqueInput
  }

  export type EnumInteractionTypeFieldUpdateOperationsInput = {
    set?: $Enums.InteractionType
  }

  export type BlogPostUpdateOneRequiredWithoutInteractionsNestedInput = {
    create?: XOR<BlogPostCreateWithoutInteractionsInput, BlogPostUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutInteractionsInput
    upsert?: BlogPostUpsertWithoutInteractionsInput
    connect?: BlogPostWhereUniqueInput
    update?: XOR<XOR<BlogPostUpdateToOneWithWhereWithoutInteractionsInput, BlogPostUpdateWithoutInteractionsInput>, BlogPostUncheckedUpdateWithoutInteractionsInput>
  }

  export type BlogPostCreateNestedOneWithoutSeoEventsInput = {
    create?: XOR<BlogPostCreateWithoutSeoEventsInput, BlogPostUncheckedCreateWithoutSeoEventsInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutSeoEventsInput
    connect?: BlogPostWhereUniqueInput
  }

  export type EnumSEOEventTypeFieldUpdateOperationsInput = {
    set?: $Enums.SEOEventType
  }

  export type EnumSEOSeverityFieldUpdateOperationsInput = {
    set?: $Enums.SEOSeverity
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type BlogPostUpdateOneWithoutSeoEventsNestedInput = {
    create?: XOR<BlogPostCreateWithoutSeoEventsInput, BlogPostUncheckedCreateWithoutSeoEventsInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutSeoEventsInput
    upsert?: BlogPostUpsertWithoutSeoEventsInput
    disconnect?: BlogPostWhereInput | boolean
    delete?: BlogPostWhereInput | boolean
    connect?: BlogPostWhereUniqueInput
    update?: XOR<XOR<BlogPostUpdateToOneWithWhereWithoutSeoEventsInput, BlogPostUpdateWithoutSeoEventsInput>, BlogPostUncheckedUpdateWithoutSeoEventsInput>
  }

  export type BlogPostCreateNestedOneWithoutSeoKeywordsInput = {
    create?: XOR<BlogPostCreateWithoutSeoKeywordsInput, BlogPostUncheckedCreateWithoutSeoKeywordsInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutSeoKeywordsInput
    connect?: BlogPostWhereUniqueInput
  }

  export type BlogPostUpdateOneWithoutSeoKeywordsNestedInput = {
    create?: XOR<BlogPostCreateWithoutSeoKeywordsInput, BlogPostUncheckedCreateWithoutSeoKeywordsInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutSeoKeywordsInput
    upsert?: BlogPostUpsertWithoutSeoKeywordsInput
    disconnect?: BlogPostWhereInput | boolean
    delete?: BlogPostWhereInput | boolean
    connect?: BlogPostWhereUniqueInput
    update?: XOR<XOR<BlogPostUpdateToOneWithWhereWithoutSeoKeywordsInput, BlogPostUpdateWithoutSeoKeywordsInput>, BlogPostUncheckedUpdateWithoutSeoKeywordsInput>
  }

  export type BlogPostCreateNestedOneWithoutSitemapEntriesInput = {
    create?: XOR<BlogPostCreateWithoutSitemapEntriesInput, BlogPostUncheckedCreateWithoutSitemapEntriesInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutSitemapEntriesInput
    connect?: BlogPostWhereUniqueInput
  }

  export type EnumChangeFrequencyFieldUpdateOperationsInput = {
    set?: $Enums.ChangeFrequency
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BlogPostUpdateOneWithoutSitemapEntriesNestedInput = {
    create?: XOR<BlogPostCreateWithoutSitemapEntriesInput, BlogPostUncheckedCreateWithoutSitemapEntriesInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutSitemapEntriesInput
    upsert?: BlogPostUpsertWithoutSitemapEntriesInput
    disconnect?: BlogPostWhereInput | boolean
    delete?: BlogPostWhereInput | boolean
    connect?: BlogPostWhereUniqueInput
    update?: XOR<XOR<BlogPostUpdateToOneWithWhereWithoutSitemapEntriesInput, BlogPostUpdateWithoutSitemapEntriesInput>, BlogPostUncheckedUpdateWithoutSitemapEntriesInput>
  }

  export type ProjectCreatetagsInput = {
    set: string[]
  }

  export type ProjectUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumSubmissionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubmissionStatus
  }

  export type EnumSecurityEventTypeFieldUpdateOperationsInput = {
    set?: $Enums.SecurityEventType
  }

  export type EnumSecuritySeverityFieldUpdateOperationsInput = {
    set?: $Enums.SecuritySeverity
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumContentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentType | EnumContentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContentTypeFilter<$PrismaModel> | $Enums.ContentType
  }

  export type NestedEnumPostStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PostStatus | EnumPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPostStatusFilter<$PrismaModel> | $Enums.PostStatus
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumContentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentType | EnumContentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContentTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContentTypeFilter<$PrismaModel>
    _max?: NestedEnumContentTypeFilter<$PrismaModel>
  }

  export type NestedEnumPostStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostStatus | EnumPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPostStatusWithAggregatesFilter<$PrismaModel> | $Enums.PostStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostStatusFilter<$PrismaModel>
    _max?: NestedEnumPostStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumRelationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RelationType | EnumRelationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RelationType[] | ListEnumRelationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RelationType[] | ListEnumRelationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRelationTypeFilter<$PrismaModel> | $Enums.RelationType
  }

  export type NestedEnumRelationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RelationType | EnumRelationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RelationType[] | ListEnumRelationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RelationType[] | ListEnumRelationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRelationTypeWithAggregatesFilter<$PrismaModel> | $Enums.RelationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRelationTypeFilter<$PrismaModel>
    _max?: NestedEnumRelationTypeFilter<$PrismaModel>
  }

  export type NestedEnumChangeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ChangeType | EnumChangeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChangeType[] | ListEnumChangeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChangeType[] | ListEnumChangeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChangeTypeFilter<$PrismaModel> | $Enums.ChangeType
  }

  export type NestedEnumChangeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChangeType | EnumChangeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChangeType[] | ListEnumChangeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChangeType[] | ListEnumChangeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChangeTypeWithAggregatesFilter<$PrismaModel> | $Enums.ChangeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChangeTypeFilter<$PrismaModel>
    _max?: NestedEnumChangeTypeFilter<$PrismaModel>
  }

  export type NestedEnumInteractionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InteractionType | EnumInteractionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InteractionType[] | ListEnumInteractionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InteractionType[] | ListEnumInteractionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInteractionTypeFilter<$PrismaModel> | $Enums.InteractionType
  }

  export type NestedEnumInteractionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InteractionType | EnumInteractionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InteractionType[] | ListEnumInteractionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InteractionType[] | ListEnumInteractionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInteractionTypeWithAggregatesFilter<$PrismaModel> | $Enums.InteractionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInteractionTypeFilter<$PrismaModel>
    _max?: NestedEnumInteractionTypeFilter<$PrismaModel>
  }

  export type NestedEnumSEOEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SEOEventType | EnumSEOEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SEOEventType[] | ListEnumSEOEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SEOEventType[] | ListEnumSEOEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSEOEventTypeFilter<$PrismaModel> | $Enums.SEOEventType
  }

  export type NestedEnumSEOSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.SEOSeverity | EnumSEOSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.SEOSeverity[] | ListEnumSEOSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.SEOSeverity[] | ListEnumSEOSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumSEOSeverityFilter<$PrismaModel> | $Enums.SEOSeverity
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumSEOEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SEOEventType | EnumSEOEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SEOEventType[] | ListEnumSEOEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SEOEventType[] | ListEnumSEOEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSEOEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.SEOEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSEOEventTypeFilter<$PrismaModel>
    _max?: NestedEnumSEOEventTypeFilter<$PrismaModel>
  }

  export type NestedEnumSEOSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SEOSeverity | EnumSEOSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.SEOSeverity[] | ListEnumSEOSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.SEOSeverity[] | ListEnumSEOSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumSEOSeverityWithAggregatesFilter<$PrismaModel> | $Enums.SEOSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSEOSeverityFilter<$PrismaModel>
    _max?: NestedEnumSEOSeverityFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumChangeFrequencyFilter<$PrismaModel = never> = {
    equals?: $Enums.ChangeFrequency | EnumChangeFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.ChangeFrequency[] | ListEnumChangeFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChangeFrequency[] | ListEnumChangeFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumChangeFrequencyFilter<$PrismaModel> | $Enums.ChangeFrequency
  }

  export type NestedEnumChangeFrequencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChangeFrequency | EnumChangeFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.ChangeFrequency[] | ListEnumChangeFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChangeFrequency[] | ListEnumChangeFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumChangeFrequencyWithAggregatesFilter<$PrismaModel> | $Enums.ChangeFrequency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChangeFrequencyFilter<$PrismaModel>
    _max?: NestedEnumChangeFrequencyFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumSubmissionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubmissionStatus | EnumSubmissionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubmissionStatus[] | ListEnumSubmissionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubmissionStatus[] | ListEnumSubmissionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubmissionStatusFilter<$PrismaModel> | $Enums.SubmissionStatus
  }

  export type NestedEnumSubmissionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubmissionStatus | EnumSubmissionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubmissionStatus[] | ListEnumSubmissionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubmissionStatus[] | ListEnumSubmissionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubmissionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubmissionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubmissionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubmissionStatusFilter<$PrismaModel>
  }

  export type NestedEnumSecurityEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SecurityEventType | EnumSecurityEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SecurityEventType[] | ListEnumSecurityEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SecurityEventType[] | ListEnumSecurityEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSecurityEventTypeFilter<$PrismaModel> | $Enums.SecurityEventType
  }

  export type NestedEnumSecuritySeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.SecuritySeverity | EnumSecuritySeverityFieldRefInput<$PrismaModel>
    in?: $Enums.SecuritySeverity[] | ListEnumSecuritySeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.SecuritySeverity[] | ListEnumSecuritySeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumSecuritySeverityFilter<$PrismaModel> | $Enums.SecuritySeverity
  }

  export type NestedEnumSecurityEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SecurityEventType | EnumSecurityEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SecurityEventType[] | ListEnumSecurityEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SecurityEventType[] | ListEnumSecurityEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSecurityEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.SecurityEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSecurityEventTypeFilter<$PrismaModel>
    _max?: NestedEnumSecurityEventTypeFilter<$PrismaModel>
  }

  export type NestedEnumSecuritySeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SecuritySeverity | EnumSecuritySeverityFieldRefInput<$PrismaModel>
    in?: $Enums.SecuritySeverity[] | ListEnumSecuritySeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.SecuritySeverity[] | ListEnumSecuritySeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumSecuritySeverityWithAggregatesFilter<$PrismaModel> | $Enums.SecuritySeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSecuritySeverityFilter<$PrismaModel>
    _max?: NestedEnumSecuritySeverityFilter<$PrismaModel>
  }

  export type AuthorCreateWithoutPostsInput = {
    id?: string
    name: string
    email: string
    slug: string
    bio?: string | null
    avatar?: string | null
    website?: string | null
    twitter?: string | null
    linkedin?: string | null
    github?: string | null
    metaDescription?: string | null
    totalViews?: number
    totalPosts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    postVersions?: PostVersionCreateNestedManyWithoutAuthorInput
  }

  export type AuthorUncheckedCreateWithoutPostsInput = {
    id?: string
    name: string
    email: string
    slug: string
    bio?: string | null
    avatar?: string | null
    website?: string | null
    twitter?: string | null
    linkedin?: string | null
    github?: string | null
    metaDescription?: string | null
    totalViews?: number
    totalPosts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    postVersions?: PostVersionUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type AuthorCreateOrConnectWithoutPostsInput = {
    where: AuthorWhereUniqueInput
    create: XOR<AuthorCreateWithoutPostsInput, AuthorUncheckedCreateWithoutPostsInput>
  }

  export type CategoryCreateWithoutPostsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    color?: string | null
    icon?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: CategoryCreatekeywordsInput | string[]
    postCount?: number
    totalViews?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    children?: CategoryCreateNestedManyWithoutParentInput
  }

  export type CategoryUncheckedCreateWithoutPostsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    color?: string | null
    icon?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: CategoryCreatekeywordsInput | string[]
    parentId?: string | null
    postCount?: number
    totalViews?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
  }

  export type CategoryCreateOrConnectWithoutPostsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutPostsInput, CategoryUncheckedCreateWithoutPostsInput>
  }

  export type PostTagCreateWithoutPostInput = {
    createdAt?: Date | string
    tag: TagCreateNestedOneWithoutPostsInput
  }

  export type PostTagUncheckedCreateWithoutPostInput = {
    tagId: string
    createdAt?: Date | string
  }

  export type PostTagCreateOrConnectWithoutPostInput = {
    where: PostTagWhereUniqueInput
    create: XOR<PostTagCreateWithoutPostInput, PostTagUncheckedCreateWithoutPostInput>
  }

  export type PostTagCreateManyPostInputEnvelope = {
    data: PostTagCreateManyPostInput | PostTagCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type SeriesPostCreateWithoutPostInput = {
    order: number
    createdAt?: Date | string
    series: PostSeriesCreateNestedOneWithoutPostsInput
  }

  export type SeriesPostUncheckedCreateWithoutPostInput = {
    seriesId: string
    order: number
    createdAt?: Date | string
  }

  export type SeriesPostCreateOrConnectWithoutPostInput = {
    where: SeriesPostWhereUniqueInput
    create: XOR<SeriesPostCreateWithoutPostInput, SeriesPostUncheckedCreateWithoutPostInput>
  }

  export type SeriesPostCreateManyPostInputEnvelope = {
    data: SeriesPostCreateManyPostInput | SeriesPostCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type PostRelationCreateWithoutOriginalPostInput = {
    id?: string
    relationType?: $Enums.RelationType
    createdAt?: Date | string
    relatedPost: BlogPostCreateNestedOneWithoutRelatedToPostsInput
  }

  export type PostRelationUncheckedCreateWithoutOriginalPostInput = {
    id?: string
    relatedPostId: string
    relationType?: $Enums.RelationType
    createdAt?: Date | string
  }

  export type PostRelationCreateOrConnectWithoutOriginalPostInput = {
    where: PostRelationWhereUniqueInput
    create: XOR<PostRelationCreateWithoutOriginalPostInput, PostRelationUncheckedCreateWithoutOriginalPostInput>
  }

  export type PostRelationCreateManyOriginalPostInputEnvelope = {
    data: PostRelationCreateManyOriginalPostInput | PostRelationCreateManyOriginalPostInput[]
    skipDuplicates?: boolean
  }

  export type PostRelationCreateWithoutRelatedPostInput = {
    id?: string
    relationType?: $Enums.RelationType
    createdAt?: Date | string
    originalPost: BlogPostCreateNestedOneWithoutRelatedPostsInput
  }

  export type PostRelationUncheckedCreateWithoutRelatedPostInput = {
    id?: string
    originalPostId: string
    relationType?: $Enums.RelationType
    createdAt?: Date | string
  }

  export type PostRelationCreateOrConnectWithoutRelatedPostInput = {
    where: PostRelationWhereUniqueInput
    create: XOR<PostRelationCreateWithoutRelatedPostInput, PostRelationUncheckedCreateWithoutRelatedPostInput>
  }

  export type PostRelationCreateManyRelatedPostInputEnvelope = {
    data: PostRelationCreateManyRelatedPostInput | PostRelationCreateManyRelatedPostInput[]
    skipDuplicates?: boolean
  }

  export type PostVersionCreateWithoutPostInput = {
    id?: string
    version: number
    title: string
    content: string
    excerpt?: string | null
    changeType?: $Enums.ChangeType
    changeNotes?: string | null
    createdAt?: Date | string
    author: AuthorCreateNestedOneWithoutPostVersionsInput
  }

  export type PostVersionUncheckedCreateWithoutPostInput = {
    id?: string
    version: number
    title: string
    content: string
    excerpt?: string | null
    changeType?: $Enums.ChangeType
    changeNotes?: string | null
    authorId: string
    createdAt?: Date | string
  }

  export type PostVersionCreateOrConnectWithoutPostInput = {
    where: PostVersionWhereUniqueInput
    create: XOR<PostVersionCreateWithoutPostInput, PostVersionUncheckedCreateWithoutPostInput>
  }

  export type PostVersionCreateManyPostInputEnvelope = {
    data: PostVersionCreateManyPostInput | PostVersionCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type PostViewCreateWithoutPostInput = {
    id?: string
    visitorId?: string | null
    sessionId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    referer?: string | null
    country?: string | null
    region?: string | null
    city?: string | null
    readingTime?: number | null
    scrollDepth?: number | null
    viewedAt?: Date | string
  }

  export type PostViewUncheckedCreateWithoutPostInput = {
    id?: string
    visitorId?: string | null
    sessionId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    referer?: string | null
    country?: string | null
    region?: string | null
    city?: string | null
    readingTime?: number | null
    scrollDepth?: number | null
    viewedAt?: Date | string
  }

  export type PostViewCreateOrConnectWithoutPostInput = {
    where: PostViewWhereUniqueInput
    create: XOR<PostViewCreateWithoutPostInput, PostViewUncheckedCreateWithoutPostInput>
  }

  export type PostViewCreateManyPostInputEnvelope = {
    data: PostViewCreateManyPostInput | PostViewCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type PostInteractionCreateWithoutPostInput = {
    id?: string
    type: $Enums.InteractionType
    visitorId?: string | null
    sessionId?: string | null
    value?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PostInteractionUncheckedCreateWithoutPostInput = {
    id?: string
    type: $Enums.InteractionType
    visitorId?: string | null
    sessionId?: string | null
    value?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PostInteractionCreateOrConnectWithoutPostInput = {
    where: PostInteractionWhereUniqueInput
    create: XOR<PostInteractionCreateWithoutPostInput, PostInteractionUncheckedCreateWithoutPostInput>
  }

  export type PostInteractionCreateManyPostInputEnvelope = {
    data: PostInteractionCreateManyPostInput | PostInteractionCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type SEOEventCreateWithoutPostInput = {
    id?: string
    type: $Enums.SEOEventType
    title: string
    description?: string | null
    severity?: $Enums.SEOSeverity
    oldValue?: string | null
    newValue?: string | null
    recommendations?: string | null
    processed?: boolean
    processedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SEOEventUncheckedCreateWithoutPostInput = {
    id?: string
    type: $Enums.SEOEventType
    title: string
    description?: string | null
    severity?: $Enums.SEOSeverity
    oldValue?: string | null
    newValue?: string | null
    recommendations?: string | null
    processed?: boolean
    processedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SEOEventCreateOrConnectWithoutPostInput = {
    where: SEOEventWhereUniqueInput
    create: XOR<SEOEventCreateWithoutPostInput, SEOEventUncheckedCreateWithoutPostInput>
  }

  export type SEOEventCreateManyPostInputEnvelope = {
    data: SEOEventCreateManyPostInput | SEOEventCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type SEOKeywordCreateWithoutPostInput = {
    id?: string
    keyword: string
    position?: number | null
    searchVolume?: number | null
    difficulty?: number | null
    cpc?: number | null
    clicks?: number
    impressions?: number
    ctr?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastChecked?: Date | string | null
  }

  export type SEOKeywordUncheckedCreateWithoutPostInput = {
    id?: string
    keyword: string
    position?: number | null
    searchVolume?: number | null
    difficulty?: number | null
    cpc?: number | null
    clicks?: number
    impressions?: number
    ctr?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastChecked?: Date | string | null
  }

  export type SEOKeywordCreateOrConnectWithoutPostInput = {
    where: SEOKeywordWhereUniqueInput
    create: XOR<SEOKeywordCreateWithoutPostInput, SEOKeywordUncheckedCreateWithoutPostInput>
  }

  export type SEOKeywordCreateManyPostInputEnvelope = {
    data: SEOKeywordCreateManyPostInput | SEOKeywordCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type SitemapEntryCreateWithoutPostInput = {
    id?: string
    url: string
    lastMod: Date | string
    changeFreq?: $Enums.ChangeFrequency
    priority?: number
    included?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SitemapEntryUncheckedCreateWithoutPostInput = {
    id?: string
    url: string
    lastMod: Date | string
    changeFreq?: $Enums.ChangeFrequency
    priority?: number
    included?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SitemapEntryCreateOrConnectWithoutPostInput = {
    where: SitemapEntryWhereUniqueInput
    create: XOR<SitemapEntryCreateWithoutPostInput, SitemapEntryUncheckedCreateWithoutPostInput>
  }

  export type SitemapEntryCreateManyPostInputEnvelope = {
    data: SitemapEntryCreateManyPostInput | SitemapEntryCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type AuthorUpsertWithoutPostsInput = {
    update: XOR<AuthorUpdateWithoutPostsInput, AuthorUncheckedUpdateWithoutPostsInput>
    create: XOR<AuthorCreateWithoutPostsInput, AuthorUncheckedCreateWithoutPostsInput>
    where?: AuthorWhereInput
  }

  export type AuthorUpdateToOneWithWhereWithoutPostsInput = {
    where?: AuthorWhereInput
    data: XOR<AuthorUpdateWithoutPostsInput, AuthorUncheckedUpdateWithoutPostsInput>
  }

  export type AuthorUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    totalViews?: IntFieldUpdateOperationsInput | number
    totalPosts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postVersions?: PostVersionUpdateManyWithoutAuthorNestedInput
  }

  export type AuthorUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    totalViews?: IntFieldUpdateOperationsInput | number
    totalPosts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postVersions?: PostVersionUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type CategoryUpsertWithoutPostsInput = {
    update: XOR<CategoryUpdateWithoutPostsInput, CategoryUncheckedUpdateWithoutPostsInput>
    create: XOR<CategoryCreateWithoutPostsInput, CategoryUncheckedCreateWithoutPostsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutPostsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutPostsInput, CategoryUncheckedUpdateWithoutPostsInput>
  }

  export type CategoryUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: CategoryUpdatekeywordsInput | string[]
    postCount?: IntFieldUpdateOperationsInput | number
    totalViews?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
  }

  export type CategoryUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: CategoryUpdatekeywordsInput | string[]
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    totalViews?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
  }

  export type PostTagUpsertWithWhereUniqueWithoutPostInput = {
    where: PostTagWhereUniqueInput
    update: XOR<PostTagUpdateWithoutPostInput, PostTagUncheckedUpdateWithoutPostInput>
    create: XOR<PostTagCreateWithoutPostInput, PostTagUncheckedCreateWithoutPostInput>
  }

  export type PostTagUpdateWithWhereUniqueWithoutPostInput = {
    where: PostTagWhereUniqueInput
    data: XOR<PostTagUpdateWithoutPostInput, PostTagUncheckedUpdateWithoutPostInput>
  }

  export type PostTagUpdateManyWithWhereWithoutPostInput = {
    where: PostTagScalarWhereInput
    data: XOR<PostTagUpdateManyMutationInput, PostTagUncheckedUpdateManyWithoutPostInput>
  }

  export type PostTagScalarWhereInput = {
    AND?: PostTagScalarWhereInput | PostTagScalarWhereInput[]
    OR?: PostTagScalarWhereInput[]
    NOT?: PostTagScalarWhereInput | PostTagScalarWhereInput[]
    postId?: StringFilter<"PostTag"> | string
    tagId?: StringFilter<"PostTag"> | string
    createdAt?: DateTimeFilter<"PostTag"> | Date | string
  }

  export type SeriesPostUpsertWithWhereUniqueWithoutPostInput = {
    where: SeriesPostWhereUniqueInput
    update: XOR<SeriesPostUpdateWithoutPostInput, SeriesPostUncheckedUpdateWithoutPostInput>
    create: XOR<SeriesPostCreateWithoutPostInput, SeriesPostUncheckedCreateWithoutPostInput>
  }

  export type SeriesPostUpdateWithWhereUniqueWithoutPostInput = {
    where: SeriesPostWhereUniqueInput
    data: XOR<SeriesPostUpdateWithoutPostInput, SeriesPostUncheckedUpdateWithoutPostInput>
  }

  export type SeriesPostUpdateManyWithWhereWithoutPostInput = {
    where: SeriesPostScalarWhereInput
    data: XOR<SeriesPostUpdateManyMutationInput, SeriesPostUncheckedUpdateManyWithoutPostInput>
  }

  export type SeriesPostScalarWhereInput = {
    AND?: SeriesPostScalarWhereInput | SeriesPostScalarWhereInput[]
    OR?: SeriesPostScalarWhereInput[]
    NOT?: SeriesPostScalarWhereInput | SeriesPostScalarWhereInput[]
    seriesId?: StringFilter<"SeriesPost"> | string
    postId?: StringFilter<"SeriesPost"> | string
    order?: IntFilter<"SeriesPost"> | number
    createdAt?: DateTimeFilter<"SeriesPost"> | Date | string
  }

  export type PostRelationUpsertWithWhereUniqueWithoutOriginalPostInput = {
    where: PostRelationWhereUniqueInput
    update: XOR<PostRelationUpdateWithoutOriginalPostInput, PostRelationUncheckedUpdateWithoutOriginalPostInput>
    create: XOR<PostRelationCreateWithoutOriginalPostInput, PostRelationUncheckedCreateWithoutOriginalPostInput>
  }

  export type PostRelationUpdateWithWhereUniqueWithoutOriginalPostInput = {
    where: PostRelationWhereUniqueInput
    data: XOR<PostRelationUpdateWithoutOriginalPostInput, PostRelationUncheckedUpdateWithoutOriginalPostInput>
  }

  export type PostRelationUpdateManyWithWhereWithoutOriginalPostInput = {
    where: PostRelationScalarWhereInput
    data: XOR<PostRelationUpdateManyMutationInput, PostRelationUncheckedUpdateManyWithoutOriginalPostInput>
  }

  export type PostRelationScalarWhereInput = {
    AND?: PostRelationScalarWhereInput | PostRelationScalarWhereInput[]
    OR?: PostRelationScalarWhereInput[]
    NOT?: PostRelationScalarWhereInput | PostRelationScalarWhereInput[]
    id?: StringFilter<"PostRelation"> | string
    originalPostId?: StringFilter<"PostRelation"> | string
    relatedPostId?: StringFilter<"PostRelation"> | string
    relationType?: EnumRelationTypeFilter<"PostRelation"> | $Enums.RelationType
    createdAt?: DateTimeFilter<"PostRelation"> | Date | string
  }

  export type PostRelationUpsertWithWhereUniqueWithoutRelatedPostInput = {
    where: PostRelationWhereUniqueInput
    update: XOR<PostRelationUpdateWithoutRelatedPostInput, PostRelationUncheckedUpdateWithoutRelatedPostInput>
    create: XOR<PostRelationCreateWithoutRelatedPostInput, PostRelationUncheckedCreateWithoutRelatedPostInput>
  }

  export type PostRelationUpdateWithWhereUniqueWithoutRelatedPostInput = {
    where: PostRelationWhereUniqueInput
    data: XOR<PostRelationUpdateWithoutRelatedPostInput, PostRelationUncheckedUpdateWithoutRelatedPostInput>
  }

  export type PostRelationUpdateManyWithWhereWithoutRelatedPostInput = {
    where: PostRelationScalarWhereInput
    data: XOR<PostRelationUpdateManyMutationInput, PostRelationUncheckedUpdateManyWithoutRelatedPostInput>
  }

  export type PostVersionUpsertWithWhereUniqueWithoutPostInput = {
    where: PostVersionWhereUniqueInput
    update: XOR<PostVersionUpdateWithoutPostInput, PostVersionUncheckedUpdateWithoutPostInput>
    create: XOR<PostVersionCreateWithoutPostInput, PostVersionUncheckedCreateWithoutPostInput>
  }

  export type PostVersionUpdateWithWhereUniqueWithoutPostInput = {
    where: PostVersionWhereUniqueInput
    data: XOR<PostVersionUpdateWithoutPostInput, PostVersionUncheckedUpdateWithoutPostInput>
  }

  export type PostVersionUpdateManyWithWhereWithoutPostInput = {
    where: PostVersionScalarWhereInput
    data: XOR<PostVersionUpdateManyMutationInput, PostVersionUncheckedUpdateManyWithoutPostInput>
  }

  export type PostVersionScalarWhereInput = {
    AND?: PostVersionScalarWhereInput | PostVersionScalarWhereInput[]
    OR?: PostVersionScalarWhereInput[]
    NOT?: PostVersionScalarWhereInput | PostVersionScalarWhereInput[]
    id?: StringFilter<"PostVersion"> | string
    postId?: StringFilter<"PostVersion"> | string
    version?: IntFilter<"PostVersion"> | number
    title?: StringFilter<"PostVersion"> | string
    content?: StringFilter<"PostVersion"> | string
    excerpt?: StringNullableFilter<"PostVersion"> | string | null
    changeType?: EnumChangeTypeFilter<"PostVersion"> | $Enums.ChangeType
    changeNotes?: StringNullableFilter<"PostVersion"> | string | null
    authorId?: StringFilter<"PostVersion"> | string
    createdAt?: DateTimeFilter<"PostVersion"> | Date | string
  }

  export type PostViewUpsertWithWhereUniqueWithoutPostInput = {
    where: PostViewWhereUniqueInput
    update: XOR<PostViewUpdateWithoutPostInput, PostViewUncheckedUpdateWithoutPostInput>
    create: XOR<PostViewCreateWithoutPostInput, PostViewUncheckedCreateWithoutPostInput>
  }

  export type PostViewUpdateWithWhereUniqueWithoutPostInput = {
    where: PostViewWhereUniqueInput
    data: XOR<PostViewUpdateWithoutPostInput, PostViewUncheckedUpdateWithoutPostInput>
  }

  export type PostViewUpdateManyWithWhereWithoutPostInput = {
    where: PostViewScalarWhereInput
    data: XOR<PostViewUpdateManyMutationInput, PostViewUncheckedUpdateManyWithoutPostInput>
  }

  export type PostViewScalarWhereInput = {
    AND?: PostViewScalarWhereInput | PostViewScalarWhereInput[]
    OR?: PostViewScalarWhereInput[]
    NOT?: PostViewScalarWhereInput | PostViewScalarWhereInput[]
    id?: StringFilter<"PostView"> | string
    postId?: StringFilter<"PostView"> | string
    visitorId?: StringNullableFilter<"PostView"> | string | null
    sessionId?: StringNullableFilter<"PostView"> | string | null
    ipAddress?: StringNullableFilter<"PostView"> | string | null
    userAgent?: StringNullableFilter<"PostView"> | string | null
    referer?: StringNullableFilter<"PostView"> | string | null
    country?: StringNullableFilter<"PostView"> | string | null
    region?: StringNullableFilter<"PostView"> | string | null
    city?: StringNullableFilter<"PostView"> | string | null
    readingTime?: IntNullableFilter<"PostView"> | number | null
    scrollDepth?: FloatNullableFilter<"PostView"> | number | null
    viewedAt?: DateTimeFilter<"PostView"> | Date | string
  }

  export type PostInteractionUpsertWithWhereUniqueWithoutPostInput = {
    where: PostInteractionWhereUniqueInput
    update: XOR<PostInteractionUpdateWithoutPostInput, PostInteractionUncheckedUpdateWithoutPostInput>
    create: XOR<PostInteractionCreateWithoutPostInput, PostInteractionUncheckedCreateWithoutPostInput>
  }

  export type PostInteractionUpdateWithWhereUniqueWithoutPostInput = {
    where: PostInteractionWhereUniqueInput
    data: XOR<PostInteractionUpdateWithoutPostInput, PostInteractionUncheckedUpdateWithoutPostInput>
  }

  export type PostInteractionUpdateManyWithWhereWithoutPostInput = {
    where: PostInteractionScalarWhereInput
    data: XOR<PostInteractionUpdateManyMutationInput, PostInteractionUncheckedUpdateManyWithoutPostInput>
  }

  export type PostInteractionScalarWhereInput = {
    AND?: PostInteractionScalarWhereInput | PostInteractionScalarWhereInput[]
    OR?: PostInteractionScalarWhereInput[]
    NOT?: PostInteractionScalarWhereInput | PostInteractionScalarWhereInput[]
    id?: StringFilter<"PostInteraction"> | string
    postId?: StringFilter<"PostInteraction"> | string
    type?: EnumInteractionTypeFilter<"PostInteraction"> | $Enums.InteractionType
    visitorId?: StringNullableFilter<"PostInteraction"> | string | null
    sessionId?: StringNullableFilter<"PostInteraction"> | string | null
    value?: StringNullableFilter<"PostInteraction"> | string | null
    metadata?: JsonNullableFilter<"PostInteraction">
    createdAt?: DateTimeFilter<"PostInteraction"> | Date | string
  }

  export type SEOEventUpsertWithWhereUniqueWithoutPostInput = {
    where: SEOEventWhereUniqueInput
    update: XOR<SEOEventUpdateWithoutPostInput, SEOEventUncheckedUpdateWithoutPostInput>
    create: XOR<SEOEventCreateWithoutPostInput, SEOEventUncheckedCreateWithoutPostInput>
  }

  export type SEOEventUpdateWithWhereUniqueWithoutPostInput = {
    where: SEOEventWhereUniqueInput
    data: XOR<SEOEventUpdateWithoutPostInput, SEOEventUncheckedUpdateWithoutPostInput>
  }

  export type SEOEventUpdateManyWithWhereWithoutPostInput = {
    where: SEOEventScalarWhereInput
    data: XOR<SEOEventUpdateManyMutationInput, SEOEventUncheckedUpdateManyWithoutPostInput>
  }

  export type SEOEventScalarWhereInput = {
    AND?: SEOEventScalarWhereInput | SEOEventScalarWhereInput[]
    OR?: SEOEventScalarWhereInput[]
    NOT?: SEOEventScalarWhereInput | SEOEventScalarWhereInput[]
    id?: StringFilter<"SEOEvent"> | string
    postId?: StringNullableFilter<"SEOEvent"> | string | null
    type?: EnumSEOEventTypeFilter<"SEOEvent"> | $Enums.SEOEventType
    title?: StringFilter<"SEOEvent"> | string
    description?: StringNullableFilter<"SEOEvent"> | string | null
    severity?: EnumSEOSeverityFilter<"SEOEvent"> | $Enums.SEOSeverity
    oldValue?: StringNullableFilter<"SEOEvent"> | string | null
    newValue?: StringNullableFilter<"SEOEvent"> | string | null
    recommendations?: StringNullableFilter<"SEOEvent"> | string | null
    processed?: BoolFilter<"SEOEvent"> | boolean
    processedAt?: DateTimeNullableFilter<"SEOEvent"> | Date | string | null
    createdAt?: DateTimeFilter<"SEOEvent"> | Date | string
  }

  export type SEOKeywordUpsertWithWhereUniqueWithoutPostInput = {
    where: SEOKeywordWhereUniqueInput
    update: XOR<SEOKeywordUpdateWithoutPostInput, SEOKeywordUncheckedUpdateWithoutPostInput>
    create: XOR<SEOKeywordCreateWithoutPostInput, SEOKeywordUncheckedCreateWithoutPostInput>
  }

  export type SEOKeywordUpdateWithWhereUniqueWithoutPostInput = {
    where: SEOKeywordWhereUniqueInput
    data: XOR<SEOKeywordUpdateWithoutPostInput, SEOKeywordUncheckedUpdateWithoutPostInput>
  }

  export type SEOKeywordUpdateManyWithWhereWithoutPostInput = {
    where: SEOKeywordScalarWhereInput
    data: XOR<SEOKeywordUpdateManyMutationInput, SEOKeywordUncheckedUpdateManyWithoutPostInput>
  }

  export type SEOKeywordScalarWhereInput = {
    AND?: SEOKeywordScalarWhereInput | SEOKeywordScalarWhereInput[]
    OR?: SEOKeywordScalarWhereInput[]
    NOT?: SEOKeywordScalarWhereInput | SEOKeywordScalarWhereInput[]
    id?: StringFilter<"SEOKeyword"> | string
    keyword?: StringFilter<"SEOKeyword"> | string
    postId?: StringNullableFilter<"SEOKeyword"> | string | null
    position?: IntNullableFilter<"SEOKeyword"> | number | null
    searchVolume?: IntNullableFilter<"SEOKeyword"> | number | null
    difficulty?: FloatNullableFilter<"SEOKeyword"> | number | null
    cpc?: FloatNullableFilter<"SEOKeyword"> | number | null
    clicks?: IntFilter<"SEOKeyword"> | number
    impressions?: IntFilter<"SEOKeyword"> | number
    ctr?: FloatNullableFilter<"SEOKeyword"> | number | null
    createdAt?: DateTimeFilter<"SEOKeyword"> | Date | string
    updatedAt?: DateTimeFilter<"SEOKeyword"> | Date | string
    lastChecked?: DateTimeNullableFilter<"SEOKeyword"> | Date | string | null
  }

  export type SitemapEntryUpsertWithWhereUniqueWithoutPostInput = {
    where: SitemapEntryWhereUniqueInput
    update: XOR<SitemapEntryUpdateWithoutPostInput, SitemapEntryUncheckedUpdateWithoutPostInput>
    create: XOR<SitemapEntryCreateWithoutPostInput, SitemapEntryUncheckedCreateWithoutPostInput>
  }

  export type SitemapEntryUpdateWithWhereUniqueWithoutPostInput = {
    where: SitemapEntryWhereUniqueInput
    data: XOR<SitemapEntryUpdateWithoutPostInput, SitemapEntryUncheckedUpdateWithoutPostInput>
  }

  export type SitemapEntryUpdateManyWithWhereWithoutPostInput = {
    where: SitemapEntryScalarWhereInput
    data: XOR<SitemapEntryUpdateManyMutationInput, SitemapEntryUncheckedUpdateManyWithoutPostInput>
  }

  export type SitemapEntryScalarWhereInput = {
    AND?: SitemapEntryScalarWhereInput | SitemapEntryScalarWhereInput[]
    OR?: SitemapEntryScalarWhereInput[]
    NOT?: SitemapEntryScalarWhereInput | SitemapEntryScalarWhereInput[]
    id?: StringFilter<"SitemapEntry"> | string
    url?: StringFilter<"SitemapEntry"> | string
    lastMod?: DateTimeFilter<"SitemapEntry"> | Date | string
    changeFreq?: EnumChangeFrequencyFilter<"SitemapEntry"> | $Enums.ChangeFrequency
    priority?: FloatFilter<"SitemapEntry"> | number
    postId?: StringNullableFilter<"SitemapEntry"> | string | null
    included?: BoolFilter<"SitemapEntry"> | boolean
    createdAt?: DateTimeFilter<"SitemapEntry"> | Date | string
    updatedAt?: DateTimeFilter<"SitemapEntry"> | Date | string
  }

  export type BlogPostCreateWithoutAuthorInput = {
    id?: string
    title: string
    slug: string
    excerpt?: string | null
    content: string
    contentType?: $Enums.ContentType
    status?: $Enums.PostStatus
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: BlogPostCreatekeywordsInput | string[]
    canonicalUrl?: string | null
    ogTitle?: string | null
    ogDescription?: string | null
    ogImage?: string | null
    twitterTitle?: string | null
    twitterDescription?: string | null
    twitterImage?: string | null
    featuredImage?: string | null
    featuredImageAlt?: string | null
    readingTime?: number | null
    wordCount?: number | null
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    archivedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currentVersion?: number
    viewCount?: number
    likeCount?: number
    shareCount?: number
    commentCount?: number
    seoScore?: number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: Date | string | null
    category?: CategoryCreateNestedOneWithoutPostsInput
    tags?: PostTagCreateNestedManyWithoutPostInput
    seriesPosts?: SeriesPostCreateNestedManyWithoutPostInput
    relatedPosts?: PostRelationCreateNestedManyWithoutOriginalPostInput
    relatedToPosts?: PostRelationCreateNestedManyWithoutRelatedPostInput
    versions?: PostVersionCreateNestedManyWithoutPostInput
    views?: PostViewCreateNestedManyWithoutPostInput
    interactions?: PostInteractionCreateNestedManyWithoutPostInput
    seoEvents?: SEOEventCreateNestedManyWithoutPostInput
    seoKeywords?: SEOKeywordCreateNestedManyWithoutPostInput
    sitemapEntries?: SitemapEntryCreateNestedManyWithoutPostInput
  }

  export type BlogPostUncheckedCreateWithoutAuthorInput = {
    id?: string
    title: string
    slug: string
    excerpt?: string | null
    content: string
    contentType?: $Enums.ContentType
    status?: $Enums.PostStatus
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: BlogPostCreatekeywordsInput | string[]
    canonicalUrl?: string | null
    ogTitle?: string | null
    ogDescription?: string | null
    ogImage?: string | null
    twitterTitle?: string | null
    twitterDescription?: string | null
    twitterImage?: string | null
    featuredImage?: string | null
    featuredImageAlt?: string | null
    readingTime?: number | null
    wordCount?: number | null
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    archivedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    categoryId?: string | null
    currentVersion?: number
    viewCount?: number
    likeCount?: number
    shareCount?: number
    commentCount?: number
    seoScore?: number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: Date | string | null
    tags?: PostTagUncheckedCreateNestedManyWithoutPostInput
    seriesPosts?: SeriesPostUncheckedCreateNestedManyWithoutPostInput
    relatedPosts?: PostRelationUncheckedCreateNestedManyWithoutOriginalPostInput
    relatedToPosts?: PostRelationUncheckedCreateNestedManyWithoutRelatedPostInput
    versions?: PostVersionUncheckedCreateNestedManyWithoutPostInput
    views?: PostViewUncheckedCreateNestedManyWithoutPostInput
    interactions?: PostInteractionUncheckedCreateNestedManyWithoutPostInput
    seoEvents?: SEOEventUncheckedCreateNestedManyWithoutPostInput
    seoKeywords?: SEOKeywordUncheckedCreateNestedManyWithoutPostInput
    sitemapEntries?: SitemapEntryUncheckedCreateNestedManyWithoutPostInput
  }

  export type BlogPostCreateOrConnectWithoutAuthorInput = {
    where: BlogPostWhereUniqueInput
    create: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput>
  }

  export type BlogPostCreateManyAuthorInputEnvelope = {
    data: BlogPostCreateManyAuthorInput | BlogPostCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type PostVersionCreateWithoutAuthorInput = {
    id?: string
    version: number
    title: string
    content: string
    excerpt?: string | null
    changeType?: $Enums.ChangeType
    changeNotes?: string | null
    createdAt?: Date | string
    post: BlogPostCreateNestedOneWithoutVersionsInput
  }

  export type PostVersionUncheckedCreateWithoutAuthorInput = {
    id?: string
    postId: string
    version: number
    title: string
    content: string
    excerpt?: string | null
    changeType?: $Enums.ChangeType
    changeNotes?: string | null
    createdAt?: Date | string
  }

  export type PostVersionCreateOrConnectWithoutAuthorInput = {
    where: PostVersionWhereUniqueInput
    create: XOR<PostVersionCreateWithoutAuthorInput, PostVersionUncheckedCreateWithoutAuthorInput>
  }

  export type PostVersionCreateManyAuthorInputEnvelope = {
    data: PostVersionCreateManyAuthorInput | PostVersionCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type BlogPostUpsertWithWhereUniqueWithoutAuthorInput = {
    where: BlogPostWhereUniqueInput
    update: XOR<BlogPostUpdateWithoutAuthorInput, BlogPostUncheckedUpdateWithoutAuthorInput>
    create: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput>
  }

  export type BlogPostUpdateWithWhereUniqueWithoutAuthorInput = {
    where: BlogPostWhereUniqueInput
    data: XOR<BlogPostUpdateWithoutAuthorInput, BlogPostUncheckedUpdateWithoutAuthorInput>
  }

  export type BlogPostUpdateManyWithWhereWithoutAuthorInput = {
    where: BlogPostScalarWhereInput
    data: XOR<BlogPostUpdateManyMutationInput, BlogPostUncheckedUpdateManyWithoutAuthorInput>
  }

  export type BlogPostScalarWhereInput = {
    AND?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
    OR?: BlogPostScalarWhereInput[]
    NOT?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
    id?: StringFilter<"BlogPost"> | string
    title?: StringFilter<"BlogPost"> | string
    slug?: StringFilter<"BlogPost"> | string
    excerpt?: StringNullableFilter<"BlogPost"> | string | null
    content?: StringFilter<"BlogPost"> | string
    contentType?: EnumContentTypeFilter<"BlogPost"> | $Enums.ContentType
    status?: EnumPostStatusFilter<"BlogPost"> | $Enums.PostStatus
    metaTitle?: StringNullableFilter<"BlogPost"> | string | null
    metaDescription?: StringNullableFilter<"BlogPost"> | string | null
    keywords?: StringNullableListFilter<"BlogPost">
    canonicalUrl?: StringNullableFilter<"BlogPost"> | string | null
    ogTitle?: StringNullableFilter<"BlogPost"> | string | null
    ogDescription?: StringNullableFilter<"BlogPost"> | string | null
    ogImage?: StringNullableFilter<"BlogPost"> | string | null
    twitterTitle?: StringNullableFilter<"BlogPost"> | string | null
    twitterDescription?: StringNullableFilter<"BlogPost"> | string | null
    twitterImage?: StringNullableFilter<"BlogPost"> | string | null
    featuredImage?: StringNullableFilter<"BlogPost"> | string | null
    featuredImageAlt?: StringNullableFilter<"BlogPost"> | string | null
    readingTime?: IntNullableFilter<"BlogPost"> | number | null
    wordCount?: IntNullableFilter<"BlogPost"> | number | null
    publishedAt?: DateTimeNullableFilter<"BlogPost"> | Date | string | null
    scheduledAt?: DateTimeNullableFilter<"BlogPost"> | Date | string | null
    archivedAt?: DateTimeNullableFilter<"BlogPost"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"BlogPost"> | Date | string | null
    createdAt?: DateTimeFilter<"BlogPost"> | Date | string
    updatedAt?: DateTimeFilter<"BlogPost"> | Date | string
    authorId?: StringFilter<"BlogPost"> | string
    categoryId?: StringNullableFilter<"BlogPost"> | string | null
    currentVersion?: IntFilter<"BlogPost"> | number
    viewCount?: IntFilter<"BlogPost"> | number
    likeCount?: IntFilter<"BlogPost"> | number
    shareCount?: IntFilter<"BlogPost"> | number
    commentCount?: IntFilter<"BlogPost"> | number
    seoScore?: FloatNullableFilter<"BlogPost"> | number | null
    seoAnalysis?: JsonNullableFilter<"BlogPost">
    lastSeoCheck?: DateTimeNullableFilter<"BlogPost"> | Date | string | null
  }

  export type PostVersionUpsertWithWhereUniqueWithoutAuthorInput = {
    where: PostVersionWhereUniqueInput
    update: XOR<PostVersionUpdateWithoutAuthorInput, PostVersionUncheckedUpdateWithoutAuthorInput>
    create: XOR<PostVersionCreateWithoutAuthorInput, PostVersionUncheckedCreateWithoutAuthorInput>
  }

  export type PostVersionUpdateWithWhereUniqueWithoutAuthorInput = {
    where: PostVersionWhereUniqueInput
    data: XOR<PostVersionUpdateWithoutAuthorInput, PostVersionUncheckedUpdateWithoutAuthorInput>
  }

  export type PostVersionUpdateManyWithWhereWithoutAuthorInput = {
    where: PostVersionScalarWhereInput
    data: XOR<PostVersionUpdateManyMutationInput, PostVersionUncheckedUpdateManyWithoutAuthorInput>
  }

  export type CategoryCreateWithoutChildrenInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    color?: string | null
    icon?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: CategoryCreatekeywordsInput | string[]
    postCount?: number
    totalViews?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    posts?: BlogPostCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutChildrenInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    color?: string | null
    icon?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: CategoryCreatekeywordsInput | string[]
    parentId?: string | null
    postCount?: number
    totalViews?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: BlogPostUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutChildrenInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
  }

  export type CategoryCreateWithoutParentInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    color?: string | null
    icon?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: CategoryCreatekeywordsInput | string[]
    postCount?: number
    totalViews?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: CategoryCreateNestedManyWithoutParentInput
    posts?: BlogPostCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutParentInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    color?: string | null
    icon?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: CategoryCreatekeywordsInput | string[]
    postCount?: number
    totalViews?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    posts?: BlogPostUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutParentInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput>
  }

  export type CategoryCreateManyParentInputEnvelope = {
    data: CategoryCreateManyParentInput | CategoryCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type BlogPostCreateWithoutCategoryInput = {
    id?: string
    title: string
    slug: string
    excerpt?: string | null
    content: string
    contentType?: $Enums.ContentType
    status?: $Enums.PostStatus
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: BlogPostCreatekeywordsInput | string[]
    canonicalUrl?: string | null
    ogTitle?: string | null
    ogDescription?: string | null
    ogImage?: string | null
    twitterTitle?: string | null
    twitterDescription?: string | null
    twitterImage?: string | null
    featuredImage?: string | null
    featuredImageAlt?: string | null
    readingTime?: number | null
    wordCount?: number | null
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    archivedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currentVersion?: number
    viewCount?: number
    likeCount?: number
    shareCount?: number
    commentCount?: number
    seoScore?: number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: Date | string | null
    author: AuthorCreateNestedOneWithoutPostsInput
    tags?: PostTagCreateNestedManyWithoutPostInput
    seriesPosts?: SeriesPostCreateNestedManyWithoutPostInput
    relatedPosts?: PostRelationCreateNestedManyWithoutOriginalPostInput
    relatedToPosts?: PostRelationCreateNestedManyWithoutRelatedPostInput
    versions?: PostVersionCreateNestedManyWithoutPostInput
    views?: PostViewCreateNestedManyWithoutPostInput
    interactions?: PostInteractionCreateNestedManyWithoutPostInput
    seoEvents?: SEOEventCreateNestedManyWithoutPostInput
    seoKeywords?: SEOKeywordCreateNestedManyWithoutPostInput
    sitemapEntries?: SitemapEntryCreateNestedManyWithoutPostInput
  }

  export type BlogPostUncheckedCreateWithoutCategoryInput = {
    id?: string
    title: string
    slug: string
    excerpt?: string | null
    content: string
    contentType?: $Enums.ContentType
    status?: $Enums.PostStatus
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: BlogPostCreatekeywordsInput | string[]
    canonicalUrl?: string | null
    ogTitle?: string | null
    ogDescription?: string | null
    ogImage?: string | null
    twitterTitle?: string | null
    twitterDescription?: string | null
    twitterImage?: string | null
    featuredImage?: string | null
    featuredImageAlt?: string | null
    readingTime?: number | null
    wordCount?: number | null
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    archivedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
    currentVersion?: number
    viewCount?: number
    likeCount?: number
    shareCount?: number
    commentCount?: number
    seoScore?: number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: Date | string | null
    tags?: PostTagUncheckedCreateNestedManyWithoutPostInput
    seriesPosts?: SeriesPostUncheckedCreateNestedManyWithoutPostInput
    relatedPosts?: PostRelationUncheckedCreateNestedManyWithoutOriginalPostInput
    relatedToPosts?: PostRelationUncheckedCreateNestedManyWithoutRelatedPostInput
    versions?: PostVersionUncheckedCreateNestedManyWithoutPostInput
    views?: PostViewUncheckedCreateNestedManyWithoutPostInput
    interactions?: PostInteractionUncheckedCreateNestedManyWithoutPostInput
    seoEvents?: SEOEventUncheckedCreateNestedManyWithoutPostInput
    seoKeywords?: SEOKeywordUncheckedCreateNestedManyWithoutPostInput
    sitemapEntries?: SitemapEntryUncheckedCreateNestedManyWithoutPostInput
  }

  export type BlogPostCreateOrConnectWithoutCategoryInput = {
    where: BlogPostWhereUniqueInput
    create: XOR<BlogPostCreateWithoutCategoryInput, BlogPostUncheckedCreateWithoutCategoryInput>
  }

  export type BlogPostCreateManyCategoryInputEnvelope = {
    data: BlogPostCreateManyCategoryInput | BlogPostCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type CategoryUpsertWithoutChildrenInput = {
    update: XOR<CategoryUpdateWithoutChildrenInput, CategoryUncheckedUpdateWithoutChildrenInput>
    create: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutChildrenInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutChildrenInput, CategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type CategoryUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: CategoryUpdatekeywordsInput | string[]
    postCount?: IntFieldUpdateOperationsInput | number
    totalViews?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    posts?: BlogPostUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: CategoryUpdatekeywordsInput | string[]
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    totalViews?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: BlogPostUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUpsertWithWhereUniqueWithoutParentInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutParentInput, CategoryUncheckedUpdateWithoutParentInput>
    create: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutParentInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutParentInput, CategoryUncheckedUpdateWithoutParentInput>
  }

  export type CategoryUpdateManyWithWhereWithoutParentInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutParentInput>
  }

  export type CategoryScalarWhereInput = {
    AND?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    OR?: CategoryScalarWhereInput[]
    NOT?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    slug?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    color?: StringNullableFilter<"Category"> | string | null
    icon?: StringNullableFilter<"Category"> | string | null
    metaTitle?: StringNullableFilter<"Category"> | string | null
    metaDescription?: StringNullableFilter<"Category"> | string | null
    keywords?: StringNullableListFilter<"Category">
    parentId?: StringNullableFilter<"Category"> | string | null
    postCount?: IntFilter<"Category"> | number
    totalViews?: IntFilter<"Category"> | number
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
  }

  export type BlogPostUpsertWithWhereUniqueWithoutCategoryInput = {
    where: BlogPostWhereUniqueInput
    update: XOR<BlogPostUpdateWithoutCategoryInput, BlogPostUncheckedUpdateWithoutCategoryInput>
    create: XOR<BlogPostCreateWithoutCategoryInput, BlogPostUncheckedCreateWithoutCategoryInput>
  }

  export type BlogPostUpdateWithWhereUniqueWithoutCategoryInput = {
    where: BlogPostWhereUniqueInput
    data: XOR<BlogPostUpdateWithoutCategoryInput, BlogPostUncheckedUpdateWithoutCategoryInput>
  }

  export type BlogPostUpdateManyWithWhereWithoutCategoryInput = {
    where: BlogPostScalarWhereInput
    data: XOR<BlogPostUpdateManyMutationInput, BlogPostUncheckedUpdateManyWithoutCategoryInput>
  }

  export type PostTagCreateWithoutTagInput = {
    createdAt?: Date | string
    post: BlogPostCreateNestedOneWithoutTagsInput
  }

  export type PostTagUncheckedCreateWithoutTagInput = {
    postId: string
    createdAt?: Date | string
  }

  export type PostTagCreateOrConnectWithoutTagInput = {
    where: PostTagWhereUniqueInput
    create: XOR<PostTagCreateWithoutTagInput, PostTagUncheckedCreateWithoutTagInput>
  }

  export type PostTagCreateManyTagInputEnvelope = {
    data: PostTagCreateManyTagInput | PostTagCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type PostTagUpsertWithWhereUniqueWithoutTagInput = {
    where: PostTagWhereUniqueInput
    update: XOR<PostTagUpdateWithoutTagInput, PostTagUncheckedUpdateWithoutTagInput>
    create: XOR<PostTagCreateWithoutTagInput, PostTagUncheckedCreateWithoutTagInput>
  }

  export type PostTagUpdateWithWhereUniqueWithoutTagInput = {
    where: PostTagWhereUniqueInput
    data: XOR<PostTagUpdateWithoutTagInput, PostTagUncheckedUpdateWithoutTagInput>
  }

  export type PostTagUpdateManyWithWhereWithoutTagInput = {
    where: PostTagScalarWhereInput
    data: XOR<PostTagUpdateManyMutationInput, PostTagUncheckedUpdateManyWithoutTagInput>
  }

  export type BlogPostCreateWithoutTagsInput = {
    id?: string
    title: string
    slug: string
    excerpt?: string | null
    content: string
    contentType?: $Enums.ContentType
    status?: $Enums.PostStatus
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: BlogPostCreatekeywordsInput | string[]
    canonicalUrl?: string | null
    ogTitle?: string | null
    ogDescription?: string | null
    ogImage?: string | null
    twitterTitle?: string | null
    twitterDescription?: string | null
    twitterImage?: string | null
    featuredImage?: string | null
    featuredImageAlt?: string | null
    readingTime?: number | null
    wordCount?: number | null
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    archivedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currentVersion?: number
    viewCount?: number
    likeCount?: number
    shareCount?: number
    commentCount?: number
    seoScore?: number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: Date | string | null
    author: AuthorCreateNestedOneWithoutPostsInput
    category?: CategoryCreateNestedOneWithoutPostsInput
    seriesPosts?: SeriesPostCreateNestedManyWithoutPostInput
    relatedPosts?: PostRelationCreateNestedManyWithoutOriginalPostInput
    relatedToPosts?: PostRelationCreateNestedManyWithoutRelatedPostInput
    versions?: PostVersionCreateNestedManyWithoutPostInput
    views?: PostViewCreateNestedManyWithoutPostInput
    interactions?: PostInteractionCreateNestedManyWithoutPostInput
    seoEvents?: SEOEventCreateNestedManyWithoutPostInput
    seoKeywords?: SEOKeywordCreateNestedManyWithoutPostInput
    sitemapEntries?: SitemapEntryCreateNestedManyWithoutPostInput
  }

  export type BlogPostUncheckedCreateWithoutTagsInput = {
    id?: string
    title: string
    slug: string
    excerpt?: string | null
    content: string
    contentType?: $Enums.ContentType
    status?: $Enums.PostStatus
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: BlogPostCreatekeywordsInput | string[]
    canonicalUrl?: string | null
    ogTitle?: string | null
    ogDescription?: string | null
    ogImage?: string | null
    twitterTitle?: string | null
    twitterDescription?: string | null
    twitterImage?: string | null
    featuredImage?: string | null
    featuredImageAlt?: string | null
    readingTime?: number | null
    wordCount?: number | null
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    archivedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
    categoryId?: string | null
    currentVersion?: number
    viewCount?: number
    likeCount?: number
    shareCount?: number
    commentCount?: number
    seoScore?: number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: Date | string | null
    seriesPosts?: SeriesPostUncheckedCreateNestedManyWithoutPostInput
    relatedPosts?: PostRelationUncheckedCreateNestedManyWithoutOriginalPostInput
    relatedToPosts?: PostRelationUncheckedCreateNestedManyWithoutRelatedPostInput
    versions?: PostVersionUncheckedCreateNestedManyWithoutPostInput
    views?: PostViewUncheckedCreateNestedManyWithoutPostInput
    interactions?: PostInteractionUncheckedCreateNestedManyWithoutPostInput
    seoEvents?: SEOEventUncheckedCreateNestedManyWithoutPostInput
    seoKeywords?: SEOKeywordUncheckedCreateNestedManyWithoutPostInput
    sitemapEntries?: SitemapEntryUncheckedCreateNestedManyWithoutPostInput
  }

  export type BlogPostCreateOrConnectWithoutTagsInput = {
    where: BlogPostWhereUniqueInput
    create: XOR<BlogPostCreateWithoutTagsInput, BlogPostUncheckedCreateWithoutTagsInput>
  }

  export type TagCreateWithoutPostsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    color?: string | null
    metaDescription?: string | null
    postCount?: number
    totalViews?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagUncheckedCreateWithoutPostsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    color?: string | null
    metaDescription?: string | null
    postCount?: number
    totalViews?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagCreateOrConnectWithoutPostsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutPostsInput, TagUncheckedCreateWithoutPostsInput>
  }

  export type BlogPostUpsertWithoutTagsInput = {
    update: XOR<BlogPostUpdateWithoutTagsInput, BlogPostUncheckedUpdateWithoutTagsInput>
    create: XOR<BlogPostCreateWithoutTagsInput, BlogPostUncheckedCreateWithoutTagsInput>
    where?: BlogPostWhereInput
  }

  export type BlogPostUpdateToOneWithWhereWithoutTagsInput = {
    where?: BlogPostWhereInput
    data: XOR<BlogPostUpdateWithoutTagsInput, BlogPostUncheckedUpdateWithoutTagsInput>
  }

  export type BlogPostUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: BlogPostUpdatekeywordsInput | string[]
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    twitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentVersion?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    seoScore?: NullableFloatFieldUpdateOperationsInput | number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: AuthorUpdateOneRequiredWithoutPostsNestedInput
    category?: CategoryUpdateOneWithoutPostsNestedInput
    seriesPosts?: SeriesPostUpdateManyWithoutPostNestedInput
    relatedPosts?: PostRelationUpdateManyWithoutOriginalPostNestedInput
    relatedToPosts?: PostRelationUpdateManyWithoutRelatedPostNestedInput
    versions?: PostVersionUpdateManyWithoutPostNestedInput
    views?: PostViewUpdateManyWithoutPostNestedInput
    interactions?: PostInteractionUpdateManyWithoutPostNestedInput
    seoEvents?: SEOEventUpdateManyWithoutPostNestedInput
    seoKeywords?: SEOKeywordUpdateManyWithoutPostNestedInput
    sitemapEntries?: SitemapEntryUpdateManyWithoutPostNestedInput
  }

  export type BlogPostUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: BlogPostUpdatekeywordsInput | string[]
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    twitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    currentVersion?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    seoScore?: NullableFloatFieldUpdateOperationsInput | number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seriesPosts?: SeriesPostUncheckedUpdateManyWithoutPostNestedInput
    relatedPosts?: PostRelationUncheckedUpdateManyWithoutOriginalPostNestedInput
    relatedToPosts?: PostRelationUncheckedUpdateManyWithoutRelatedPostNestedInput
    versions?: PostVersionUncheckedUpdateManyWithoutPostNestedInput
    views?: PostViewUncheckedUpdateManyWithoutPostNestedInput
    interactions?: PostInteractionUncheckedUpdateManyWithoutPostNestedInput
    seoEvents?: SEOEventUncheckedUpdateManyWithoutPostNestedInput
    seoKeywords?: SEOKeywordUncheckedUpdateManyWithoutPostNestedInput
    sitemapEntries?: SitemapEntryUncheckedUpdateManyWithoutPostNestedInput
  }

  export type TagUpsertWithoutPostsInput = {
    update: XOR<TagUpdateWithoutPostsInput, TagUncheckedUpdateWithoutPostsInput>
    create: XOR<TagCreateWithoutPostsInput, TagUncheckedCreateWithoutPostsInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutPostsInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutPostsInput, TagUncheckedUpdateWithoutPostsInput>
  }

  export type TagUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    totalViews?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    totalViews?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostCreateWithoutRelatedPostsInput = {
    id?: string
    title: string
    slug: string
    excerpt?: string | null
    content: string
    contentType?: $Enums.ContentType
    status?: $Enums.PostStatus
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: BlogPostCreatekeywordsInput | string[]
    canonicalUrl?: string | null
    ogTitle?: string | null
    ogDescription?: string | null
    ogImage?: string | null
    twitterTitle?: string | null
    twitterDescription?: string | null
    twitterImage?: string | null
    featuredImage?: string | null
    featuredImageAlt?: string | null
    readingTime?: number | null
    wordCount?: number | null
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    archivedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currentVersion?: number
    viewCount?: number
    likeCount?: number
    shareCount?: number
    commentCount?: number
    seoScore?: number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: Date | string | null
    author: AuthorCreateNestedOneWithoutPostsInput
    category?: CategoryCreateNestedOneWithoutPostsInput
    tags?: PostTagCreateNestedManyWithoutPostInput
    seriesPosts?: SeriesPostCreateNestedManyWithoutPostInput
    relatedToPosts?: PostRelationCreateNestedManyWithoutRelatedPostInput
    versions?: PostVersionCreateNestedManyWithoutPostInput
    views?: PostViewCreateNestedManyWithoutPostInput
    interactions?: PostInteractionCreateNestedManyWithoutPostInput
    seoEvents?: SEOEventCreateNestedManyWithoutPostInput
    seoKeywords?: SEOKeywordCreateNestedManyWithoutPostInput
    sitemapEntries?: SitemapEntryCreateNestedManyWithoutPostInput
  }

  export type BlogPostUncheckedCreateWithoutRelatedPostsInput = {
    id?: string
    title: string
    slug: string
    excerpt?: string | null
    content: string
    contentType?: $Enums.ContentType
    status?: $Enums.PostStatus
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: BlogPostCreatekeywordsInput | string[]
    canonicalUrl?: string | null
    ogTitle?: string | null
    ogDescription?: string | null
    ogImage?: string | null
    twitterTitle?: string | null
    twitterDescription?: string | null
    twitterImage?: string | null
    featuredImage?: string | null
    featuredImageAlt?: string | null
    readingTime?: number | null
    wordCount?: number | null
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    archivedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
    categoryId?: string | null
    currentVersion?: number
    viewCount?: number
    likeCount?: number
    shareCount?: number
    commentCount?: number
    seoScore?: number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: Date | string | null
    tags?: PostTagUncheckedCreateNestedManyWithoutPostInput
    seriesPosts?: SeriesPostUncheckedCreateNestedManyWithoutPostInput
    relatedToPosts?: PostRelationUncheckedCreateNestedManyWithoutRelatedPostInput
    versions?: PostVersionUncheckedCreateNestedManyWithoutPostInput
    views?: PostViewUncheckedCreateNestedManyWithoutPostInput
    interactions?: PostInteractionUncheckedCreateNestedManyWithoutPostInput
    seoEvents?: SEOEventUncheckedCreateNestedManyWithoutPostInput
    seoKeywords?: SEOKeywordUncheckedCreateNestedManyWithoutPostInput
    sitemapEntries?: SitemapEntryUncheckedCreateNestedManyWithoutPostInput
  }

  export type BlogPostCreateOrConnectWithoutRelatedPostsInput = {
    where: BlogPostWhereUniqueInput
    create: XOR<BlogPostCreateWithoutRelatedPostsInput, BlogPostUncheckedCreateWithoutRelatedPostsInput>
  }

  export type BlogPostCreateWithoutRelatedToPostsInput = {
    id?: string
    title: string
    slug: string
    excerpt?: string | null
    content: string
    contentType?: $Enums.ContentType
    status?: $Enums.PostStatus
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: BlogPostCreatekeywordsInput | string[]
    canonicalUrl?: string | null
    ogTitle?: string | null
    ogDescription?: string | null
    ogImage?: string | null
    twitterTitle?: string | null
    twitterDescription?: string | null
    twitterImage?: string | null
    featuredImage?: string | null
    featuredImageAlt?: string | null
    readingTime?: number | null
    wordCount?: number | null
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    archivedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currentVersion?: number
    viewCount?: number
    likeCount?: number
    shareCount?: number
    commentCount?: number
    seoScore?: number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: Date | string | null
    author: AuthorCreateNestedOneWithoutPostsInput
    category?: CategoryCreateNestedOneWithoutPostsInput
    tags?: PostTagCreateNestedManyWithoutPostInput
    seriesPosts?: SeriesPostCreateNestedManyWithoutPostInput
    relatedPosts?: PostRelationCreateNestedManyWithoutOriginalPostInput
    versions?: PostVersionCreateNestedManyWithoutPostInput
    views?: PostViewCreateNestedManyWithoutPostInput
    interactions?: PostInteractionCreateNestedManyWithoutPostInput
    seoEvents?: SEOEventCreateNestedManyWithoutPostInput
    seoKeywords?: SEOKeywordCreateNestedManyWithoutPostInput
    sitemapEntries?: SitemapEntryCreateNestedManyWithoutPostInput
  }

  export type BlogPostUncheckedCreateWithoutRelatedToPostsInput = {
    id?: string
    title: string
    slug: string
    excerpt?: string | null
    content: string
    contentType?: $Enums.ContentType
    status?: $Enums.PostStatus
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: BlogPostCreatekeywordsInput | string[]
    canonicalUrl?: string | null
    ogTitle?: string | null
    ogDescription?: string | null
    ogImage?: string | null
    twitterTitle?: string | null
    twitterDescription?: string | null
    twitterImage?: string | null
    featuredImage?: string | null
    featuredImageAlt?: string | null
    readingTime?: number | null
    wordCount?: number | null
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    archivedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
    categoryId?: string | null
    currentVersion?: number
    viewCount?: number
    likeCount?: number
    shareCount?: number
    commentCount?: number
    seoScore?: number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: Date | string | null
    tags?: PostTagUncheckedCreateNestedManyWithoutPostInput
    seriesPosts?: SeriesPostUncheckedCreateNestedManyWithoutPostInput
    relatedPosts?: PostRelationUncheckedCreateNestedManyWithoutOriginalPostInput
    versions?: PostVersionUncheckedCreateNestedManyWithoutPostInput
    views?: PostViewUncheckedCreateNestedManyWithoutPostInput
    interactions?: PostInteractionUncheckedCreateNestedManyWithoutPostInput
    seoEvents?: SEOEventUncheckedCreateNestedManyWithoutPostInput
    seoKeywords?: SEOKeywordUncheckedCreateNestedManyWithoutPostInput
    sitemapEntries?: SitemapEntryUncheckedCreateNestedManyWithoutPostInput
  }

  export type BlogPostCreateOrConnectWithoutRelatedToPostsInput = {
    where: BlogPostWhereUniqueInput
    create: XOR<BlogPostCreateWithoutRelatedToPostsInput, BlogPostUncheckedCreateWithoutRelatedToPostsInput>
  }

  export type BlogPostUpsertWithoutRelatedPostsInput = {
    update: XOR<BlogPostUpdateWithoutRelatedPostsInput, BlogPostUncheckedUpdateWithoutRelatedPostsInput>
    create: XOR<BlogPostCreateWithoutRelatedPostsInput, BlogPostUncheckedCreateWithoutRelatedPostsInput>
    where?: BlogPostWhereInput
  }

  export type BlogPostUpdateToOneWithWhereWithoutRelatedPostsInput = {
    where?: BlogPostWhereInput
    data: XOR<BlogPostUpdateWithoutRelatedPostsInput, BlogPostUncheckedUpdateWithoutRelatedPostsInput>
  }

  export type BlogPostUpdateWithoutRelatedPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: BlogPostUpdatekeywordsInput | string[]
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    twitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentVersion?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    seoScore?: NullableFloatFieldUpdateOperationsInput | number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: AuthorUpdateOneRequiredWithoutPostsNestedInput
    category?: CategoryUpdateOneWithoutPostsNestedInput
    tags?: PostTagUpdateManyWithoutPostNestedInput
    seriesPosts?: SeriesPostUpdateManyWithoutPostNestedInput
    relatedToPosts?: PostRelationUpdateManyWithoutRelatedPostNestedInput
    versions?: PostVersionUpdateManyWithoutPostNestedInput
    views?: PostViewUpdateManyWithoutPostNestedInput
    interactions?: PostInteractionUpdateManyWithoutPostNestedInput
    seoEvents?: SEOEventUpdateManyWithoutPostNestedInput
    seoKeywords?: SEOKeywordUpdateManyWithoutPostNestedInput
    sitemapEntries?: SitemapEntryUpdateManyWithoutPostNestedInput
  }

  export type BlogPostUncheckedUpdateWithoutRelatedPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: BlogPostUpdatekeywordsInput | string[]
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    twitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    currentVersion?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    seoScore?: NullableFloatFieldUpdateOperationsInput | number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: PostTagUncheckedUpdateManyWithoutPostNestedInput
    seriesPosts?: SeriesPostUncheckedUpdateManyWithoutPostNestedInput
    relatedToPosts?: PostRelationUncheckedUpdateManyWithoutRelatedPostNestedInput
    versions?: PostVersionUncheckedUpdateManyWithoutPostNestedInput
    views?: PostViewUncheckedUpdateManyWithoutPostNestedInput
    interactions?: PostInteractionUncheckedUpdateManyWithoutPostNestedInput
    seoEvents?: SEOEventUncheckedUpdateManyWithoutPostNestedInput
    seoKeywords?: SEOKeywordUncheckedUpdateManyWithoutPostNestedInput
    sitemapEntries?: SitemapEntryUncheckedUpdateManyWithoutPostNestedInput
  }

  export type BlogPostUpsertWithoutRelatedToPostsInput = {
    update: XOR<BlogPostUpdateWithoutRelatedToPostsInput, BlogPostUncheckedUpdateWithoutRelatedToPostsInput>
    create: XOR<BlogPostCreateWithoutRelatedToPostsInput, BlogPostUncheckedCreateWithoutRelatedToPostsInput>
    where?: BlogPostWhereInput
  }

  export type BlogPostUpdateToOneWithWhereWithoutRelatedToPostsInput = {
    where?: BlogPostWhereInput
    data: XOR<BlogPostUpdateWithoutRelatedToPostsInput, BlogPostUncheckedUpdateWithoutRelatedToPostsInput>
  }

  export type BlogPostUpdateWithoutRelatedToPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: BlogPostUpdatekeywordsInput | string[]
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    twitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentVersion?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    seoScore?: NullableFloatFieldUpdateOperationsInput | number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: AuthorUpdateOneRequiredWithoutPostsNestedInput
    category?: CategoryUpdateOneWithoutPostsNestedInput
    tags?: PostTagUpdateManyWithoutPostNestedInput
    seriesPosts?: SeriesPostUpdateManyWithoutPostNestedInput
    relatedPosts?: PostRelationUpdateManyWithoutOriginalPostNestedInput
    versions?: PostVersionUpdateManyWithoutPostNestedInput
    views?: PostViewUpdateManyWithoutPostNestedInput
    interactions?: PostInteractionUpdateManyWithoutPostNestedInput
    seoEvents?: SEOEventUpdateManyWithoutPostNestedInput
    seoKeywords?: SEOKeywordUpdateManyWithoutPostNestedInput
    sitemapEntries?: SitemapEntryUpdateManyWithoutPostNestedInput
  }

  export type BlogPostUncheckedUpdateWithoutRelatedToPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: BlogPostUpdatekeywordsInput | string[]
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    twitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    currentVersion?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    seoScore?: NullableFloatFieldUpdateOperationsInput | number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: PostTagUncheckedUpdateManyWithoutPostNestedInput
    seriesPosts?: SeriesPostUncheckedUpdateManyWithoutPostNestedInput
    relatedPosts?: PostRelationUncheckedUpdateManyWithoutOriginalPostNestedInput
    versions?: PostVersionUncheckedUpdateManyWithoutPostNestedInput
    views?: PostViewUncheckedUpdateManyWithoutPostNestedInput
    interactions?: PostInteractionUncheckedUpdateManyWithoutPostNestedInput
    seoEvents?: SEOEventUncheckedUpdateManyWithoutPostNestedInput
    seoKeywords?: SEOKeywordUncheckedUpdateManyWithoutPostNestedInput
    sitemapEntries?: SitemapEntryUncheckedUpdateManyWithoutPostNestedInput
  }

  export type AuthorCreateWithoutPostVersionsInput = {
    id?: string
    name: string
    email: string
    slug: string
    bio?: string | null
    avatar?: string | null
    website?: string | null
    twitter?: string | null
    linkedin?: string | null
    github?: string | null
    metaDescription?: string | null
    totalViews?: number
    totalPosts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: BlogPostCreateNestedManyWithoutAuthorInput
  }

  export type AuthorUncheckedCreateWithoutPostVersionsInput = {
    id?: string
    name: string
    email: string
    slug: string
    bio?: string | null
    avatar?: string | null
    website?: string | null
    twitter?: string | null
    linkedin?: string | null
    github?: string | null
    metaDescription?: string | null
    totalViews?: number
    totalPosts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type AuthorCreateOrConnectWithoutPostVersionsInput = {
    where: AuthorWhereUniqueInput
    create: XOR<AuthorCreateWithoutPostVersionsInput, AuthorUncheckedCreateWithoutPostVersionsInput>
  }

  export type BlogPostCreateWithoutVersionsInput = {
    id?: string
    title: string
    slug: string
    excerpt?: string | null
    content: string
    contentType?: $Enums.ContentType
    status?: $Enums.PostStatus
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: BlogPostCreatekeywordsInput | string[]
    canonicalUrl?: string | null
    ogTitle?: string | null
    ogDescription?: string | null
    ogImage?: string | null
    twitterTitle?: string | null
    twitterDescription?: string | null
    twitterImage?: string | null
    featuredImage?: string | null
    featuredImageAlt?: string | null
    readingTime?: number | null
    wordCount?: number | null
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    archivedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currentVersion?: number
    viewCount?: number
    likeCount?: number
    shareCount?: number
    commentCount?: number
    seoScore?: number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: Date | string | null
    author: AuthorCreateNestedOneWithoutPostsInput
    category?: CategoryCreateNestedOneWithoutPostsInput
    tags?: PostTagCreateNestedManyWithoutPostInput
    seriesPosts?: SeriesPostCreateNestedManyWithoutPostInput
    relatedPosts?: PostRelationCreateNestedManyWithoutOriginalPostInput
    relatedToPosts?: PostRelationCreateNestedManyWithoutRelatedPostInput
    views?: PostViewCreateNestedManyWithoutPostInput
    interactions?: PostInteractionCreateNestedManyWithoutPostInput
    seoEvents?: SEOEventCreateNestedManyWithoutPostInput
    seoKeywords?: SEOKeywordCreateNestedManyWithoutPostInput
    sitemapEntries?: SitemapEntryCreateNestedManyWithoutPostInput
  }

  export type BlogPostUncheckedCreateWithoutVersionsInput = {
    id?: string
    title: string
    slug: string
    excerpt?: string | null
    content: string
    contentType?: $Enums.ContentType
    status?: $Enums.PostStatus
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: BlogPostCreatekeywordsInput | string[]
    canonicalUrl?: string | null
    ogTitle?: string | null
    ogDescription?: string | null
    ogImage?: string | null
    twitterTitle?: string | null
    twitterDescription?: string | null
    twitterImage?: string | null
    featuredImage?: string | null
    featuredImageAlt?: string | null
    readingTime?: number | null
    wordCount?: number | null
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    archivedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
    categoryId?: string | null
    currentVersion?: number
    viewCount?: number
    likeCount?: number
    shareCount?: number
    commentCount?: number
    seoScore?: number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: Date | string | null
    tags?: PostTagUncheckedCreateNestedManyWithoutPostInput
    seriesPosts?: SeriesPostUncheckedCreateNestedManyWithoutPostInput
    relatedPosts?: PostRelationUncheckedCreateNestedManyWithoutOriginalPostInput
    relatedToPosts?: PostRelationUncheckedCreateNestedManyWithoutRelatedPostInput
    views?: PostViewUncheckedCreateNestedManyWithoutPostInput
    interactions?: PostInteractionUncheckedCreateNestedManyWithoutPostInput
    seoEvents?: SEOEventUncheckedCreateNestedManyWithoutPostInput
    seoKeywords?: SEOKeywordUncheckedCreateNestedManyWithoutPostInput
    sitemapEntries?: SitemapEntryUncheckedCreateNestedManyWithoutPostInput
  }

  export type BlogPostCreateOrConnectWithoutVersionsInput = {
    where: BlogPostWhereUniqueInput
    create: XOR<BlogPostCreateWithoutVersionsInput, BlogPostUncheckedCreateWithoutVersionsInput>
  }

  export type AuthorUpsertWithoutPostVersionsInput = {
    update: XOR<AuthorUpdateWithoutPostVersionsInput, AuthorUncheckedUpdateWithoutPostVersionsInput>
    create: XOR<AuthorCreateWithoutPostVersionsInput, AuthorUncheckedCreateWithoutPostVersionsInput>
    where?: AuthorWhereInput
  }

  export type AuthorUpdateToOneWithWhereWithoutPostVersionsInput = {
    where?: AuthorWhereInput
    data: XOR<AuthorUpdateWithoutPostVersionsInput, AuthorUncheckedUpdateWithoutPostVersionsInput>
  }

  export type AuthorUpdateWithoutPostVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    totalViews?: IntFieldUpdateOperationsInput | number
    totalPosts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: BlogPostUpdateManyWithoutAuthorNestedInput
  }

  export type AuthorUncheckedUpdateWithoutPostVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    totalViews?: IntFieldUpdateOperationsInput | number
    totalPosts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type BlogPostUpsertWithoutVersionsInput = {
    update: XOR<BlogPostUpdateWithoutVersionsInput, BlogPostUncheckedUpdateWithoutVersionsInput>
    create: XOR<BlogPostCreateWithoutVersionsInput, BlogPostUncheckedCreateWithoutVersionsInput>
    where?: BlogPostWhereInput
  }

  export type BlogPostUpdateToOneWithWhereWithoutVersionsInput = {
    where?: BlogPostWhereInput
    data: XOR<BlogPostUpdateWithoutVersionsInput, BlogPostUncheckedUpdateWithoutVersionsInput>
  }

  export type BlogPostUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: BlogPostUpdatekeywordsInput | string[]
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    twitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentVersion?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    seoScore?: NullableFloatFieldUpdateOperationsInput | number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: AuthorUpdateOneRequiredWithoutPostsNestedInput
    category?: CategoryUpdateOneWithoutPostsNestedInput
    tags?: PostTagUpdateManyWithoutPostNestedInput
    seriesPosts?: SeriesPostUpdateManyWithoutPostNestedInput
    relatedPosts?: PostRelationUpdateManyWithoutOriginalPostNestedInput
    relatedToPosts?: PostRelationUpdateManyWithoutRelatedPostNestedInput
    views?: PostViewUpdateManyWithoutPostNestedInput
    interactions?: PostInteractionUpdateManyWithoutPostNestedInput
    seoEvents?: SEOEventUpdateManyWithoutPostNestedInput
    seoKeywords?: SEOKeywordUpdateManyWithoutPostNestedInput
    sitemapEntries?: SitemapEntryUpdateManyWithoutPostNestedInput
  }

  export type BlogPostUncheckedUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: BlogPostUpdatekeywordsInput | string[]
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    twitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    currentVersion?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    seoScore?: NullableFloatFieldUpdateOperationsInput | number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: PostTagUncheckedUpdateManyWithoutPostNestedInput
    seriesPosts?: SeriesPostUncheckedUpdateManyWithoutPostNestedInput
    relatedPosts?: PostRelationUncheckedUpdateManyWithoutOriginalPostNestedInput
    relatedToPosts?: PostRelationUncheckedUpdateManyWithoutRelatedPostNestedInput
    views?: PostViewUncheckedUpdateManyWithoutPostNestedInput
    interactions?: PostInteractionUncheckedUpdateManyWithoutPostNestedInput
    seoEvents?: SEOEventUncheckedUpdateManyWithoutPostNestedInput
    seoKeywords?: SEOKeywordUncheckedUpdateManyWithoutPostNestedInput
    sitemapEntries?: SitemapEntryUncheckedUpdateManyWithoutPostNestedInput
  }

  export type SeriesPostCreateWithoutSeriesInput = {
    order: number
    createdAt?: Date | string
    post: BlogPostCreateNestedOneWithoutSeriesPostsInput
  }

  export type SeriesPostUncheckedCreateWithoutSeriesInput = {
    postId: string
    order: number
    createdAt?: Date | string
  }

  export type SeriesPostCreateOrConnectWithoutSeriesInput = {
    where: SeriesPostWhereUniqueInput
    create: XOR<SeriesPostCreateWithoutSeriesInput, SeriesPostUncheckedCreateWithoutSeriesInput>
  }

  export type SeriesPostCreateManySeriesInputEnvelope = {
    data: SeriesPostCreateManySeriesInput | SeriesPostCreateManySeriesInput[]
    skipDuplicates?: boolean
  }

  export type SeriesPostUpsertWithWhereUniqueWithoutSeriesInput = {
    where: SeriesPostWhereUniqueInput
    update: XOR<SeriesPostUpdateWithoutSeriesInput, SeriesPostUncheckedUpdateWithoutSeriesInput>
    create: XOR<SeriesPostCreateWithoutSeriesInput, SeriesPostUncheckedCreateWithoutSeriesInput>
  }

  export type SeriesPostUpdateWithWhereUniqueWithoutSeriesInput = {
    where: SeriesPostWhereUniqueInput
    data: XOR<SeriesPostUpdateWithoutSeriesInput, SeriesPostUncheckedUpdateWithoutSeriesInput>
  }

  export type SeriesPostUpdateManyWithWhereWithoutSeriesInput = {
    where: SeriesPostScalarWhereInput
    data: XOR<SeriesPostUpdateManyMutationInput, SeriesPostUncheckedUpdateManyWithoutSeriesInput>
  }

  export type PostSeriesCreateWithoutPostsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    coverImage?: string | null
    color?: string | null
    totalPosts?: number
    totalViews?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostSeriesUncheckedCreateWithoutPostsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    coverImage?: string | null
    color?: string | null
    totalPosts?: number
    totalViews?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostSeriesCreateOrConnectWithoutPostsInput = {
    where: PostSeriesWhereUniqueInput
    create: XOR<PostSeriesCreateWithoutPostsInput, PostSeriesUncheckedCreateWithoutPostsInput>
  }

  export type BlogPostCreateWithoutSeriesPostsInput = {
    id?: string
    title: string
    slug: string
    excerpt?: string | null
    content: string
    contentType?: $Enums.ContentType
    status?: $Enums.PostStatus
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: BlogPostCreatekeywordsInput | string[]
    canonicalUrl?: string | null
    ogTitle?: string | null
    ogDescription?: string | null
    ogImage?: string | null
    twitterTitle?: string | null
    twitterDescription?: string | null
    twitterImage?: string | null
    featuredImage?: string | null
    featuredImageAlt?: string | null
    readingTime?: number | null
    wordCount?: number | null
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    archivedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currentVersion?: number
    viewCount?: number
    likeCount?: number
    shareCount?: number
    commentCount?: number
    seoScore?: number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: Date | string | null
    author: AuthorCreateNestedOneWithoutPostsInput
    category?: CategoryCreateNestedOneWithoutPostsInput
    tags?: PostTagCreateNestedManyWithoutPostInput
    relatedPosts?: PostRelationCreateNestedManyWithoutOriginalPostInput
    relatedToPosts?: PostRelationCreateNestedManyWithoutRelatedPostInput
    versions?: PostVersionCreateNestedManyWithoutPostInput
    views?: PostViewCreateNestedManyWithoutPostInput
    interactions?: PostInteractionCreateNestedManyWithoutPostInput
    seoEvents?: SEOEventCreateNestedManyWithoutPostInput
    seoKeywords?: SEOKeywordCreateNestedManyWithoutPostInput
    sitemapEntries?: SitemapEntryCreateNestedManyWithoutPostInput
  }

  export type BlogPostUncheckedCreateWithoutSeriesPostsInput = {
    id?: string
    title: string
    slug: string
    excerpt?: string | null
    content: string
    contentType?: $Enums.ContentType
    status?: $Enums.PostStatus
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: BlogPostCreatekeywordsInput | string[]
    canonicalUrl?: string | null
    ogTitle?: string | null
    ogDescription?: string | null
    ogImage?: string | null
    twitterTitle?: string | null
    twitterDescription?: string | null
    twitterImage?: string | null
    featuredImage?: string | null
    featuredImageAlt?: string | null
    readingTime?: number | null
    wordCount?: number | null
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    archivedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
    categoryId?: string | null
    currentVersion?: number
    viewCount?: number
    likeCount?: number
    shareCount?: number
    commentCount?: number
    seoScore?: number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: Date | string | null
    tags?: PostTagUncheckedCreateNestedManyWithoutPostInput
    relatedPosts?: PostRelationUncheckedCreateNestedManyWithoutOriginalPostInput
    relatedToPosts?: PostRelationUncheckedCreateNestedManyWithoutRelatedPostInput
    versions?: PostVersionUncheckedCreateNestedManyWithoutPostInput
    views?: PostViewUncheckedCreateNestedManyWithoutPostInput
    interactions?: PostInteractionUncheckedCreateNestedManyWithoutPostInput
    seoEvents?: SEOEventUncheckedCreateNestedManyWithoutPostInput
    seoKeywords?: SEOKeywordUncheckedCreateNestedManyWithoutPostInput
    sitemapEntries?: SitemapEntryUncheckedCreateNestedManyWithoutPostInput
  }

  export type BlogPostCreateOrConnectWithoutSeriesPostsInput = {
    where: BlogPostWhereUniqueInput
    create: XOR<BlogPostCreateWithoutSeriesPostsInput, BlogPostUncheckedCreateWithoutSeriesPostsInput>
  }

  export type PostSeriesUpsertWithoutPostsInput = {
    update: XOR<PostSeriesUpdateWithoutPostsInput, PostSeriesUncheckedUpdateWithoutPostsInput>
    create: XOR<PostSeriesCreateWithoutPostsInput, PostSeriesUncheckedCreateWithoutPostsInput>
    where?: PostSeriesWhereInput
  }

  export type PostSeriesUpdateToOneWithWhereWithoutPostsInput = {
    where?: PostSeriesWhereInput
    data: XOR<PostSeriesUpdateWithoutPostsInput, PostSeriesUncheckedUpdateWithoutPostsInput>
  }

  export type PostSeriesUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    totalPosts?: IntFieldUpdateOperationsInput | number
    totalViews?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostSeriesUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    totalPosts?: IntFieldUpdateOperationsInput | number
    totalViews?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostUpsertWithoutSeriesPostsInput = {
    update: XOR<BlogPostUpdateWithoutSeriesPostsInput, BlogPostUncheckedUpdateWithoutSeriesPostsInput>
    create: XOR<BlogPostCreateWithoutSeriesPostsInput, BlogPostUncheckedCreateWithoutSeriesPostsInput>
    where?: BlogPostWhereInput
  }

  export type BlogPostUpdateToOneWithWhereWithoutSeriesPostsInput = {
    where?: BlogPostWhereInput
    data: XOR<BlogPostUpdateWithoutSeriesPostsInput, BlogPostUncheckedUpdateWithoutSeriesPostsInput>
  }

  export type BlogPostUpdateWithoutSeriesPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: BlogPostUpdatekeywordsInput | string[]
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    twitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentVersion?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    seoScore?: NullableFloatFieldUpdateOperationsInput | number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: AuthorUpdateOneRequiredWithoutPostsNestedInput
    category?: CategoryUpdateOneWithoutPostsNestedInput
    tags?: PostTagUpdateManyWithoutPostNestedInput
    relatedPosts?: PostRelationUpdateManyWithoutOriginalPostNestedInput
    relatedToPosts?: PostRelationUpdateManyWithoutRelatedPostNestedInput
    versions?: PostVersionUpdateManyWithoutPostNestedInput
    views?: PostViewUpdateManyWithoutPostNestedInput
    interactions?: PostInteractionUpdateManyWithoutPostNestedInput
    seoEvents?: SEOEventUpdateManyWithoutPostNestedInput
    seoKeywords?: SEOKeywordUpdateManyWithoutPostNestedInput
    sitemapEntries?: SitemapEntryUpdateManyWithoutPostNestedInput
  }

  export type BlogPostUncheckedUpdateWithoutSeriesPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: BlogPostUpdatekeywordsInput | string[]
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    twitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    currentVersion?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    seoScore?: NullableFloatFieldUpdateOperationsInput | number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: PostTagUncheckedUpdateManyWithoutPostNestedInput
    relatedPosts?: PostRelationUncheckedUpdateManyWithoutOriginalPostNestedInput
    relatedToPosts?: PostRelationUncheckedUpdateManyWithoutRelatedPostNestedInput
    versions?: PostVersionUncheckedUpdateManyWithoutPostNestedInput
    views?: PostViewUncheckedUpdateManyWithoutPostNestedInput
    interactions?: PostInteractionUncheckedUpdateManyWithoutPostNestedInput
    seoEvents?: SEOEventUncheckedUpdateManyWithoutPostNestedInput
    seoKeywords?: SEOKeywordUncheckedUpdateManyWithoutPostNestedInput
    sitemapEntries?: SitemapEntryUncheckedUpdateManyWithoutPostNestedInput
  }

  export type BlogPostCreateWithoutViewsInput = {
    id?: string
    title: string
    slug: string
    excerpt?: string | null
    content: string
    contentType?: $Enums.ContentType
    status?: $Enums.PostStatus
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: BlogPostCreatekeywordsInput | string[]
    canonicalUrl?: string | null
    ogTitle?: string | null
    ogDescription?: string | null
    ogImage?: string | null
    twitterTitle?: string | null
    twitterDescription?: string | null
    twitterImage?: string | null
    featuredImage?: string | null
    featuredImageAlt?: string | null
    readingTime?: number | null
    wordCount?: number | null
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    archivedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currentVersion?: number
    viewCount?: number
    likeCount?: number
    shareCount?: number
    commentCount?: number
    seoScore?: number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: Date | string | null
    author: AuthorCreateNestedOneWithoutPostsInput
    category?: CategoryCreateNestedOneWithoutPostsInput
    tags?: PostTagCreateNestedManyWithoutPostInput
    seriesPosts?: SeriesPostCreateNestedManyWithoutPostInput
    relatedPosts?: PostRelationCreateNestedManyWithoutOriginalPostInput
    relatedToPosts?: PostRelationCreateNestedManyWithoutRelatedPostInput
    versions?: PostVersionCreateNestedManyWithoutPostInput
    interactions?: PostInteractionCreateNestedManyWithoutPostInput
    seoEvents?: SEOEventCreateNestedManyWithoutPostInput
    seoKeywords?: SEOKeywordCreateNestedManyWithoutPostInput
    sitemapEntries?: SitemapEntryCreateNestedManyWithoutPostInput
  }

  export type BlogPostUncheckedCreateWithoutViewsInput = {
    id?: string
    title: string
    slug: string
    excerpt?: string | null
    content: string
    contentType?: $Enums.ContentType
    status?: $Enums.PostStatus
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: BlogPostCreatekeywordsInput | string[]
    canonicalUrl?: string | null
    ogTitle?: string | null
    ogDescription?: string | null
    ogImage?: string | null
    twitterTitle?: string | null
    twitterDescription?: string | null
    twitterImage?: string | null
    featuredImage?: string | null
    featuredImageAlt?: string | null
    readingTime?: number | null
    wordCount?: number | null
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    archivedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
    categoryId?: string | null
    currentVersion?: number
    viewCount?: number
    likeCount?: number
    shareCount?: number
    commentCount?: number
    seoScore?: number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: Date | string | null
    tags?: PostTagUncheckedCreateNestedManyWithoutPostInput
    seriesPosts?: SeriesPostUncheckedCreateNestedManyWithoutPostInput
    relatedPosts?: PostRelationUncheckedCreateNestedManyWithoutOriginalPostInput
    relatedToPosts?: PostRelationUncheckedCreateNestedManyWithoutRelatedPostInput
    versions?: PostVersionUncheckedCreateNestedManyWithoutPostInput
    interactions?: PostInteractionUncheckedCreateNestedManyWithoutPostInput
    seoEvents?: SEOEventUncheckedCreateNestedManyWithoutPostInput
    seoKeywords?: SEOKeywordUncheckedCreateNestedManyWithoutPostInput
    sitemapEntries?: SitemapEntryUncheckedCreateNestedManyWithoutPostInput
  }

  export type BlogPostCreateOrConnectWithoutViewsInput = {
    where: BlogPostWhereUniqueInput
    create: XOR<BlogPostCreateWithoutViewsInput, BlogPostUncheckedCreateWithoutViewsInput>
  }

  export type BlogPostUpsertWithoutViewsInput = {
    update: XOR<BlogPostUpdateWithoutViewsInput, BlogPostUncheckedUpdateWithoutViewsInput>
    create: XOR<BlogPostCreateWithoutViewsInput, BlogPostUncheckedCreateWithoutViewsInput>
    where?: BlogPostWhereInput
  }

  export type BlogPostUpdateToOneWithWhereWithoutViewsInput = {
    where?: BlogPostWhereInput
    data: XOR<BlogPostUpdateWithoutViewsInput, BlogPostUncheckedUpdateWithoutViewsInput>
  }

  export type BlogPostUpdateWithoutViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: BlogPostUpdatekeywordsInput | string[]
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    twitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentVersion?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    seoScore?: NullableFloatFieldUpdateOperationsInput | number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: AuthorUpdateOneRequiredWithoutPostsNestedInput
    category?: CategoryUpdateOneWithoutPostsNestedInput
    tags?: PostTagUpdateManyWithoutPostNestedInput
    seriesPosts?: SeriesPostUpdateManyWithoutPostNestedInput
    relatedPosts?: PostRelationUpdateManyWithoutOriginalPostNestedInput
    relatedToPosts?: PostRelationUpdateManyWithoutRelatedPostNestedInput
    versions?: PostVersionUpdateManyWithoutPostNestedInput
    interactions?: PostInteractionUpdateManyWithoutPostNestedInput
    seoEvents?: SEOEventUpdateManyWithoutPostNestedInput
    seoKeywords?: SEOKeywordUpdateManyWithoutPostNestedInput
    sitemapEntries?: SitemapEntryUpdateManyWithoutPostNestedInput
  }

  export type BlogPostUncheckedUpdateWithoutViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: BlogPostUpdatekeywordsInput | string[]
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    twitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    currentVersion?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    seoScore?: NullableFloatFieldUpdateOperationsInput | number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: PostTagUncheckedUpdateManyWithoutPostNestedInput
    seriesPosts?: SeriesPostUncheckedUpdateManyWithoutPostNestedInput
    relatedPosts?: PostRelationUncheckedUpdateManyWithoutOriginalPostNestedInput
    relatedToPosts?: PostRelationUncheckedUpdateManyWithoutRelatedPostNestedInput
    versions?: PostVersionUncheckedUpdateManyWithoutPostNestedInput
    interactions?: PostInteractionUncheckedUpdateManyWithoutPostNestedInput
    seoEvents?: SEOEventUncheckedUpdateManyWithoutPostNestedInput
    seoKeywords?: SEOKeywordUncheckedUpdateManyWithoutPostNestedInput
    sitemapEntries?: SitemapEntryUncheckedUpdateManyWithoutPostNestedInput
  }

  export type BlogPostCreateWithoutInteractionsInput = {
    id?: string
    title: string
    slug: string
    excerpt?: string | null
    content: string
    contentType?: $Enums.ContentType
    status?: $Enums.PostStatus
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: BlogPostCreatekeywordsInput | string[]
    canonicalUrl?: string | null
    ogTitle?: string | null
    ogDescription?: string | null
    ogImage?: string | null
    twitterTitle?: string | null
    twitterDescription?: string | null
    twitterImage?: string | null
    featuredImage?: string | null
    featuredImageAlt?: string | null
    readingTime?: number | null
    wordCount?: number | null
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    archivedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currentVersion?: number
    viewCount?: number
    likeCount?: number
    shareCount?: number
    commentCount?: number
    seoScore?: number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: Date | string | null
    author: AuthorCreateNestedOneWithoutPostsInput
    category?: CategoryCreateNestedOneWithoutPostsInput
    tags?: PostTagCreateNestedManyWithoutPostInput
    seriesPosts?: SeriesPostCreateNestedManyWithoutPostInput
    relatedPosts?: PostRelationCreateNestedManyWithoutOriginalPostInput
    relatedToPosts?: PostRelationCreateNestedManyWithoutRelatedPostInput
    versions?: PostVersionCreateNestedManyWithoutPostInput
    views?: PostViewCreateNestedManyWithoutPostInput
    seoEvents?: SEOEventCreateNestedManyWithoutPostInput
    seoKeywords?: SEOKeywordCreateNestedManyWithoutPostInput
    sitemapEntries?: SitemapEntryCreateNestedManyWithoutPostInput
  }

  export type BlogPostUncheckedCreateWithoutInteractionsInput = {
    id?: string
    title: string
    slug: string
    excerpt?: string | null
    content: string
    contentType?: $Enums.ContentType
    status?: $Enums.PostStatus
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: BlogPostCreatekeywordsInput | string[]
    canonicalUrl?: string | null
    ogTitle?: string | null
    ogDescription?: string | null
    ogImage?: string | null
    twitterTitle?: string | null
    twitterDescription?: string | null
    twitterImage?: string | null
    featuredImage?: string | null
    featuredImageAlt?: string | null
    readingTime?: number | null
    wordCount?: number | null
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    archivedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
    categoryId?: string | null
    currentVersion?: number
    viewCount?: number
    likeCount?: number
    shareCount?: number
    commentCount?: number
    seoScore?: number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: Date | string | null
    tags?: PostTagUncheckedCreateNestedManyWithoutPostInput
    seriesPosts?: SeriesPostUncheckedCreateNestedManyWithoutPostInput
    relatedPosts?: PostRelationUncheckedCreateNestedManyWithoutOriginalPostInput
    relatedToPosts?: PostRelationUncheckedCreateNestedManyWithoutRelatedPostInput
    versions?: PostVersionUncheckedCreateNestedManyWithoutPostInput
    views?: PostViewUncheckedCreateNestedManyWithoutPostInput
    seoEvents?: SEOEventUncheckedCreateNestedManyWithoutPostInput
    seoKeywords?: SEOKeywordUncheckedCreateNestedManyWithoutPostInput
    sitemapEntries?: SitemapEntryUncheckedCreateNestedManyWithoutPostInput
  }

  export type BlogPostCreateOrConnectWithoutInteractionsInput = {
    where: BlogPostWhereUniqueInput
    create: XOR<BlogPostCreateWithoutInteractionsInput, BlogPostUncheckedCreateWithoutInteractionsInput>
  }

  export type BlogPostUpsertWithoutInteractionsInput = {
    update: XOR<BlogPostUpdateWithoutInteractionsInput, BlogPostUncheckedUpdateWithoutInteractionsInput>
    create: XOR<BlogPostCreateWithoutInteractionsInput, BlogPostUncheckedCreateWithoutInteractionsInput>
    where?: BlogPostWhereInput
  }

  export type BlogPostUpdateToOneWithWhereWithoutInteractionsInput = {
    where?: BlogPostWhereInput
    data: XOR<BlogPostUpdateWithoutInteractionsInput, BlogPostUncheckedUpdateWithoutInteractionsInput>
  }

  export type BlogPostUpdateWithoutInteractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: BlogPostUpdatekeywordsInput | string[]
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    twitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentVersion?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    seoScore?: NullableFloatFieldUpdateOperationsInput | number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: AuthorUpdateOneRequiredWithoutPostsNestedInput
    category?: CategoryUpdateOneWithoutPostsNestedInput
    tags?: PostTagUpdateManyWithoutPostNestedInput
    seriesPosts?: SeriesPostUpdateManyWithoutPostNestedInput
    relatedPosts?: PostRelationUpdateManyWithoutOriginalPostNestedInput
    relatedToPosts?: PostRelationUpdateManyWithoutRelatedPostNestedInput
    versions?: PostVersionUpdateManyWithoutPostNestedInput
    views?: PostViewUpdateManyWithoutPostNestedInput
    seoEvents?: SEOEventUpdateManyWithoutPostNestedInput
    seoKeywords?: SEOKeywordUpdateManyWithoutPostNestedInput
    sitemapEntries?: SitemapEntryUpdateManyWithoutPostNestedInput
  }

  export type BlogPostUncheckedUpdateWithoutInteractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: BlogPostUpdatekeywordsInput | string[]
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    twitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    currentVersion?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    seoScore?: NullableFloatFieldUpdateOperationsInput | number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: PostTagUncheckedUpdateManyWithoutPostNestedInput
    seriesPosts?: SeriesPostUncheckedUpdateManyWithoutPostNestedInput
    relatedPosts?: PostRelationUncheckedUpdateManyWithoutOriginalPostNestedInput
    relatedToPosts?: PostRelationUncheckedUpdateManyWithoutRelatedPostNestedInput
    versions?: PostVersionUncheckedUpdateManyWithoutPostNestedInput
    views?: PostViewUncheckedUpdateManyWithoutPostNestedInput
    seoEvents?: SEOEventUncheckedUpdateManyWithoutPostNestedInput
    seoKeywords?: SEOKeywordUncheckedUpdateManyWithoutPostNestedInput
    sitemapEntries?: SitemapEntryUncheckedUpdateManyWithoutPostNestedInput
  }

  export type BlogPostCreateWithoutSeoEventsInput = {
    id?: string
    title: string
    slug: string
    excerpt?: string | null
    content: string
    contentType?: $Enums.ContentType
    status?: $Enums.PostStatus
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: BlogPostCreatekeywordsInput | string[]
    canonicalUrl?: string | null
    ogTitle?: string | null
    ogDescription?: string | null
    ogImage?: string | null
    twitterTitle?: string | null
    twitterDescription?: string | null
    twitterImage?: string | null
    featuredImage?: string | null
    featuredImageAlt?: string | null
    readingTime?: number | null
    wordCount?: number | null
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    archivedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currentVersion?: number
    viewCount?: number
    likeCount?: number
    shareCount?: number
    commentCount?: number
    seoScore?: number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: Date | string | null
    author: AuthorCreateNestedOneWithoutPostsInput
    category?: CategoryCreateNestedOneWithoutPostsInput
    tags?: PostTagCreateNestedManyWithoutPostInput
    seriesPosts?: SeriesPostCreateNestedManyWithoutPostInput
    relatedPosts?: PostRelationCreateNestedManyWithoutOriginalPostInput
    relatedToPosts?: PostRelationCreateNestedManyWithoutRelatedPostInput
    versions?: PostVersionCreateNestedManyWithoutPostInput
    views?: PostViewCreateNestedManyWithoutPostInput
    interactions?: PostInteractionCreateNestedManyWithoutPostInput
    seoKeywords?: SEOKeywordCreateNestedManyWithoutPostInput
    sitemapEntries?: SitemapEntryCreateNestedManyWithoutPostInput
  }

  export type BlogPostUncheckedCreateWithoutSeoEventsInput = {
    id?: string
    title: string
    slug: string
    excerpt?: string | null
    content: string
    contentType?: $Enums.ContentType
    status?: $Enums.PostStatus
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: BlogPostCreatekeywordsInput | string[]
    canonicalUrl?: string | null
    ogTitle?: string | null
    ogDescription?: string | null
    ogImage?: string | null
    twitterTitle?: string | null
    twitterDescription?: string | null
    twitterImage?: string | null
    featuredImage?: string | null
    featuredImageAlt?: string | null
    readingTime?: number | null
    wordCount?: number | null
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    archivedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
    categoryId?: string | null
    currentVersion?: number
    viewCount?: number
    likeCount?: number
    shareCount?: number
    commentCount?: number
    seoScore?: number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: Date | string | null
    tags?: PostTagUncheckedCreateNestedManyWithoutPostInput
    seriesPosts?: SeriesPostUncheckedCreateNestedManyWithoutPostInput
    relatedPosts?: PostRelationUncheckedCreateNestedManyWithoutOriginalPostInput
    relatedToPosts?: PostRelationUncheckedCreateNestedManyWithoutRelatedPostInput
    versions?: PostVersionUncheckedCreateNestedManyWithoutPostInput
    views?: PostViewUncheckedCreateNestedManyWithoutPostInput
    interactions?: PostInteractionUncheckedCreateNestedManyWithoutPostInput
    seoKeywords?: SEOKeywordUncheckedCreateNestedManyWithoutPostInput
    sitemapEntries?: SitemapEntryUncheckedCreateNestedManyWithoutPostInput
  }

  export type BlogPostCreateOrConnectWithoutSeoEventsInput = {
    where: BlogPostWhereUniqueInput
    create: XOR<BlogPostCreateWithoutSeoEventsInput, BlogPostUncheckedCreateWithoutSeoEventsInput>
  }

  export type BlogPostUpsertWithoutSeoEventsInput = {
    update: XOR<BlogPostUpdateWithoutSeoEventsInput, BlogPostUncheckedUpdateWithoutSeoEventsInput>
    create: XOR<BlogPostCreateWithoutSeoEventsInput, BlogPostUncheckedCreateWithoutSeoEventsInput>
    where?: BlogPostWhereInput
  }

  export type BlogPostUpdateToOneWithWhereWithoutSeoEventsInput = {
    where?: BlogPostWhereInput
    data: XOR<BlogPostUpdateWithoutSeoEventsInput, BlogPostUncheckedUpdateWithoutSeoEventsInput>
  }

  export type BlogPostUpdateWithoutSeoEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: BlogPostUpdatekeywordsInput | string[]
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    twitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentVersion?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    seoScore?: NullableFloatFieldUpdateOperationsInput | number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: AuthorUpdateOneRequiredWithoutPostsNestedInput
    category?: CategoryUpdateOneWithoutPostsNestedInput
    tags?: PostTagUpdateManyWithoutPostNestedInput
    seriesPosts?: SeriesPostUpdateManyWithoutPostNestedInput
    relatedPosts?: PostRelationUpdateManyWithoutOriginalPostNestedInput
    relatedToPosts?: PostRelationUpdateManyWithoutRelatedPostNestedInput
    versions?: PostVersionUpdateManyWithoutPostNestedInput
    views?: PostViewUpdateManyWithoutPostNestedInput
    interactions?: PostInteractionUpdateManyWithoutPostNestedInput
    seoKeywords?: SEOKeywordUpdateManyWithoutPostNestedInput
    sitemapEntries?: SitemapEntryUpdateManyWithoutPostNestedInput
  }

  export type BlogPostUncheckedUpdateWithoutSeoEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: BlogPostUpdatekeywordsInput | string[]
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    twitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    currentVersion?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    seoScore?: NullableFloatFieldUpdateOperationsInput | number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: PostTagUncheckedUpdateManyWithoutPostNestedInput
    seriesPosts?: SeriesPostUncheckedUpdateManyWithoutPostNestedInput
    relatedPosts?: PostRelationUncheckedUpdateManyWithoutOriginalPostNestedInput
    relatedToPosts?: PostRelationUncheckedUpdateManyWithoutRelatedPostNestedInput
    versions?: PostVersionUncheckedUpdateManyWithoutPostNestedInput
    views?: PostViewUncheckedUpdateManyWithoutPostNestedInput
    interactions?: PostInteractionUncheckedUpdateManyWithoutPostNestedInput
    seoKeywords?: SEOKeywordUncheckedUpdateManyWithoutPostNestedInput
    sitemapEntries?: SitemapEntryUncheckedUpdateManyWithoutPostNestedInput
  }

  export type BlogPostCreateWithoutSeoKeywordsInput = {
    id?: string
    title: string
    slug: string
    excerpt?: string | null
    content: string
    contentType?: $Enums.ContentType
    status?: $Enums.PostStatus
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: BlogPostCreatekeywordsInput | string[]
    canonicalUrl?: string | null
    ogTitle?: string | null
    ogDescription?: string | null
    ogImage?: string | null
    twitterTitle?: string | null
    twitterDescription?: string | null
    twitterImage?: string | null
    featuredImage?: string | null
    featuredImageAlt?: string | null
    readingTime?: number | null
    wordCount?: number | null
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    archivedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currentVersion?: number
    viewCount?: number
    likeCount?: number
    shareCount?: number
    commentCount?: number
    seoScore?: number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: Date | string | null
    author: AuthorCreateNestedOneWithoutPostsInput
    category?: CategoryCreateNestedOneWithoutPostsInput
    tags?: PostTagCreateNestedManyWithoutPostInput
    seriesPosts?: SeriesPostCreateNestedManyWithoutPostInput
    relatedPosts?: PostRelationCreateNestedManyWithoutOriginalPostInput
    relatedToPosts?: PostRelationCreateNestedManyWithoutRelatedPostInput
    versions?: PostVersionCreateNestedManyWithoutPostInput
    views?: PostViewCreateNestedManyWithoutPostInput
    interactions?: PostInteractionCreateNestedManyWithoutPostInput
    seoEvents?: SEOEventCreateNestedManyWithoutPostInput
    sitemapEntries?: SitemapEntryCreateNestedManyWithoutPostInput
  }

  export type BlogPostUncheckedCreateWithoutSeoKeywordsInput = {
    id?: string
    title: string
    slug: string
    excerpt?: string | null
    content: string
    contentType?: $Enums.ContentType
    status?: $Enums.PostStatus
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: BlogPostCreatekeywordsInput | string[]
    canonicalUrl?: string | null
    ogTitle?: string | null
    ogDescription?: string | null
    ogImage?: string | null
    twitterTitle?: string | null
    twitterDescription?: string | null
    twitterImage?: string | null
    featuredImage?: string | null
    featuredImageAlt?: string | null
    readingTime?: number | null
    wordCount?: number | null
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    archivedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
    categoryId?: string | null
    currentVersion?: number
    viewCount?: number
    likeCount?: number
    shareCount?: number
    commentCount?: number
    seoScore?: number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: Date | string | null
    tags?: PostTagUncheckedCreateNestedManyWithoutPostInput
    seriesPosts?: SeriesPostUncheckedCreateNestedManyWithoutPostInput
    relatedPosts?: PostRelationUncheckedCreateNestedManyWithoutOriginalPostInput
    relatedToPosts?: PostRelationUncheckedCreateNestedManyWithoutRelatedPostInput
    versions?: PostVersionUncheckedCreateNestedManyWithoutPostInput
    views?: PostViewUncheckedCreateNestedManyWithoutPostInput
    interactions?: PostInteractionUncheckedCreateNestedManyWithoutPostInput
    seoEvents?: SEOEventUncheckedCreateNestedManyWithoutPostInput
    sitemapEntries?: SitemapEntryUncheckedCreateNestedManyWithoutPostInput
  }

  export type BlogPostCreateOrConnectWithoutSeoKeywordsInput = {
    where: BlogPostWhereUniqueInput
    create: XOR<BlogPostCreateWithoutSeoKeywordsInput, BlogPostUncheckedCreateWithoutSeoKeywordsInput>
  }

  export type BlogPostUpsertWithoutSeoKeywordsInput = {
    update: XOR<BlogPostUpdateWithoutSeoKeywordsInput, BlogPostUncheckedUpdateWithoutSeoKeywordsInput>
    create: XOR<BlogPostCreateWithoutSeoKeywordsInput, BlogPostUncheckedCreateWithoutSeoKeywordsInput>
    where?: BlogPostWhereInput
  }

  export type BlogPostUpdateToOneWithWhereWithoutSeoKeywordsInput = {
    where?: BlogPostWhereInput
    data: XOR<BlogPostUpdateWithoutSeoKeywordsInput, BlogPostUncheckedUpdateWithoutSeoKeywordsInput>
  }

  export type BlogPostUpdateWithoutSeoKeywordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: BlogPostUpdatekeywordsInput | string[]
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    twitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentVersion?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    seoScore?: NullableFloatFieldUpdateOperationsInput | number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: AuthorUpdateOneRequiredWithoutPostsNestedInput
    category?: CategoryUpdateOneWithoutPostsNestedInput
    tags?: PostTagUpdateManyWithoutPostNestedInput
    seriesPosts?: SeriesPostUpdateManyWithoutPostNestedInput
    relatedPosts?: PostRelationUpdateManyWithoutOriginalPostNestedInput
    relatedToPosts?: PostRelationUpdateManyWithoutRelatedPostNestedInput
    versions?: PostVersionUpdateManyWithoutPostNestedInput
    views?: PostViewUpdateManyWithoutPostNestedInput
    interactions?: PostInteractionUpdateManyWithoutPostNestedInput
    seoEvents?: SEOEventUpdateManyWithoutPostNestedInput
    sitemapEntries?: SitemapEntryUpdateManyWithoutPostNestedInput
  }

  export type BlogPostUncheckedUpdateWithoutSeoKeywordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: BlogPostUpdatekeywordsInput | string[]
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    twitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    currentVersion?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    seoScore?: NullableFloatFieldUpdateOperationsInput | number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: PostTagUncheckedUpdateManyWithoutPostNestedInput
    seriesPosts?: SeriesPostUncheckedUpdateManyWithoutPostNestedInput
    relatedPosts?: PostRelationUncheckedUpdateManyWithoutOriginalPostNestedInput
    relatedToPosts?: PostRelationUncheckedUpdateManyWithoutRelatedPostNestedInput
    versions?: PostVersionUncheckedUpdateManyWithoutPostNestedInput
    views?: PostViewUncheckedUpdateManyWithoutPostNestedInput
    interactions?: PostInteractionUncheckedUpdateManyWithoutPostNestedInput
    seoEvents?: SEOEventUncheckedUpdateManyWithoutPostNestedInput
    sitemapEntries?: SitemapEntryUncheckedUpdateManyWithoutPostNestedInput
  }

  export type BlogPostCreateWithoutSitemapEntriesInput = {
    id?: string
    title: string
    slug: string
    excerpt?: string | null
    content: string
    contentType?: $Enums.ContentType
    status?: $Enums.PostStatus
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: BlogPostCreatekeywordsInput | string[]
    canonicalUrl?: string | null
    ogTitle?: string | null
    ogDescription?: string | null
    ogImage?: string | null
    twitterTitle?: string | null
    twitterDescription?: string | null
    twitterImage?: string | null
    featuredImage?: string | null
    featuredImageAlt?: string | null
    readingTime?: number | null
    wordCount?: number | null
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    archivedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currentVersion?: number
    viewCount?: number
    likeCount?: number
    shareCount?: number
    commentCount?: number
    seoScore?: number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: Date | string | null
    author: AuthorCreateNestedOneWithoutPostsInput
    category?: CategoryCreateNestedOneWithoutPostsInput
    tags?: PostTagCreateNestedManyWithoutPostInput
    seriesPosts?: SeriesPostCreateNestedManyWithoutPostInput
    relatedPosts?: PostRelationCreateNestedManyWithoutOriginalPostInput
    relatedToPosts?: PostRelationCreateNestedManyWithoutRelatedPostInput
    versions?: PostVersionCreateNestedManyWithoutPostInput
    views?: PostViewCreateNestedManyWithoutPostInput
    interactions?: PostInteractionCreateNestedManyWithoutPostInput
    seoEvents?: SEOEventCreateNestedManyWithoutPostInput
    seoKeywords?: SEOKeywordCreateNestedManyWithoutPostInput
  }

  export type BlogPostUncheckedCreateWithoutSitemapEntriesInput = {
    id?: string
    title: string
    slug: string
    excerpt?: string | null
    content: string
    contentType?: $Enums.ContentType
    status?: $Enums.PostStatus
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: BlogPostCreatekeywordsInput | string[]
    canonicalUrl?: string | null
    ogTitle?: string | null
    ogDescription?: string | null
    ogImage?: string | null
    twitterTitle?: string | null
    twitterDescription?: string | null
    twitterImage?: string | null
    featuredImage?: string | null
    featuredImageAlt?: string | null
    readingTime?: number | null
    wordCount?: number | null
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    archivedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
    categoryId?: string | null
    currentVersion?: number
    viewCount?: number
    likeCount?: number
    shareCount?: number
    commentCount?: number
    seoScore?: number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: Date | string | null
    tags?: PostTagUncheckedCreateNestedManyWithoutPostInput
    seriesPosts?: SeriesPostUncheckedCreateNestedManyWithoutPostInput
    relatedPosts?: PostRelationUncheckedCreateNestedManyWithoutOriginalPostInput
    relatedToPosts?: PostRelationUncheckedCreateNestedManyWithoutRelatedPostInput
    versions?: PostVersionUncheckedCreateNestedManyWithoutPostInput
    views?: PostViewUncheckedCreateNestedManyWithoutPostInput
    interactions?: PostInteractionUncheckedCreateNestedManyWithoutPostInput
    seoEvents?: SEOEventUncheckedCreateNestedManyWithoutPostInput
    seoKeywords?: SEOKeywordUncheckedCreateNestedManyWithoutPostInput
  }

  export type BlogPostCreateOrConnectWithoutSitemapEntriesInput = {
    where: BlogPostWhereUniqueInput
    create: XOR<BlogPostCreateWithoutSitemapEntriesInput, BlogPostUncheckedCreateWithoutSitemapEntriesInput>
  }

  export type BlogPostUpsertWithoutSitemapEntriesInput = {
    update: XOR<BlogPostUpdateWithoutSitemapEntriesInput, BlogPostUncheckedUpdateWithoutSitemapEntriesInput>
    create: XOR<BlogPostCreateWithoutSitemapEntriesInput, BlogPostUncheckedCreateWithoutSitemapEntriesInput>
    where?: BlogPostWhereInput
  }

  export type BlogPostUpdateToOneWithWhereWithoutSitemapEntriesInput = {
    where?: BlogPostWhereInput
    data: XOR<BlogPostUpdateWithoutSitemapEntriesInput, BlogPostUncheckedUpdateWithoutSitemapEntriesInput>
  }

  export type BlogPostUpdateWithoutSitemapEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: BlogPostUpdatekeywordsInput | string[]
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    twitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentVersion?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    seoScore?: NullableFloatFieldUpdateOperationsInput | number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: AuthorUpdateOneRequiredWithoutPostsNestedInput
    category?: CategoryUpdateOneWithoutPostsNestedInput
    tags?: PostTagUpdateManyWithoutPostNestedInput
    seriesPosts?: SeriesPostUpdateManyWithoutPostNestedInput
    relatedPosts?: PostRelationUpdateManyWithoutOriginalPostNestedInput
    relatedToPosts?: PostRelationUpdateManyWithoutRelatedPostNestedInput
    versions?: PostVersionUpdateManyWithoutPostNestedInput
    views?: PostViewUpdateManyWithoutPostNestedInput
    interactions?: PostInteractionUpdateManyWithoutPostNestedInput
    seoEvents?: SEOEventUpdateManyWithoutPostNestedInput
    seoKeywords?: SEOKeywordUpdateManyWithoutPostNestedInput
  }

  export type BlogPostUncheckedUpdateWithoutSitemapEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: BlogPostUpdatekeywordsInput | string[]
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    twitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    currentVersion?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    seoScore?: NullableFloatFieldUpdateOperationsInput | number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: PostTagUncheckedUpdateManyWithoutPostNestedInput
    seriesPosts?: SeriesPostUncheckedUpdateManyWithoutPostNestedInput
    relatedPosts?: PostRelationUncheckedUpdateManyWithoutOriginalPostNestedInput
    relatedToPosts?: PostRelationUncheckedUpdateManyWithoutRelatedPostNestedInput
    versions?: PostVersionUncheckedUpdateManyWithoutPostNestedInput
    views?: PostViewUncheckedUpdateManyWithoutPostNestedInput
    interactions?: PostInteractionUncheckedUpdateManyWithoutPostNestedInput
    seoEvents?: SEOEventUncheckedUpdateManyWithoutPostNestedInput
    seoKeywords?: SEOKeywordUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostTagCreateManyPostInput = {
    tagId: string
    createdAt?: Date | string
  }

  export type SeriesPostCreateManyPostInput = {
    seriesId: string
    order: number
    createdAt?: Date | string
  }

  export type PostRelationCreateManyOriginalPostInput = {
    id?: string
    relatedPostId: string
    relationType?: $Enums.RelationType
    createdAt?: Date | string
  }

  export type PostRelationCreateManyRelatedPostInput = {
    id?: string
    originalPostId: string
    relationType?: $Enums.RelationType
    createdAt?: Date | string
  }

  export type PostVersionCreateManyPostInput = {
    id?: string
    version: number
    title: string
    content: string
    excerpt?: string | null
    changeType?: $Enums.ChangeType
    changeNotes?: string | null
    authorId: string
    createdAt?: Date | string
  }

  export type PostViewCreateManyPostInput = {
    id?: string
    visitorId?: string | null
    sessionId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    referer?: string | null
    country?: string | null
    region?: string | null
    city?: string | null
    readingTime?: number | null
    scrollDepth?: number | null
    viewedAt?: Date | string
  }

  export type PostInteractionCreateManyPostInput = {
    id?: string
    type: $Enums.InteractionType
    visitorId?: string | null
    sessionId?: string | null
    value?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SEOEventCreateManyPostInput = {
    id?: string
    type: $Enums.SEOEventType
    title: string
    description?: string | null
    severity?: $Enums.SEOSeverity
    oldValue?: string | null
    newValue?: string | null
    recommendations?: string | null
    processed?: boolean
    processedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SEOKeywordCreateManyPostInput = {
    id?: string
    keyword: string
    position?: number | null
    searchVolume?: number | null
    difficulty?: number | null
    cpc?: number | null
    clicks?: number
    impressions?: number
    ctr?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastChecked?: Date | string | null
  }

  export type SitemapEntryCreateManyPostInput = {
    id?: string
    url: string
    lastMod: Date | string
    changeFreq?: $Enums.ChangeFrequency
    priority?: number
    included?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostTagUpdateWithoutPostInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tag?: TagUpdateOneRequiredWithoutPostsNestedInput
  }

  export type PostTagUncheckedUpdateWithoutPostInput = {
    tagId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostTagUncheckedUpdateManyWithoutPostInput = {
    tagId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeriesPostUpdateWithoutPostInput = {
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    series?: PostSeriesUpdateOneRequiredWithoutPostsNestedInput
  }

  export type SeriesPostUncheckedUpdateWithoutPostInput = {
    seriesId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeriesPostUncheckedUpdateManyWithoutPostInput = {
    seriesId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostRelationUpdateWithoutOriginalPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationType?: EnumRelationTypeFieldUpdateOperationsInput | $Enums.RelationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedPost?: BlogPostUpdateOneRequiredWithoutRelatedToPostsNestedInput
  }

  export type PostRelationUncheckedUpdateWithoutOriginalPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    relatedPostId?: StringFieldUpdateOperationsInput | string
    relationType?: EnumRelationTypeFieldUpdateOperationsInput | $Enums.RelationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostRelationUncheckedUpdateManyWithoutOriginalPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    relatedPostId?: StringFieldUpdateOperationsInput | string
    relationType?: EnumRelationTypeFieldUpdateOperationsInput | $Enums.RelationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostRelationUpdateWithoutRelatedPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationType?: EnumRelationTypeFieldUpdateOperationsInput | $Enums.RelationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originalPost?: BlogPostUpdateOneRequiredWithoutRelatedPostsNestedInput
  }

  export type PostRelationUncheckedUpdateWithoutRelatedPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalPostId?: StringFieldUpdateOperationsInput | string
    relationType?: EnumRelationTypeFieldUpdateOperationsInput | $Enums.RelationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostRelationUncheckedUpdateManyWithoutRelatedPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalPostId?: StringFieldUpdateOperationsInput | string
    relationType?: EnumRelationTypeFieldUpdateOperationsInput | $Enums.RelationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostVersionUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    changeType?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    changeNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: AuthorUpdateOneRequiredWithoutPostVersionsNestedInput
  }

  export type PostVersionUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    changeType?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    changeNotes?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostVersionUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    changeType?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    changeNotes?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostViewUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitorId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    referer?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    scrollDepth?: NullableFloatFieldUpdateOperationsInput | number | null
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostViewUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitorId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    referer?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    scrollDepth?: NullableFloatFieldUpdateOperationsInput | number | null
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostViewUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitorId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    referer?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    scrollDepth?: NullableFloatFieldUpdateOperationsInput | number | null
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostInteractionUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    visitorId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostInteractionUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    visitorId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostInteractionUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    visitorId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SEOEventUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSEOEventTypeFieldUpdateOperationsInput | $Enums.SEOEventType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: EnumSEOSeverityFieldUpdateOperationsInput | $Enums.SEOSeverity
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SEOEventUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSEOEventTypeFieldUpdateOperationsInput | $Enums.SEOEventType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: EnumSEOSeverityFieldUpdateOperationsInput | $Enums.SEOSeverity
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SEOEventUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSEOEventTypeFieldUpdateOperationsInput | $Enums.SEOEventType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: EnumSEOSeverityFieldUpdateOperationsInput | $Enums.SEOSeverity
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SEOKeywordUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    position?: NullableIntFieldUpdateOperationsInput | number | null
    searchVolume?: NullableIntFieldUpdateOperationsInput | number | null
    difficulty?: NullableFloatFieldUpdateOperationsInput | number | null
    cpc?: NullableFloatFieldUpdateOperationsInput | number | null
    clicks?: IntFieldUpdateOperationsInput | number
    impressions?: IntFieldUpdateOperationsInput | number
    ctr?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChecked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SEOKeywordUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    position?: NullableIntFieldUpdateOperationsInput | number | null
    searchVolume?: NullableIntFieldUpdateOperationsInput | number | null
    difficulty?: NullableFloatFieldUpdateOperationsInput | number | null
    cpc?: NullableFloatFieldUpdateOperationsInput | number | null
    clicks?: IntFieldUpdateOperationsInput | number
    impressions?: IntFieldUpdateOperationsInput | number
    ctr?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChecked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SEOKeywordUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    position?: NullableIntFieldUpdateOperationsInput | number | null
    searchVolume?: NullableIntFieldUpdateOperationsInput | number | null
    difficulty?: NullableFloatFieldUpdateOperationsInput | number | null
    cpc?: NullableFloatFieldUpdateOperationsInput | number | null
    clicks?: IntFieldUpdateOperationsInput | number
    impressions?: IntFieldUpdateOperationsInput | number
    ctr?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChecked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SitemapEntryUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    lastMod?: DateTimeFieldUpdateOperationsInput | Date | string
    changeFreq?: EnumChangeFrequencyFieldUpdateOperationsInput | $Enums.ChangeFrequency
    priority?: FloatFieldUpdateOperationsInput | number
    included?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SitemapEntryUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    lastMod?: DateTimeFieldUpdateOperationsInput | Date | string
    changeFreq?: EnumChangeFrequencyFieldUpdateOperationsInput | $Enums.ChangeFrequency
    priority?: FloatFieldUpdateOperationsInput | number
    included?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SitemapEntryUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    lastMod?: DateTimeFieldUpdateOperationsInput | Date | string
    changeFreq?: EnumChangeFrequencyFieldUpdateOperationsInput | $Enums.ChangeFrequency
    priority?: FloatFieldUpdateOperationsInput | number
    included?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostCreateManyAuthorInput = {
    id?: string
    title: string
    slug: string
    excerpt?: string | null
    content: string
    contentType?: $Enums.ContentType
    status?: $Enums.PostStatus
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: BlogPostCreatekeywordsInput | string[]
    canonicalUrl?: string | null
    ogTitle?: string | null
    ogDescription?: string | null
    ogImage?: string | null
    twitterTitle?: string | null
    twitterDescription?: string | null
    twitterImage?: string | null
    featuredImage?: string | null
    featuredImageAlt?: string | null
    readingTime?: number | null
    wordCount?: number | null
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    archivedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    categoryId?: string | null
    currentVersion?: number
    viewCount?: number
    likeCount?: number
    shareCount?: number
    commentCount?: number
    seoScore?: number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: Date | string | null
  }

  export type PostVersionCreateManyAuthorInput = {
    id?: string
    postId: string
    version: number
    title: string
    content: string
    excerpt?: string | null
    changeType?: $Enums.ChangeType
    changeNotes?: string | null
    createdAt?: Date | string
  }

  export type BlogPostUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: BlogPostUpdatekeywordsInput | string[]
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    twitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentVersion?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    seoScore?: NullableFloatFieldUpdateOperationsInput | number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: CategoryUpdateOneWithoutPostsNestedInput
    tags?: PostTagUpdateManyWithoutPostNestedInput
    seriesPosts?: SeriesPostUpdateManyWithoutPostNestedInput
    relatedPosts?: PostRelationUpdateManyWithoutOriginalPostNestedInput
    relatedToPosts?: PostRelationUpdateManyWithoutRelatedPostNestedInput
    versions?: PostVersionUpdateManyWithoutPostNestedInput
    views?: PostViewUpdateManyWithoutPostNestedInput
    interactions?: PostInteractionUpdateManyWithoutPostNestedInput
    seoEvents?: SEOEventUpdateManyWithoutPostNestedInput
    seoKeywords?: SEOKeywordUpdateManyWithoutPostNestedInput
    sitemapEntries?: SitemapEntryUpdateManyWithoutPostNestedInput
  }

  export type BlogPostUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: BlogPostUpdatekeywordsInput | string[]
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    twitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    currentVersion?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    seoScore?: NullableFloatFieldUpdateOperationsInput | number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: PostTagUncheckedUpdateManyWithoutPostNestedInput
    seriesPosts?: SeriesPostUncheckedUpdateManyWithoutPostNestedInput
    relatedPosts?: PostRelationUncheckedUpdateManyWithoutOriginalPostNestedInput
    relatedToPosts?: PostRelationUncheckedUpdateManyWithoutRelatedPostNestedInput
    versions?: PostVersionUncheckedUpdateManyWithoutPostNestedInput
    views?: PostViewUncheckedUpdateManyWithoutPostNestedInput
    interactions?: PostInteractionUncheckedUpdateManyWithoutPostNestedInput
    seoEvents?: SEOEventUncheckedUpdateManyWithoutPostNestedInput
    seoKeywords?: SEOKeywordUncheckedUpdateManyWithoutPostNestedInput
    sitemapEntries?: SitemapEntryUncheckedUpdateManyWithoutPostNestedInput
  }

  export type BlogPostUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: BlogPostUpdatekeywordsInput | string[]
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    twitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    currentVersion?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    seoScore?: NullableFloatFieldUpdateOperationsInput | number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PostVersionUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    changeType?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    changeNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: BlogPostUpdateOneRequiredWithoutVersionsNestedInput
  }

  export type PostVersionUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    changeType?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    changeNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostVersionUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    changeType?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    changeNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateManyParentInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    color?: string | null
    icon?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: CategoryCreatekeywordsInput | string[]
    postCount?: number
    totalViews?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogPostCreateManyCategoryInput = {
    id?: string
    title: string
    slug: string
    excerpt?: string | null
    content: string
    contentType?: $Enums.ContentType
    status?: $Enums.PostStatus
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: BlogPostCreatekeywordsInput | string[]
    canonicalUrl?: string | null
    ogTitle?: string | null
    ogDescription?: string | null
    ogImage?: string | null
    twitterTitle?: string | null
    twitterDescription?: string | null
    twitterImage?: string | null
    featuredImage?: string | null
    featuredImageAlt?: string | null
    readingTime?: number | null
    wordCount?: number | null
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    archivedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
    currentVersion?: number
    viewCount?: number
    likeCount?: number
    shareCount?: number
    commentCount?: number
    seoScore?: number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: Date | string | null
  }

  export type CategoryUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: CategoryUpdatekeywordsInput | string[]
    postCount?: IntFieldUpdateOperationsInput | number
    totalViews?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CategoryUpdateManyWithoutParentNestedInput
    posts?: BlogPostUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: CategoryUpdatekeywordsInput | string[]
    postCount?: IntFieldUpdateOperationsInput | number
    totalViews?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    posts?: BlogPostUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: CategoryUpdatekeywordsInput | string[]
    postCount?: IntFieldUpdateOperationsInput | number
    totalViews?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: BlogPostUpdatekeywordsInput | string[]
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    twitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentVersion?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    seoScore?: NullableFloatFieldUpdateOperationsInput | number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: AuthorUpdateOneRequiredWithoutPostsNestedInput
    tags?: PostTagUpdateManyWithoutPostNestedInput
    seriesPosts?: SeriesPostUpdateManyWithoutPostNestedInput
    relatedPosts?: PostRelationUpdateManyWithoutOriginalPostNestedInput
    relatedToPosts?: PostRelationUpdateManyWithoutRelatedPostNestedInput
    versions?: PostVersionUpdateManyWithoutPostNestedInput
    views?: PostViewUpdateManyWithoutPostNestedInput
    interactions?: PostInteractionUpdateManyWithoutPostNestedInput
    seoEvents?: SEOEventUpdateManyWithoutPostNestedInput
    seoKeywords?: SEOKeywordUpdateManyWithoutPostNestedInput
    sitemapEntries?: SitemapEntryUpdateManyWithoutPostNestedInput
  }

  export type BlogPostUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: BlogPostUpdatekeywordsInput | string[]
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    twitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    currentVersion?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    seoScore?: NullableFloatFieldUpdateOperationsInput | number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: PostTagUncheckedUpdateManyWithoutPostNestedInput
    seriesPosts?: SeriesPostUncheckedUpdateManyWithoutPostNestedInput
    relatedPosts?: PostRelationUncheckedUpdateManyWithoutOriginalPostNestedInput
    relatedToPosts?: PostRelationUncheckedUpdateManyWithoutRelatedPostNestedInput
    versions?: PostVersionUncheckedUpdateManyWithoutPostNestedInput
    views?: PostViewUncheckedUpdateManyWithoutPostNestedInput
    interactions?: PostInteractionUncheckedUpdateManyWithoutPostNestedInput
    seoEvents?: SEOEventUncheckedUpdateManyWithoutPostNestedInput
    seoKeywords?: SEOKeywordUncheckedUpdateManyWithoutPostNestedInput
    sitemapEntries?: SitemapEntryUncheckedUpdateManyWithoutPostNestedInput
  }

  export type BlogPostUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: BlogPostUpdatekeywordsInput | string[]
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    twitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    currentVersion?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    seoScore?: NullableFloatFieldUpdateOperationsInput | number | null
    seoAnalysis?: NullableJsonNullValueInput | InputJsonValue
    lastSeoCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PostTagCreateManyTagInput = {
    postId: string
    createdAt?: Date | string
  }

  export type PostTagUpdateWithoutTagInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: BlogPostUpdateOneRequiredWithoutTagsNestedInput
  }

  export type PostTagUncheckedUpdateWithoutTagInput = {
    postId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostTagUncheckedUpdateManyWithoutTagInput = {
    postId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeriesPostCreateManySeriesInput = {
    postId: string
    order: number
    createdAt?: Date | string
  }

  export type SeriesPostUpdateWithoutSeriesInput = {
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: BlogPostUpdateOneRequiredWithoutSeriesPostsNestedInput
  }

  export type SeriesPostUncheckedUpdateWithoutSeriesInput = {
    postId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeriesPostUncheckedUpdateManyWithoutSeriesInput = {
    postId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}